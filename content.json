{"meta":{"title":"韦绍炜的博客","subtitle":"","description":"","author":"wsw","url":"https://WiSiW.github.io.git","root":"/"},"pages":[],"posts":[{"title":"[]音视频播放","slug":"音视频播放","date":"2023-09-25T06:38:55.000Z","updated":"2023-09-25T06:38:55.041Z","comments":true,"path":"2023/09/25/音视频播放/","link":"","permalink":"https://wisiw.github.io.git/2023/09/25/%E9%9F%B3%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"【Python】摄像头姿势识别","slug":"【Python】摄像头姿势识别","date":"2023-09-15T12:45:44.000Z","updated":"2023-09-25T14:27:00.564Z","comments":true,"path":"2023/09/15/【Python】摄像头姿势识别/","link":"","permalink":"https://wisiw.github.io.git/2023/09/15/%E3%80%90Python%E3%80%91%E6%91%84%E5%83%8F%E5%A4%B4%E5%A7%BF%E5%8A%BF%E8%AF%86%E5%88%AB/","excerpt":"","text":"搭建环境以及所需的库123python:3.7opencv-pythonmediapipe 识别点位对照表 1234567891011121314151617181920212223242526272829303132330 - nose1 - left eye (inner)2 - left eye3 - left eye (outer)4 - right eye (inner)5 - right eye6 - right eye (outer)7 - left ear8 - right ear9 - mouth (left)10 - mouth (right)11 - left shoulder12 - right shoulder13 - left elbow14 - right elbow15 - left wrist16 - right wrist17 - left pinky18 - right pinky19 - left index20 - right index21 - left thumb22 - right thumb23 - left hip24 - right hip25 - left knee26 - right knee27 - left ankle28 - right ankle29 - left heel30 - right heel31 - left foot index32 - right foot index 1.启动摄像头","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://wisiw.github.io.git/tags/Python/"},{"name":"openCV","slug":"openCV","permalink":"https://wisiw.github.io.git/tags/openCV/"},{"name":"姿势识别","slug":"姿势识别","permalink":"https://wisiw.github.io.git/tags/%E5%A7%BF%E5%8A%BF%E8%AF%86%E5%88%AB/"},{"name":"图像识别","slug":"图像识别","permalink":"https://wisiw.github.io.git/tags/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"}]},{"title":"【Python】摄像头手势识别","slug":"【Python】摄像头手势识别","date":"2023-09-15T12:45:44.000Z","updated":"2023-09-25T14:31:36.785Z","comments":true,"path":"2023/09/15/【Python】摄像头手势识别/","link":"","permalink":"https://wisiw.github.io.git/2023/09/15/%E3%80%90Python%E3%80%91%E6%91%84%E5%83%8F%E5%A4%B4%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB/","excerpt":"","text":"搭建环境以及所需的库123python:3.7opencv-pythonmediapipe 识别点位对照表 1234567891011121314151617181920210 - WRIST1 - THUMB_CMC2 - THUMB_MCP3 - THUMB_IP4 - THUMB_TIP5 - INDEX_FINGER_MCP6 - INDEX_FINGER_PIP7 - INDEX_FINGER_DIP8 - INDEX_FINGER_TIP9 - MIDDLE_FINGER_MCP10 - MIDDLE_FINGER_PIP11 - MIDDLE_FINGER_DIP12 - MIDDLE_FINGER_TIP13 - RING_FINGER_MCP14 - RING_FINGER_PIP15 - RING_FINGER_DIP16 - RING_FINGER_TIP17 - PINKY_MCP18 - PINKY_PIP19 - PINKY_DIP20 - PINKY_TIP 1.启动摄像头123456789import cv2cap = cv2.VideoCapture(0)while True: success, img = cap.read() cv2.imshow(&#x27;Image&#x27;, img) cv2.waitKey(1) 2.识别手部动作1234567891011121314151617import cv2import mediapipe as mpcap = cv2.VideoCapture(0)mpHands = mp.solutions.handshands = mpHands.Hands()while True: success, img = cap.read() imgRGB = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) results = hands.process(imgRGB) print(results.multi_hand_landmarks) cv2.imshow(&#x27;Image&#x27;, img) cv2.waitKey(1) 识别出的数据每个手部21个点位 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107[landmark &#123; x: 0.731960117816925 y: 0.8602098822593689 z: 3.7826006860086636e-07&#125;landmark &#123; x: 0.6678993701934814 y: 0.825223445892334 z: -0.022978829219937325&#125;landmark &#123; x: 0.6120011806488037 y: 0.7446209192276001 z: -0.032867904752492905&#125;landmark &#123; x: 0.5765049457550049 y: 0.676508903503418 z: -0.04126569628715515&#125;landmark &#123; x: 0.5479035973548889 y: 0.6209680438041687 z: -0.04858679696917534&#125;landmark &#123; x: 0.6559033989906311 y: 0.5685721039772034 z: -0.009198924526572227&#125;landmark &#123; x: 0.6436667442321777 y: 0.45814454555511475 z: -0.02262815274298191&#125;landmark &#123; x: 0.6395666599273682 y: 0.391674280166626 z: -0.03663289546966553&#125;landmark &#123; x: 0.6381848454475403 y: 0.3321998417377472 z: -0.04805788770318031&#125;landmark &#123; x: 0.6958205103874207 y: 0.5510193109512329 z: -0.013065477833151817&#125;landmark &#123; x: 0.6914491653442383 y: 0.42552679777145386 z: -0.023112589493393898&#125;landmark &#123; x: 0.6911518573760986 y: 0.3481542468070984 z: -0.03534790873527527&#125;landmark &#123; x: 0.6909988522529602 y: 0.2837005853652954 z: -0.0455666109919548&#125;landmark &#123; x: 0.7336719036102295 y: 0.5597383379936218 z: -0.02150423638522625&#125;landmark &#123; x: 0.734130859375 y: 0.4429841935634613 z: -0.03502415493130684&#125;landmark &#123; x: 0.7332345247268677 y: 0.3698875904083252 z: -0.04540318623185158&#125;landmark &#123; x: 0.7308086156845093 y: 0.3045901954174042 z: -0.053850580006837845&#125;landmark &#123; x: 0.7715479731559753 y: 0.5895281434059143 z: -0.032650720328092575&#125;landmark &#123; x: 0.7856296300888062 y: 0.5011546611785889 z: -0.046174854040145874&#125;landmark &#123; x: 0.7944579124450684 y: 0.44144606590270996 z: -0.05218689516186714&#125;landmark &#123; x: 0.8009870052337646 y: 0.3834943175315857 z: -0.05687923729419708&#125;] 以上只是将手指点位信息打印到控制台，接下来要将点位信息在视频中显示出来 123456789101112131415161718192021import cv2import mediapipe as mpcap = cv2.VideoCapture(0)mpHands = mp.solutions.handshands = mpHands.Hands()mpDraw = mp.solutions.drawing_utilswhile True: success, img = cap.read() imgRGB = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) results = hands.process(imgRGB) print(results.multi_hand_landmarks) if results.multi_hand_landmarks: for handLms in results.multi_hand_landmarks: mpDraw.draw_landmarks(img, handLms, mpHands.HAND_CONNECTIONS) cv2.imshow(&#x27;Image&#x27;, img) cv2.waitKey(1) 使用了mp.solutions.drawing_utils.draw_landmarks将点位信息在视频中显示出来 3.显示fps123456789101112131415161718import cv2import mediapipe as mpimport timecap = cv2.VideoCapture(0)cTime = 0pTime = 0while True: success, img = cap.read() cTime = time.time() fps = 1 / (cTime - pTime) pTime = cTime cv2.putText(img, str(int(fps)), (10, 70), cv2.FONT_HERSHEY_PLAIN, 3, (255, 255, 255), 3) cv2.imshow(&#x27;Image&#x27;, img) cv2.waitKey(1) 4.获取手掌点位信息12345678910111213141516171819202122232425import cv2import mediapipe as mpcap = cv2.VideoCapture(0)mpHands = mp.solutions.handshands = mpHands.Hands()mpDraw = mp.solutions.drawing_utilswhile True: success, img = cap.read() imgRGB = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) results = hands.process(imgRGB) if results.multi_hand_landmarks: for handLms in results.multi_hand_landmarks: for id, lm in enumerate(handLms.landmark): h, w, c = img.shape cx, cy = int(lm.x * w), int(lm.y * h) cv2.circle(img, (cx, cy), 15, (255, 0, 0), cv2.FILLED) mpDraw.draw_landmarks(img, handLms, mpHands.HAND_CONNECTIONS) cv2.imshow(&#x27;Image&#x27;, img) cv2.waitKey(1) 以上既是手势识别的基本代码 全部代码（模块化）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import cv2import mediapipe as mpimport timeclass handDetector(): def __init__(self, mode=False, maxHands=2, complexity=1, detectionCon=0.5, trackCon=0.5): self.mode = mode self.maxHands = maxHands self.complexity = complexity self.detectionCon = detectionCon self.trackCon = trackCon self.mpHands = mp.solutions.hands self.hands = self.mpHands.Hands(self.mode, self.maxHands, self.complexity, self.detectionCon, self.trackCon) self.mpDraw = mp.solutions.drawing_utils def findHands(self, img, draw=True): imgRGB = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) self.results = self.hands.process(imgRGB) # print(results.multi_hand_landmarks) if self.results.multi_hand_landmarks: for handLms in self.results.multi_hand_landmarks: if draw: self.mpDraw.draw_landmarks(img, handLms, self.mpHands.HAND_CONNECTIONS) return img def findPosition(self, img, handNo=0, draw=True): lmList = [] if self.results.multi_hand_landmarks: myHands = self.results.multi_hand_landmarks[handNo] for id, lm in enumerate(myHands.landmark): h, w, c = img.shape cx, cy = int(lm.x * w), int(lm.y * h) lmList.append([id, cx, cy]) if draw: cv2.circle(img, (cx, cy), 15, (255, 0, 0), cv2.FILLED) return lmListdef main(): pTime = 0 cTime = 0 cap = cv2.VideoCapture(0) detector = handDetector() print(1) while True: success, img = cap.read() img = detector.findHands(img) lmList = detector.findPosition(img) if len(lmList) != 0: print(lmList[4]) cTime = time.time() fps = 1 / (cTime - pTime) pTime = cTime cv2.putText(img, str(int(fps)), (10, 70), cv2.FONT_HERSHEY_PLAIN, 3, (255, 255, 255), 3) cv2.imshow(&#x27;Image&#x27;, img) cv2.waitKey(1)if __name__ == &quot;__main__&quot;: main()","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://wisiw.github.io.git/tags/Python/"},{"name":"openCV","slug":"openCV","permalink":"https://wisiw.github.io.git/tags/openCV/"},{"name":"图像识别","slug":"图像识别","permalink":"https://wisiw.github.io.git/tags/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"},{"name":"手势识别","slug":"手势识别","permalink":"https://wisiw.github.io.git/tags/%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB/"}]},{"title":"【业务梳理】模板开发","slug":"【业务梳理】模板开发","date":"2023-09-13T06:33:45.000Z","updated":"2023-09-14T01:46:10.486Z","comments":true,"path":"2023/09/13/【业务梳理】模板开发/","link":"","permalink":"https://wisiw.github.io.git/2023/09/13/%E3%80%90%E4%B8%9A%E5%8A%A1%E6%A2%B3%E7%90%86%E3%80%91%E6%A8%A1%E6%9D%BF%E5%BC%80%E5%8F%91/","excerpt":"","text":"主要是对参与过项目的回顾，固定成一整套模块 何为模板开发在业务中主要是为了解决APP端的重复开发，节约人力。是将主要的几个展示模块抽出成为固定模版。比如说一般展示页面都会有的轮播图，在以前的开发中，轮播图的数据","categories":[],"tags":[{"name":"业务梳理","slug":"业务梳理","permalink":"https://wisiw.github.io.git/tags/%E4%B8%9A%E5%8A%A1%E6%A2%B3%E7%90%86/"}]},{"title":"A Plea for Pure Science","slug":"A-Plea-for-Pure-Science","date":"2023-09-12T13:35:51.000Z","updated":"2023-09-12T13:36:33.515Z","comments":true,"path":"2023/09/12/A-Plea-for-Pure-Science/","link":"","permalink":"https://wisiw.github.io.git/2023/09/12/A-Plea-for-Pure-Science/","excerpt":"","text":"为纯科学呼吁 A Plea for Pure Science 亨利-奥古斯特-罗兰/Henry Augustus Rowland 编者按：1883年8月15日，美国著名物理学家、美国物理学会第一任会长亨利·奥古斯特·罗兰(1848－1901)在美国科学促进会（AAAS）年会上做了题为“为纯科学呼吁”的演讲。该演讲的文字后发表在1883年8月24日出版的Science杂志上，并被誉为“美国科学的独立宣言”。中科院科学时报社主办的《科学新闻》杂志2005年第5期全文发表了这篇演讲的中译文（王丹红译，王鸿飞校，小标题为译者所加）。一百多年后重读罗兰的“为纯科学呼吁”演讲，可以感觉到今日中国的科学发展与美国当年颇有相似之处。在当前我国科技界尚存在许多急功近利、浮躁浮夸以及学术不端行为等现象的情况下，罗兰先生的文章更是具有洞穿历史的警世作用。它山之石，可以攻玉，征得科学时报社同意，我刊特将演讲译文全文转发，以期对我国科学发展和现代化建设提供一定的借鉴。 有时我们会被问及这样的问题：你最喜欢一年中的哪段时光？对我来说，春天最令人愉快，大自然从冷漠的冬天中苏醒，生命的力量又开始涌动。树叶生长、蓓蕾绽放，眼前的一切生机盎然，令人赏心悦目。在这大自然生命复苏的时刻，我们的心也为之狂喜。但是美景不会永恒，叶子会到达它的生命极限，花蕾盛开后就走向枯萎。于是，我们开始问自己这样的问题：这一切是否最终都归于虚无，或者它会带来丰硕的收成？ 在它的成长过程中，我们这个伟大的国家也有着春天般无以匹敌的勃勃生机。森林被砍伐，城市被建立，一个伟大而强盛的国家在地球上被创造出来。我们为自己的进步而骄傲。我们为这些新生的城市而骄傲，仅仅在几年前，这些地方还只是美洲印地安人狩猎美洲野牛的地方。但是，我们必须记住现在只是我们国家的春天。我们的眼光不能向后看。无论叶子多么美丽、花儿多么鲜艳、它们生长的速度多么令人惊叹，但叶子毕竟是叶子，花终究是花。我们更应该向前看，去发现这些繁荣的结果是什么，收获的机会是什么。如果我们及时地这样做，那么我们也许能发现那些威胁果实成熟的害虫，或者看到收获正因缺水而受到摧毁的贫瘠之地。 1 为了应用科学，科学本身必须存在 我应邀在今年AAAS年会的物理学分会上作报告。我乐意在这个题目上讲让你们高兴的事，我乐意向你们列举我的同胞们在此领域所取得的进步，他们为认识宇宙的秩序而付出的高贵努力。但是，当我走出去收集等待收割的谷物时，我发现的却只是杂草。杂草丛中散落着一些鹤立鸡群的高贵谷穗。但是，它们是如此之少，以至我发现我的大多数同胞并不了解这些现状，还以为他们有一场大丰收，而实际上最终等待他们收获的不过是杂草。美国的科学只存在未来，它没有今天和过去。在我这个位置上的人应该思考的问题是：我们必须要做些什么才能创造出我国的物理学，而不是把电报机、电灯和其它的便利设施称之为科学。我并不是想低估所有这些东西的价值，世界的进步需要依靠它们，成功发明这些东西的人应该受到世界的尊重。但是，虽然一位厨师发明了餐桌上的一道新鲜的美味佳肴，使世人在某种程度上享受到了口福，但是，我们并不会尊称他为化学家。但是，人们将应用科学与纯科学混为一谈并不是罕见之事，特别是在美国的报纸上。一些卑微的美国人偷取过去伟大人物的思想，通过这些思想在日常生活中的应用让自己富裕，他们得到的赞美高于那些提出这些思想的伟大原创者。如果这些原创者思想中有一些庸俗成分，他们早就可以做出成百种这样的应用。我时常被问及这样的问题：纯科学与应用科学究竟哪个对世界更重要。为了应用科学，科学本身必须存在。假如我们停止科学的进步而只留意科学的应用，我们很快就会退化成中国人那样，多少代人以来他们（在科学上）都没有什么进步，因为他们只满足于科学的应用，却从来没有追问过他们所做事情中的原理。这些原理就构成了纯科学。中国人知道火药的应用已经若干世纪，如果他们用正确的方法探索其特殊应用的原理，他们就会在获得众多应用的同时发展出化学，甚至物理学。因为只满足于火药能爆炸的事实，而没有寻根问底，中国人已经远远落后于世界的进步。我们现在只是将这个所有民族中最古老、人口最多的民族当成野蛮人。然而，我们的国家也正处于同样的状况。不过，我们可以做得更好，因为我们获得了欧洲世界的科学，并将它们应用到生活的方方面面。我们就像接受从天空中落下的雨水那样理所应当地接过这些科学知识，既不问它们究竟从哪里来，也没有感激为我们提供这些知识的伟大、无私的人们的恩情。就像天堂之雨一样，纯科学降临到我们的国家，让我们的国家更加伟大、富裕和强壮。 对于今天已经文明化的一个国家来说，科学的应用是必需的。迄今为止，我们的国家在这条路上走得很成功，因为纯科学在世界上的某些国家中存在并得到培养，对自然的科学研究在这些国家中被尊敬为高贵的追求。但这样的国家实在稀少，在我国，希望从事纯科学研究的人必须以更多的道德勇气来面对公众的舆论。他们必须接受被每一位成功的发明家所轻视的可能，在他们肤浅的思想中，这些人以为人类唯一的追求就是财富，那些拥有最多财富的人就是世界上最成功的人。每个人都理解100万美元的意义，但能够理解科学理论进展的人屈指可数，特别是对科学理论中最抽象的部分。我相信这是只有极少数人献身于人类至高的科学事业的原因之一。人是社会动物，他们的幸福感非常依赖于周围人的认同，只有极少数的人有勇气追求自己的梦想而不在乎所处的环境。过去的人们比现在更为与世隔绝，一个人只和少数几个人交往。 因此，那时的人们有时间创造出伟大的雕塑、绘画和诗歌。每个人的思想都可以相对自由地追随自己的想法，结果就成就了古代大师们伟大、非凡的作品。今天的铁路、电报、书籍和报纸将世界各地的每个人联结起来，他的思想不再是个人的，不再是独立和独特的，它要受到外部世界的影响，并依赖于外部世界，因此在极大的程度上失去了原创性。按照今天的标准，过去的天才在精神上和物质上可能都非常贫乏，周围弥漫着傲慢的建议告诉他如何使其外表与自己的身份相符。他从来没有新想法，但他至少能吸收他人的思想来填充自己苍白的精神世界。所以，这位过去时代的天才很快就意识到自己的思想比别人高得太多而不为世人所尊重：他的思想被裁剪成标准形式，所有新生的分支被压制，直到他不再高于他周围的人。从此，世界通过这种过多的交流降低到同一个水平。过去的陆地拥有我们今天无法欣赏到的高耸入云的大山和幽暗的深谷，它们安静、平和，构成了伟大壮丽的陆上风景。如今，深谷被填充、高山被削平，随风起伏的麦浪和冒烟的工厂成为大地上的风景。 在普通人看来，这是好的变化。较之以往，人们的生活更快乐，精神状态更好。但我们失去了高山赋予的气势。我们厌倦平庸，这是我们国家所遭受的诅咒。我们厌恶地看到我们的艺术家只为金钱而工作，并且恳求国会保护他们以避免外国人的竞争。我们厌恶地看到我们的同胞从国外获取科学，然后夸耀他们在这里将其转化为财富。我们厌恶地看到，我们的教授因追求应用科学而不是纯科学从而损害了教授的声誉，当整个世界有待研究时他们却麻木不仁，当整个宇宙的问题有待解决时他们却袖手旁观。我们希望这个国家在平庸之上尚有更崇高和尊贵的东西，一座高山也能让风景不再是单调沉闷。我们被奥秘所包围，大自然赋予了我们情感去享受这些奥秘，赋予我们理智去揭开这些奥秘。大自然呼唤着我们去研究它，我们更好的感悟力也促使我们走向这同一方向。 多少代人来，只有少数学习科学的学生将对自然的研究珍视为最崇高的追求。无论富裕或者贫穷，他们都有一个共同点：对自然及其规律充满热爱。世界因科学的应用而带来的进步应归功于这少数人，但他们中只有极少数曾从世人那里得到他们应有的回报。 法拉弟(Faraday Michael，1791-1867，英国物理学、化学家，1831年发现电磁感应现象并提出相应理论，后被麦克斯维和爱因斯坦进一步发展)是所有电光机器、电气铁路、电力传输等基本原理的伟大发现者，尽管整个世界因他的发现而富裕，但他却死于贫困。这也是今后一段时期中跟随他脚步的人必将面对的命运。 但是，未来还是有因纯粹热爱而研究自然的人，以前人们未曾获得过的更崇高的奖赏在等待着他们。我们已经开始追求科学，站在门槛上想知道里面究竟有什么。我们通过重力定律解释了行星的运动，但是谁将解释是什么样的力量让两个相隔数百万英里的天体彼此相向运动呢？ 今天，我们能够非常容易地测量电量和电流，但是我们有方法来解释电的现象吗？光是波动的，但我们知道波动的是什么吗？热是一种运动，但我们知道运动着的是什么吗？普通物质随处可见，但是谁探究出了其内部组成的奥秘呢？ 所有参与工作的人都有机会，竞赛已经开始。问题的解决不是一蹴而就的事，它需要在不确定的时间里，用最优秀的头脑做出最好的工作。 当其它国家在竞赛中领先时，我们国家能满足于袖手旁观吗？难道我们总是匍匐在尘土中去捡富人餐桌上掉下来的面包屑、并因为我们有更多的面包屑而认为自己比他更富裕吗？但我们忘记了这样的事实：他拥有面包，这是所有面包屑的来源。难道我们卑贱如猪，认为谷粒和谷壳的价值比珍珠高得多吗？如果我对时代的认识是正确的，那么我认为我们不应该满足于我们低下的地位。目标低下使我们几乎变成了瞎子，但这是可以恢复的。在一个新国家中，生存的需求是首先需要关注的事情。亚当受到的诅咒降临到所有人身上，我们必须自己养活自己。 但是，让整个世界更轻松地生活是应用科学的使命。我读到过这样一个故事，它阐明了应用科学在世界上的真实地位。在蒸气机时代的早期，一个热爱阅读甚于工作的男孩获得了一份工作，他的职责是在每次引擎运动时开关阀门。男孩的阅读被他的工作所打乱，他很快发现通过将阀门与引擎的活动部分联结起来，让活塞的运动带动阀门的运动，他就能从工作中解脱出来。这个故事说明需求是发明之母，所以我认为人类真正的追求是智慧。对自然所有分支的科学研究、对数学的研究、对人类过去和现在的研究、对艺术的追求，以及对所有这些事业的培育是这个世界上最伟大、最高贵的事业，它们是人类最高级的职业。对有更高理想的人来说，商业、科学的应用、财富的积累是一种诅咒，但对世界上那些没有能力从事和鉴赏崇高追求的人来说，却是一种祝福。 2 教授的职责是促进科学进步 随着科学应用的日益增加，生活变得越来越容易，购买仪器所必须的经费也不难获得，追求生存之外的其它东西成为了可能。 但是，在能够更多地从事纯科学之前，精神品质的培育应该与国家财富的增长平衡。通过合法的专业工作，成功的雕塑家或画家自然能够获得财富。对小说家、诗人和音乐家们来说，职业成功就意味着财富。但是，科学家们和数学家们却从未有过这种对工作的动力：他们必须通过做其它工作如教学等来维持生活，只能将业余时间奉献给对科学的追求。通常情况是，因为所挣得的薪水少得可怜、因为仪器设备和资料文献的匮缺、因为他们所处的精神环境，而更重要的是因为生活理想不高，他们被迫将自己的业余时间花在给应用科学或其它增加财富的手段上。那么，我们该怎样兑现对那些少数人中的少数人的尊敬呢？尽管也面临所有这些现实困难，他们仍然坚定不移地认定目标，持之以恒地从事纯科学研究，给这个世界最珍贵的贡献，他们创造的伟大知识丰富了我们对宇宙的认识，当这些知识被应用到物质生活时，成千上万人的生活更加富裕，我们中的每个人都受益于此。也有这样一些人，他们拥有从事纯科学研究所需的所有设施，他们拥有丰厚的薪水以及每一件工作仪器，但却全力投入了商业性的工作，他们到法院作证，去做其它可增加现有丰厚收入的工作。如果这些人放弃教授的头衔，而冠之以化学顾问专家或物理学顾问专家的称谓，那么他们是值得受到尊重的。我们的社会确实需要这样的人。但是，如果一个人拥有最著名大学的教授席位，而他的精力和能力却用在科学知识的商业化应用上，他以尊贵的身份出现在社区，在报纸又成为科学的解释者，那么这对他和他所在的学院来说都是一种耻辱。这是对其所在科学事业的致命打击。给他以恰如其分的称谓，他马上就会成为这个社会中有用的一员。将一个按规则并能以身作则培育科学的人放在他的职位上，结果会多么的不同！那些正在世上寻找生活目标的年轻人，看到他们眼前这个高尚和高贵的人生，他们就会发现世界上还有比积累财富更为尊贵的东西。于是他们就愿意将生命奉献给相同的事业，他们就会尊重那些将他们引向更高境界的教授，这一境界是他们通过其它途径所不能企及的。 我并不想在这个问题上被误解。因发明而获得财富或者在某些情况下从事商业化的科学工作并不是一件有失体面的事。但是，纯科学应该是具有教授职位的人的追求目标，这个目标之伟大是毫无疑问的。如果我们生活的目标是追求财富，那就让我们诚实地从事商业，与他人竞争财富。但是，如果我们选择了我们认为更崇高的事业，那么就说到做到，无论贫富都随遇而安，二者都不能改变既定的追求。 教学工作会消耗大部分精力，这也是绝大多数在教授职位上不进行任何科学工作的人的一个借口。但是常言道：有志者事竟成。很少本国教授所承担的教学或演讲工作像德国教授那么繁重，后者却以在科学期刊上发表详细阐述、精心写作的论文而著名。我自己也肩负教育工作，深知这意味着什么。然而，在这里我仍然坚持认为：只要您愿意，您就会找出时间来做科学研究。但是，在这里我们依然无法逃避这个国家的诅咒：平庸。我们的学院和大学很少寻找有声誉的一流水平人士，我甚至听说过这样的事，一所知名学院的董事曾经声称教授不需要做研究，因为这是浪费时间。我高兴地看到在该学院的优秀科学家的呼吁下，该董事会的大多数董事都不认可这位董事的观点。 毫无疑问，教学工作是重要的。一位成功的教师应该受到尊重。但是，如果他没有引导学生向最高方向努力，难道他不该受到谴责吗？我们国家的绝大多数纯科学都是在大学和学院中进行的，现在，让我们看看这些大学和学院的状况。首先我们看看现状是怎样的。 3 什么样的机构才称得上大学 有一位人士，我们可能会称他为罗斯金(John Ruskin, 1819-1900，英国作家和艺术评论家，他认为伟大的图画应是能够给观赏者以伟大的思想)的实际追随者，他声称在这个国家里他拥有船长、上校和教授等多种头衔。这个故事真实与否并不重要，但我们都知道我们同胞们的习惯是对此没有原则性的争议。所有的人生而平等：有的人既是船长又是上校，又是教授，因此所有的人可以这样。这个逻辑是决定性的；相同的逻辑也适用于了我们的中小学、学院和大学。我手上有一份教育专员在1880年写的报告。根据这份报告，我们国家有380或者400个左右的机构称自己为学院或大学！我们或许可以借此声称我们是一个伟大的国家，我们拥有大学的数量比世界上其它国家的总数还要多。事实足够明确，整个世界也基本上很难有能力支持如此多的一流大学。它们一窝蜂地出现，平庸的诅咒一定会降临到它们身上。它们必定是一群蚊虫，而不是自诩的雄鹰。深入的分析将证实这一观点。约有三分之一的这些机构渴望被称为大学。我需要指出的是，一个只有2名教授和18名学生的机构也称自己是大学。而另外一所“大学”有3名教授和12位学生!这些例子并不罕见，自称为大学的小型机构和学校的数量相当高。很难从这些学校的统计数据决定它们的准确地位。极端的情况比较容易处理。谁能怀疑一所拥有800名学生和70名教员的机构会比拥有10或20名学生、2名或3名教授的学校要高出一个等级呢？然而，这并不总是对的。我知道的一所拥有500多名学生的机构，按我个人的标准来看不过相当于一所高中。统计数据有或多或少的缺陷，如果我仔细推究的话会有更多的弱点。我列举出下面的数字： 1）在330所自称为学院或大学的机构中，其中218 所机构的学生数在0到100之间， 88所机构的学生数在100到200之间，12所机构的学生数在200到300之间， 6所机构的学生数在300到500之间， 6所机构的学生数超过500；2）在322所自称为学院或大学的机构中，其中206所机构的教员数在0到10之间，99所机构的教员数在10到20之间，17所机构的教员数在20以上。 我们也许能够通过学生的平均年龄了解这些机构的地位，以及实现真正的大学理想的方式，这些统计数据是可以获得的，也或者它们已经存在。学生与教师的比例数据也会有所帮助。所有的这些方法都只给出这些机构现有地位的大概情况。但还有一种方法可解决这个问题，这会很准确，但只限于告诉我们该机构可能的潜力。我指的是这个机构的财产。在估计财产时，我没有纳入土地和建筑物的价值。因为好的工作既可在宫殿中做出也可在陋屋中做出。我用研究机构的运转性经费作为估算的标准，我发现：234所机构的低于50万美元；8所机构的在50万美元—100万美元；8所机构的在100万美元以上。 不容置疑，世界上的高等教育机构都不可能自己养活自己，这是一个再清楚不过的事。通常的情况是，一个学院教育一位年轻人的成本远远高于他所交的学费，成本一般是学费的3到4倍。教育的层次越高，这个比例就会越大，一所最高等级的大学只能期望学费占其收入的一小部分。因此，在所有事例中，我所用的方法都给出了可能的真实性。根据这些数字，只有16所学院和大学的投入金额达到或超过了50万，其中只有一半的基金达到或超过了100万。后面这个数字对一所学院来说也是非常小的；在世界上将一所经费不足100万美元的机构称为大学，实在荒唐。然而，我们有100多所这样机构就是以这样的方式滥用了“大学”之名，但实际上它们中的大多数是值得尊敬的学院。其中那些值得尊敬的学院获得的捐赠还有望增加，这是它们应得的，也许长久以来它们还一直在为自己的不幸称谓而自责。 但是，我们应该如何看待一个社区呢？它将大学特许状颁发给只有2万美元捐赠经费、2名所谓的教授和18位学生的机构，或者有3名教授、12名学生、捐赠经费只为2.7万美元的机构，而且绝大部分经费都花在大楼上。此外，还有相当多的类似机构，有16所机构只有3位或更少的教授，更多机构确实只有4-5位教授。 这类的事实只会存在于一个民主的国家，它所自豪的是将所有的东西都降低到同一层次。或许我可以这样说，这类事情只可能存在于这样一个民主国家的早期，因为明智的公众很快就会发现：一个错误的称谓并不能改变事物本身的性质。这一真理才是我们应该告诉这个国家的青年人的最为重要的事情。 人们也许会争辩说，所有这些机构在教育方面都做出了好工作；许多负担不起学院和大学费用的年轻人在这里接受教育。我并不反对教育，虽然我相信调查会揭示出这种说法之荒谬，但这种说法并不是我要反对的。我所反对的是降低我们国家年轻人的理想。要让他们知道他们正在上的是一所学校而不是一所大学；要让他们知道学校之上是学院，学院之上是大学。要让他们知道他们只接受了一半的教育，他们与世界上的一些人相比如原子般微不足道。换句话说，他们应该被告知真相。 也许也有一些小型机构有较高的地位，特别是那些新建的机构，但是谁也不怀疑，在我们那些自称为学院或大学的机构中，至少有三分二是名不符实的。每一个这样的机构都有所谓的教授，但事实证明他们至多称得上是一般教师。为什么不这样称呼他们呢？教师是一个受尊重的职位，但这个职位不会因一个假定的错误头衔而变得更为崇高。而且，头衔越多、越容易获得，它就越没有值得追求的价值。当一个充满精力、能力或者是天赋的人所得到的头衔和薪水与一个只有很少知识的普通人相同时，而后者教书的原因不是他能够胜任这一工作，而很可能是因为他没有能力在商业上与别人竞争，那么我会说，鼓励一流水平的人成为教授的动力之一就不复存在了。 当教授职位的工作和能力有明确要求时，当教授被要求要跟上所在领域的发展并要尽全力促进领域的发展时，而且当他是因这些原因而被选出时，那么教授就是一个值得为之努力争取的职位，成功的竞争者就会得到相应的尊重。骑士精神促使法拉弟将生命奉献给对自然的研究，这一精神也将激励少数高贵的人们将他们的生命奉献给科学事业。但是，如果我们希望在科学界培育这种最高级的人才，那么我们必须向他们展示一个他们值得之出付出的事业。 在某种程度上，詹妮·林德(Jenny Lind,1820-1887，瑞典女高音歌唱家，1850-1852年间在P.T.巴南的安排下在美国作巡回演出)可以用她美妙的歌喉在她出生的小村庄中培育这种文化，但谁能期望她在世界各地开音乐会而一无所获呢？如果她有这样的愿望，她又应该如何具备这样的能力呢？对科学家来说也是如此，无论他有什么样的天赋，在他竭尽全力工作之前，他必须拥有仪器、图书馆，和生活所需的恰当、受人尊重的薪水。要促进所有高级学科的真正进步，有些东西是必须的，当然除此之外还有其它更多的事情也是必须的。在这个国家中，并不是那些拿最高薪水、并在最富裕的大学拥有职位的人最大程度地促进了其所在学科的进步。那些拿最高薪水并拥有教授职位的人今天所做的事绝对不是纯科学研究，而是科学知识的商业应用，目的是增加他们已经很高的收入。如我之前所说，在恰当的职位上做这种追求是值得尊重的，但是教授的职责是促进科学的进步，他应该向学生和世界展示一个完全、真实地献身科学的榜样，告诉他们生命中还有更崇高的价值。货币兑换者常常是受人尊重的人，但是(耶稣)曾经严厉地谴责他们在教堂的大厅中进行交易。 财富不能成就大学，大楼也不能。大学是由教授和跟随他们学习的学生们构成的。大学是少数学生能够踏入的最后和最高一步。之后，他走向世界，他在大学里有意或无意感受到的理想会影响他今后所能达到的高度。如果他跟随的教授在其职业中一直处于很高的地位，自己又有崇高的理想；如果这些教授认为促进所在领域的进步是他们生命中最重要的工作，并因其智慧而受到全世界的尊重，那么这位学生就会被引向最高处，甚至在他今后的一生中他都有更高的理想。但是，如果这位学生被一些当时所谓的好老师所教育，这些老师所知道的只比学生多一点，并常常被学生超过甚至轻视，那么没有人会怀疑这位学生的品味低下。这位学生发现只要他稍加努力，他就能超过他所在的大学中拥有最高荣誉的人；他开始认为自己是一个天才，工作的动力随之消失了。旁边的小土丘让他感到自己是一个伟大的人，但他不知道世界上还有他无法比拟的大山。 一所大学的老师队伍中不仅要有伟大的人，而且还要有无数的各类小教授和助理，并要鼓励他们从事最高级的工作，不为别的原因，而是为了鼓励学生们要尽他们最大的努力。 但是，假如这位教授有高尚的理想，拥有大而且高级的大学所给他掌握的财富，那么，他就有充分发展其才能的机会。 在我们物理科学中尤其如此。在物理学和化学的早期时代，许多基本的实验都能够在最简单的仪器上完成。因此我们发现，渥拉斯顿(Wollaston William Hyde，1766-1828，英国化学家和物理学家，1803年发现了钯，1804年发现了铑)和法拉弟的名字总是被当作是基本上不需要任何设备做研究的名字而被提及。是的，现在仍然可以用最简单的设备做很多事情；除了完全不胜任者，没有任何人会因为缺少设备而停止工作。但是现实却是这样的，只有当一个人不仅拥有完整的实验室，而且还有一位可以为他支付每一个实验费用的朋友时，他才可能自由地在所有的化学和物理学科中做研究。物理系中最简单的部门如天文学已经达到了这样一种状态：如果没有装备完善的天文台，研究人员基本上什么都不能做，而且如果没有经费聘请一批实施观测和计算的助手，这一切也是没有用的。我们国家拥有许多非常好的天文台，然而，相比而言所做的工作太少了，如果将财富集中，也许可以有一个更有效率的天文台，而且将会证明这对天文科学发展更有利。相反，这些经费分散在六、七个地方，仅能够为附近地区人们提观测月亮的望远镜。在这里，我突然想到了一个问题，如果我们国家要在科学上站住脚，那么对她来说至少有一个问题是重要的。下面这个故事是我从报纸下剪下来的，它能说明问题的本质： “Arunah Huntington是一位古怪的加拿大人，他留下20万美元的遗产计划分给佛蒙特地区的公立学校，但他为这些学校做的事情却基本上没有一点实用价值。每所社区学校获得了微不足道的10美元，这对教育事业的提高没有一点作用。” 没有人会怀疑这笔遗产的使用是愚蠢的，也没有会怀疑在我们的国家布满观测月亮的望远镜并将之称之为天文台的做法是愚蠢的。将这些财产集中在一起会多么好，从而建立一个第一流的天文台和天文研究所。 有没有这样的可能，在我们400多所学院和大学中，有部分机构对知识的热爱程度足以将它们彼此联结成一个整体，从而形成更大的机构？有没有这样的可能，部分机构出于对真理的挚爱而要求用恰如其分的名称来称呼自己？我担心没有。因为在美国人的心中，期望与赌博的欲望被混为一谈，除了它们的名字不同之外，每个机构都在混沌中昏睡，期望时间的流逝能带来繁荣昌盛。尽管其中的许多人都受到宗教的影响，并被教导要讲真话，他们接受的教训是：为了被召唤到更高处，他们应该选择桌上更低的位置，也不要因被贬入更低的位置而觉得有失体面。但是我们的这些机构却将自己推到桌上最高的位置，也许很难让他们从位置上走下来。 但是，有没有可能改变公众的观点呢？让他们知道世界上找不到一所捐赠基金少于100万美元的学院，也找不到捐赠基金少于300万或400万美元的大学。我从教育委员的报告中得知这种变化已经开始；走向大研究机构的趋势在增加，拥有大名称的小机构在西部和西南部地区繁殖之快，令人担心，而东部已经着手迎接大型的大学到来。 1880年，这400所学院和大学的财产总值约为：建筑物4000万美元，运转经费4300万美元。这足以建立1所资产为1000万美元的大型大学、4所资产为500万美元的大学、26所资产为200万美元的学院。但是这个设想不可能成为现实。政府的拨款是不可能的，因为理想的大学绝不能允许政治权术掺和进来。 1880年，所有学校和学院获得的私人捐赠总数约为550万美元，尽管其中一项为125万美元，但这个数目还不是那么巨大。这样看起来，每年的捐赠数会达到500万美元，其中一半以上给了所谓的学院和大学。将这些遗产集中起来足以产生一个立竿见影的结果，但这样做非常之难。但这些数字表明：慷慨给予是美国人最优秀的品质，这个国家所需要的将会在将来的资金中得到支持。我们必须要让这个国家感觉到对研究和纯科学的需求。我们必须要让那些完全献身科学的人们活着，所有的人都看到我们争取钱，但并不是因为要依靠慈善施舍懒惰度日，而是为了这样的一个事业，较之于其它任何学问，这个事业在知识上和物质上已经并将更多地促进世界的进步。我们必须这样生活，以消除那些损害了职业尊严的高位者的影响，或者是那些让自己轻松过日子却没有为其所代表的学科做一点事的人的影响。让我们在目前能力所及的范围内做一切可能的事情。今天，我们中没有一个人拥有完全适合的位置，足以让他充分发挥能力、允许他做最好的科学。所有的人都有困难，但我不相信环境会从根本上改变一个人。如果一个人对研究有一种直觉，它总会以某种方式表现出来。但是，环境也许会将它带上新的征途，或许会给它以哺育，否则它可能会在含苞待放时死去，而不是像现在繁花盛开并结出完美的果实。 美国人在小事情上不缺乏发明和创造，当同样的精神被用到知识和对科学的热爱上时，它就会变成研究的精神。受限于自己的电学知识和对其规律的认识，电报员自然会将他的注意力用到如何提高他所知道的电学设备的性能上，他的研究将局限于他的知识范围，以及他知道的简单规律。但是，随着他的知识的增长，他面前的天地会越来越宽，因为他学了相关题目的数学理论，光的电磁理论也不再是遥不可及，而成为他日常的伴侣。电报装备在他的手中成了他的一个玩具，他发现新东西的努力成为纯科学研究的一部分。 等到一个人精通了科学后再努力去促进科学的进步是没有用的：他必须站到前沿，这样他的努力才可能在竞争中被分辨出来。而且，我也不相信一个没有促进科学发展愿望的人能够通晓所有的科学学科。在学习已有的知识时、在阅读科学期刊时、在讨论目前的科学问题时，一个人可能激发出工作的冲动，甚至这是以前从未有过的事情。追求已有知识的精神会促使他去探求那些未知的东西。我可以这样说，除了著名的研究人员外，我从未见过一个对我所在领域有彻底认识的人。我遇见过这样人，他们说得很好，我也时常问自己他们为什么不做一些事情。进一步了解这些人的本性让我发现他们拥有的知识是多么肤浅。我再也不相信这样的人，他们说只要愿意他们就能做某些事情，或者只要有机会他们就做某些事情。他们都是冒牌货。如果真实的精神的确存在，无论环境怎样它总会显现出来。 如我之前所说，从事纯科学的研究人员通常都是一位教授。他必须在教学的同时也做研究。近年来人们也在讨论这样的问题，即研究与教育两个功能是集中在一个人身上更好呢还是分开更好。绝大多数人认为一定量的教学任务有益于研究的精神，而不是别的。我自己认为确实是这样的，我自己不愿意中断每日的讲课。但一个人不能超负荷。我提出一个解决问题的真正办法，许多情况下可以增加助手，既为教学也为做研究。一些人天生有更多的主意，超出他们的双手能够实现的限度，如果没有为他们提供额外的助手，世界就会失去很多珍贵的东西。生命是短暂的：时光飞逝，晚年很快就会来临，一双手所能做的事情非常有限。有哪一种商店或工厂是靠一个人的手做所有的工作呢？在自然界中有一个即使民主也不能改变的事实是：人是不平等的，一些人有(聪明的)大脑、一些有(灵巧的)手。对平等的空谈不可能推翻这些自然的规则。 在这个国家里，我没有发现一个机构设有直接辅助研究的助理。那么为什么不这样做呢？甚至缺乏助理教授和其它各类助理来帮助教学，也是非常明显的问题，这类问题必须得以补救。 还有许多物理学问题，特别是那些一个人无法完成的需要精确测量的工作，要完成这些工作需要配备精良的设备和完整的助手队伍。比如，雷诺有关气体和蒸气定律的实验，是30年或40年前在法国政府的协助下完成的，他的发现已经成今天的标准。尽管这些实验着眼于对蒸汽机的实际计算，但它们在进行的时候考虑了应用之外更为广泛的问题，因此在理论上也极为有用。此外，如果没有人捐赠天文台，天文学能有什么成就呢？通过这些手段，天文学已经成为物理学中发展最完美的领域，当然天文学的简洁性也使它理应如此。毫无疑问，我认为整个物理学的其它分支的类似机构，都会能取得同样的成功。就像捐赠的天文台促进天文学一样，一个经费充足、配备有教授和助手队伍，以及能够建造新设备的机械工厂的大型、装备完善的物理实验室，同样能够促进物理学的进步。但是，这种实验室不能草率建成。它的价值完全取决于担任实验室负责人的物理学家，他要制定计划，并通过实际的工作来启动研究。这样的人总是很稀少，而且不一定总能找得到。当一个实验室成功启动后，其它的就会跟进，毕竟模仿不需要什么智慧。 我们不可能每次都想当然地得到适合的人，但必须对任命方法进行仔细研究，以保证能够具有很好的平均水平。毫无疑问，任命必须由能够判断每位候选者最高水平工作的科学团体来决定。 如果有任何普通的因素会加入进来，那么选出的人或者只是对科学有一定了解的人，或者就是在科学的边缘有所涉猎却会以最夸张的方式展示自己小小发现的人。我们所需要的是有深度的人，他对物质科学具有深刻见解，能够分辨什么时候能够给科学进展以最关键的一击。 到目前为止，世界上还没有我所描述的这种伟大的物理实验室。但是，天文科学在获得捐赠方面从来都没有什么困难。每个人都会或多或少地认可天文台的价值，因为天文学是最简单明了的科学学科，很快就能拥有精致的仪器和昂贵计算，这是促进天文学发展所必需的。物理学天地是如此的辽阔，以至到今天研究人员们还能发现许多可以做的事情。但是情况并非总是如此，现在已经到了需要建造大型实验室的时刻。在这个问题上我们国家是起领导作用呢，还是等着让其它国家走在前面？未来肯定会建立这样的实验室，但问题是什么时候建以及如何建。 几个研究机构正在设立物理实验室。它们主要将用于教学，可以想象其中绝大多数实验室只可能产生出很少的工作。但是它们显示了进步，如果这方面进步速度如其它方面的一样快，那么我们就能够想象在我们的有生之年能够看到巨大的变化。 4 在科学协会中紧密联系起来 如前面所讲，人们总是受到所接触的人们的认同的影响。我们不可能立即按有利于我们的方向改变公众的看法，而且，我们必须努力去引导公众而不是被它所指导。因为从事纯科学的研究者是先驱，他们不可能在城市和已经文明化的社会中徘徊，他们必须一头扎入未知的森林，攀登迄今无法涉足的高山，在那里俯览希望之乡的美景，这是科学许诺在未来给我们的乐土，这片土地不仅流淌着奶和蜜，而且赋予我们更好和更伟大的思想来认识这个神奇的宇宙。我们必须创造出有利于我们的公众舆论，但并不需要一定从一般大众开始。我们必须满足于站在一旁，看见世界的荣誉在一段时间里给予水平在我们之下的人；我们必须从自我良心的认可中，以及从极少数有能力评判我们工作的人们的赞许中得到更良好的满足，而不在乎整个世界在说什么。我们要将目光投向整个世界的物理学家，而不是本城或本国的物理学家，看看他们是怎么赞美或指责我们，赞美让我们受到鼓励，指责则刺激我们重新努力。无知者的赞美对我们有什么用？让我们像正在做的那样，在我们的科学协会中紧密联系起来，在追求我们喜爱的研究中彼此相互鼓励。我们知道世界需要时间才能承认我们的服务，我们也知道我们组成了人类进步最重要的力量。 但即使在我们的科学协会里，危险离我们还是很近。当协会的平均素质不高、当最高的荣誉给予平庸之辈、三流水准的人被树立成榜样、微不足道的发明被夸大为科学发现时，这种协会影响就是有害的。一位参加这种协会会议的年轻科学家很快就会得到被歪曲的思想。在他的思想中，小土丘就是高山，高山反而成为小土丘。在他的头脑中，小小的发明家或当地的某个地方名人会比国际上的科学领袖还高不可及。他就会用小土丘的标准来衡量自己，对自己状态感到满意，但他不知道与真正的高山相比，他不过如原子般的大小。或许，当他老的时候他会明白这一点，但为时已晚！如果在他起步之初他就看到了高山的雄伟，那么这位年轻的科学家至少会在其成长过程中就会一直受到激励努力向上。 不是所有的人都是天才，但至少我们能够将他们指引向我们身边的天才。我们自己也许无法从科学获得太多的好处，但我们可以有崇高的理想，并将它们逐渐渗透给我们接触到的人们。为了我们自己的幸福、为了我们国家的福祉，为了全世界的利益，我们应该形成一套能够真正衡量人或事的价值和地位的评价体系，在我们的头脑中把所有高尚、有益和高贵的思想放在前面，把所有对科学发展重要的东西放在前面，高于那些平庸的、低级的和琐碎的东西，这是我们义不容辞的责任。 人们总是说，一个人有权有自己观点。对于在荒岛中生活的人来说这种说法也许是对的，因为他的错误只会影响到他一个人；但是当他的话是用于教导别人时，特别是他的观点影响到他的日常生活时，他就必须对他在判断或事实方面的所有错误承担直接责任。他没有权利将一个小土丘当作是高山，也不能这样去教学生，就正如他不能认为地球是平的，并用这一观点来教学生一样。我们所发现的科学事实和规律的重要性是不一样的，每个研究人员的科学成果的重要性也是不一样的。一件事比另一件事更伟大，我们没有权力忽视这个秩序。这样，我们的心灵才会被正确地引导，我们的努力才会朝着最高的方向。 因此我们应该看到，这个国家还没有第一流的物理学家，我们必须到其它国家去寻找这个领域的领导，在他们创建出美国科学或者为世界科学做出贡献前，我国少数杰出的人物必须从无到有得到更多的财富支持。 但是，让我回到科学协会的题目上。美国科学有最棘手的问题需要处理。有太多的地方学会被冠以大而不当的名称，每个学会都有自己的知名人士，他们有特权将他在早晨散步时发现的某些多出一支脚的螃蟹描述为无价之宝。我们也有一些科学学会，在求知方面在当地做出很好的工作。但是，路途如此遥远，很难将人们集中到一个地方。今天我们参加开会的美国科学促进会并不是一个科学机构，也不过是聚集了对科学有兴趣的人，让他们阅读论文并享受交流的乐趣。美国国家科学院是由整个国家中最杰出的人士组成的，但它的作用只是在科学问题上为政府提供免费的建议。它没有自己的办公楼，没有图书馆，也没有出版物；它除了免费给政府的信息外，政府并不向它回报任何东西。它对美国科学没有多少直接的影响；不过，政府在科学考察、出版等方面的宽松和慷慨部分是归功于它的影响，它以这种方式做了很多好事。但是，它没有办法获得像伟大的英国皇家学会、或者是在巴黎、柏林、维也纳和其它欧洲首都和大城市的伟大学院的地位。这些学会通过它们的出版物，给年轻学生以及高级的物理学家树立了卓越的榜样，成为学会的会员是学者们期望获得的最高荣誉之一，写出让学会认为值得发表在其学报上的论文集，是他们努力的最高目标。 设在波士顿的美国科学院或许是我们最有代表性的接近于这些层次的学院机构，但是它的会员只限于该州，使它缺乏全国性的影响。 但是，还有另外一个因素影响着我们科学事业的成长。 因为我们必需在纯科学方面从国外寻求最高的灵感，因为科学不是局限于一个城市或国家的事务，而是整个世界的事业，所以我们所有的人在阅读自己国家的期刊时，也必须同时阅读最新的外国科学期刊和最重要的外国协会的学报。我们国家每一个从事科学教育的机构的图书馆，都必须存放有这些伟大的学报和期刊。如果没有提供这些期刊和学报，又怎么能期望我们的教师或教授知道过去发现过什么，或是了解到现在正在发现些什么？哪一所机构有这样的权利让它所聘请的教师或到此学习的学生们在精神上挨饿？这只能有一个答案，如果一个自称为大学的机构在它的桌子上没最新的科学期刊，或者在它的图书馆的书架上没有存放学会的学报，那么可以肯定的是它没尽最大的努力来促进和培育这个世界上最好的人和事。 我们称自己的国家是一个自由的国家，然而它却是世界上唯一一个对科学事业直接收税的国家。目前我国纯科学水平低下或许是因为我们国家很年轻，但是直接向科学收税从而阻止我国科学的成长，却不能说不是最为丢脸的事。这里我指的是对外国书籍和期刊的征税。在科学方面，我们国家还没有出版过或者即将出版任何中小学教材以上的书籍。但是，物理学的每一位教师都必须拥有这样的书，不仅是在图书馆的书架上，而且是在他们自己的书架上。这个国家有责任让这些教师有能力用自己微薄的薪水的一部分来购买有利于整个国家的书籍。做不到这一点，所有有益于培育我国科学成长的自由交流就会被全部中断。那些有助于提升我国高于平庸水平的新生事物在萌芽阶段就会被政府窒息，而这一政府在直接的科学题目上给人的印象好像还是较为宽松自由的。 人们可能以为外文书籍免税进入不过是为了让某些人或重印德国书籍的工人高兴，而没有认识到不这样，我们与德国进行自由的科学交流的权利就被剥夺了。我们的科学协会和社会必须让人们知道自己在此事上的立场，并让当局明白事情的来龙去脉。 最后，让我再次重申：我不相信我们的国家会长期处于目前的这种状况。物理学的应用让我们国家繁荣富强，我国物理学正在蒸蒸日上地发展，它会让我们受到世界各国家的尊重。这个预言似乎过于轻率，因为我们国家所做的物理学工作还不足以支撑一个物理学期刊。但是，我们知道这个国家前进的速度：我们看见城市在一夜之间拔地而起，其它的宏伟事业也以史无前例的速度前进。我们看见了正在建造的物理学实验室，我们看见了对接受过全面训练又不惧怕数学的物理学家的大量需求，需要他们做教授或加入到所谓的现实生活中。也许我们与所有真正的美国人有着同样的感觉，我们的国家正在走向繁荣昌盛的未来，我们将努力成为世界科学的领导，就像我们今天努力成为世界财富的领导一样。 如果要实现这样的理想，我们的目标就不能太低。没有辛勤工作，宇宙的问题就不会被解开；没有恰当的知识分子和物理工具，这些问题就不会被攻克；缺乏数学知识的物理学家不会走得太远。没有人会期待一匹没有经过良好训练的马能赢得伟大的长距离赛马比赛。无论拥有多么纯正、高贵的血统，指望没有良好训练的人获得大奖也是大错特错的。我们要解决的问题远比任何竞赛都更困难：没有恰当的准备，即使最高智力水平的人也不会获得成功。最伟大的奖励等待着伟大的智力付出最大的努力，他必须通过持续不断的实践来保持敏锐的目光和新鲜的思想。仪器和设备可以用钱买来，天赋可能与生俱来，但是我们心智的工具、我们的数学知识、我们的实验能力、我们对前人创造的知识的掌握，所有这些都需要通过努力才能获得。即使是在我们国家，三流水平的人因为什么都不会做而成为教师的时代也已经过去。我们希望在教授席位上看到这样的人，他们聪明、好学、精力旺盛，又充满工作的动力，但最重要的是，我们希望看到能够激励人们排除万难去追求最高理想的高贵和勇敢的精神，他们是在自己良知的赞许而不是他人的认可之下去探求自然界的难题。让他用所有的数学武器、前人的经验来武装自己，让他胸怀征服的坚定目标走进这个竞技场。让他不要满足于站在平庸之辈的人群后面，要让他在竞争中力争站到最前列。 整个宇宙就在我们面前，等待我们去研究。最伟大的头脑经过最伟大的努力才能给我们带来少量的珍宝。但是无穷的海洋在我们面前，它隐秘的深谷中充满了钻石和宝石。宇宙的问题还没有解决，即使一个原子的秘密也还让我们迷惑不已。当我们不断前进时，研究的领域就会越来越宽广，自然的庄严和美丽让我们惊讶和赞叹。我们能为这些伟大的工作做些什么吗？我们的国家是会承担起自己应有的责任呢？还是只会生活在世界的施舍中呢？ （责任编辑 黄永明）","categories":[],"tags":[]},{"title":"【Javascript】滚动吸附","slug":"【Javascript】滚动吸附","date":"2023-09-04T06:08:00.000Z","updated":"2023-09-12T09:35:44.725Z","comments":true,"path":"2023/09/04/【Javascript】滚动吸附/","link":"","permalink":"https://wisiw.github.io.git/2023/09/04/%E3%80%90Javascript%E3%80%91%E6%BB%9A%E5%8A%A8%E5%90%B8%E9%99%84/","excerpt":"","text":"什么是滚动吸附实现原理1.使用mousewheel监听页面滚动2.使用scrollIntoView将元素滚动至视区3.使用防抖函数进行优化 页面样式 123456789101112131415161718192021222324&lt;html&gt; &lt;head&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; body &#123; width: 100%; height: 100vh; overflow-y: auto; &#125; body .content &#123; width: 100%; height: 100vh; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;content&quot; style=&quot;background: red&quot;&gt;&lt;/div&gt; &lt;div class=&quot;content&quot; style=&quot;background: yellow&quot;&gt;&lt;/div&gt; &lt;div class=&quot;content&quot; style=&quot;background: blue&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 1.使用mousewheel监听页面滚动根据e.wheelDelta的正负来判断滚动的方向 1234567891011document.body.addEventListener( &quot;mousewheel&quot;, (e) =&gt; &#123; if (e.wheelDelta &lt; 0) &#123; // down &#125; if (e.wheelDelta &gt; 0) &#123; // up &#125; &#125;); 2.使用scrollIntoView将元素滚动至视区12345678910111213141516171819document.body.addEventListener( &quot;mousewheel&quot;, (e) =&gt; &#123; const els = document.querySelectorAll(&quot;.content&quot;); if (e.wheelDelta &lt; 0) &#123; // down scroll(els[0]) &#125; if (e.wheelDelta &gt; 0) &#123; // up scroll(els[1]) &#125; &#125;);function scroll(el) &#123; if (el) &#123; el.scrollIntoView(&#123; behavior: &quot;smooth&quot;, block: &quot;center&quot; &#125;); &#125;&#125; 这样能实现两个class=&quot;content&quot;元素之间的滚动吸附，但这不具备通用性，当前页面只有两个元素，可以根据滚动方向来判断将那个元素滚动到当前视区。但如果增加元素数量，就很难判断当前要滚动哪个元素，有的人可能想着增加一个全局idx，通过上下滚动来修改idx进行判断当前应该滚动哪个元素，但因为第一步的滚动监听是持续的，因此会造成idx的不断修改，因此进入第三步，引入防抖函数. 3.使用防抖函数进行优化123456789101112131415161718192021222324252627282930let idx = 0;document.body.addEventListener( &quot;mousewheel&quot;, debounce((e) =&gt; &#123; const els = document.querySelectorAll(&quot;.content&quot;); if (e.wheelDelta &lt; 0) &#123; // down idx++; if (idx &gt; els.length - 1) idx = els.length - 1; &#125; if (e.wheelDelta &gt; 0) &#123; // up idx--; if (idx &lt; 0) idx = 0; &#125; scroll(els[idx]); &#125;, 500));function debounce(fn, delay = 500) &#123; let timer = null; return function () &#123; if (timer) &#123; clearTimeout(timer); &#125; timer = setTimeout(() =&gt; &#123; fn.apply(this, arguments); timer = null; &#125;, delay); &#125;;&#125; 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; body &#123; width: 100%; height: 100vh; overflow-y: auto; &#125; body .content &#123; width: 100%; height: 100vh; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;content&quot; style=&quot;background: red&quot;&gt;&lt;/div&gt; &lt;div class=&quot;content&quot; style=&quot;background: yellow&quot;&gt;&lt;/div&gt; &lt;div class=&quot;content&quot; style=&quot;background: blue&quot;&gt;&lt;/div&gt; &lt;script&gt; let idx = 0; document.body.addEventListener( &quot;mousewheel&quot;, debounce((e) =&gt; &#123; const els = document.querySelectorAll(&quot;.content&quot;); if (e.wheelDelta &lt; 0) &#123; // down idx++; if (idx &gt; els.length - 1) idx = els.length - 1; &#125; if (e.wheelDelta &gt; 0) &#123; // up idx--; if (idx &lt; 0) idx = 0; &#125; scroll(els[idx]); &#125;, 500) ); function scroll(el) &#123; if (el) &#123; el.scrollIntoView(&#123; behavior: &quot;smooth&quot;, block: &quot;center&quot; &#125;); &#125; &#125; function debounce(fn, delay = 500) &#123; let timer = null; return function () &#123; if (timer) &#123; clearTimeout(timer); &#125; timer = setTimeout(() =&gt; &#123; fn.apply(this, arguments); timer = null; &#125;, delay); &#125;; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"滚动吸附","slug":"滚动吸附","permalink":"https://wisiw.github.io.git/tags/%E6%BB%9A%E5%8A%A8%E5%90%B8%E9%99%84/"}]},{"title":"【Node】模板生成器","slug":"【Node】模板生成器","date":"2023-08-15T12:51:58.000Z","updated":"2023-08-16T01:23:15.344Z","comments":true,"path":"2023/08/15/【Node】模板生成器/","link":"","permalink":"https://wisiw.github.io.git/2023/08/15/%E3%80%90Node%E3%80%91%E6%A8%A1%E6%9D%BF%E7%94%9F%E6%88%90%E5%99%A8/","excerpt":"","text":"1.什么是模板生成用于","categories":[],"tags":[{"name":"Node","slug":"Node","permalink":"https://wisiw.github.io.git/tags/Node/"},{"name":"模板生成器","slug":"模板生成器","permalink":"https://wisiw.github.io.git/tags/%E6%A8%A1%E6%9D%BF%E7%94%9F%E6%88%90%E5%99%A8/"}]},{"title":"vue的业务状态显示","slug":"vue的业务状态显示","date":"2023-04-03T05:00:56.000Z","updated":"2023-04-03T05:00:56.900Z","comments":true,"path":"2023/04/03/vue的业务状态显示/","link":"","permalink":"https://wisiw.github.io.git/2023/04/03/vue%E7%9A%84%E4%B8%9A%E5%8A%A1%E7%8A%B6%E6%80%81%E6%98%BE%E7%A4%BA/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"【CSS】css实现页面翻滚","slug":"【CSS】css实现页面翻滚","date":"2023-03-15T09:46:05.000Z","updated":"2023-03-15T10:07:18.395Z","comments":true,"path":"2023/03/15/【CSS】css实现页面翻滚/","link":"","permalink":"https://wisiw.github.io.git/2023/03/15/%E3%80%90CSS%E3%80%91css%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E7%BF%BB%E6%BB%9A/","excerpt":"","text":"1.行翻滚顾名思义，一行行的滚动。 1-1.实现思路主要使用animation和translationY实现。注意：动画最后的显示会出现问题，因为如果要把最后一列滚动到第一列，底部会出现一大段空白。解决的办法是在原来的列表多添加开始的几列，作为视界的填充 1-2.代码12345678&lt;style&gt; .main &#123;&#125;&lt;/style&gt;&lt;div class=&quot;main&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 2.页翻滚2-1.实现思路2-2.代码1","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://wisiw.github.io.git/tags/CSS/"},{"name":"CSS翻滚","slug":"CSS翻滚","permalink":"https://wisiw.github.io.git/tags/CSS%E7%BF%BB%E6%BB%9A/"}]},{"title":"【Echarts】graph连线设置label","slug":"【Echarts】graph连线设置label","date":"2023-01-30T10:03:34.000Z","updated":"2023-01-30T10:05:45.762Z","comments":true,"path":"2023/01/30/【Echarts】graph连线设置label/","link":"","permalink":"https://wisiw.github.io.git/2023/01/30/%E3%80%90Echarts%E3%80%91graph%E8%BF%9E%E7%BA%BF%E8%AE%BE%E7%BD%AElabel/","excerpt":"","text":"12345678910&#123; edgeLabel: &#123; normal: &#123; show: true, formatter: () =&gt; &#123; return &quot;标题&quot;; &#125;, &#125;, &#125;,&#125;","categories":[],"tags":[{"name":"Echarts","slug":"Echarts","permalink":"https://wisiw.github.io.git/tags/Echarts/"}]},{"title":"【设计】同一页面toggle跳转的的页面组件化","slug":"【设计】同一页面toggle跳转的的页面组件化","date":"2022-12-05T05:34:49.000Z","updated":"2022-12-05T05:34:49.206Z","comments":true,"path":"2022/12/05/【设计】同一页面toggle跳转的的页面组件化/","link":"","permalink":"https://wisiw.github.io.git/2022/12/05/%E3%80%90%E8%AE%BE%E8%AE%A1%E3%80%91%E5%90%8C%E4%B8%80%E9%A1%B5%E9%9D%A2toggle%E8%B7%B3%E8%BD%AC%E7%9A%84%E7%9A%84%E9%A1%B5%E9%9D%A2%E7%BB%84%E4%BB%B6%E5%8C%96/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"【funny】代码画","slug":"【funny】代码画","date":"2022-11-30T05:35:51.000Z","updated":"2022-12-02T01:31:44.182Z","comments":true,"path":"2022/11/30/【funny】代码画/","link":"","permalink":"https://wisiw.github.io.git/2022/11/30/%E3%80%90funny%E3%80%91%E4%BB%A3%E7%A0%81%E7%94%BB/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"【function】Carousel 走马灯","slug":"【function】Carousel-走马灯","date":"2022-11-30T00:58:08.000Z","updated":"2022-11-30T00:58:08.398Z","comments":true,"path":"2022/11/30/【function】Carousel-走马灯/","link":"","permalink":"https://wisiw.github.io.git/2022/11/30/%E3%80%90function%E3%80%91Carousel-%E8%B5%B0%E9%A9%AC%E7%81%AF/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"【element-ui】el-cascader 级联选择器清空初始化","slug":"【element-ui】el-cascader-级联选择器清空初始化","date":"2022-11-29T09:20:17.000Z","updated":"2022-11-29T09:36:02.606Z","comments":true,"path":"2022/11/29/【element-ui】el-cascader-级联选择器清空初始化/","link":"","permalink":"https://wisiw.github.io.git/2022/11/29/%E3%80%90element-ui%E3%80%91el-cascader-%E7%BA%A7%E8%81%94%E9%80%89%E6%8B%A9%E5%99%A8%E6%B8%85%E7%A9%BA%E5%88%9D%E5%A7%8B%E5%8C%96/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;template&gt; &lt;el-cascader v-model=&quot;value&quot; :options=&quot;options&quot; :props=&quot;&#123; checkStrictly: true &#125;&quot; ref=&quot;cascader&quot; @change=&quot;handleChange&quot;&gt; &lt;/el-cascader&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; value: &quot;&quot;, options: [&#123; value: &#x27;zhinan&#x27;, label: &#x27;指南&#x27;, children: [&#123; value: &#x27;shejiyuanze&#x27;, label: &#x27;设计原则&#x27;, children: [&#123; value: &#x27;yizhi&#x27;, label: &#x27;一致&#x27; &#125;, &#123; value: &#x27;fankui&#x27;, label: &#x27;反馈&#x27; &#125;, &#123; value: &#x27;xiaolv&#x27;, label: &#x27;效率&#x27; &#125;, &#123; value: &#x27;kekong&#x27;, label: &#x27;可控&#x27; &#125;] &#125;, &#123; value: &#x27;daohang&#x27;, label: &#x27;导航&#x27;, children: [&#123; value: &#x27;cexiangdaohang&#x27;, label: &#x27;侧向导航&#x27; &#125;, &#123; value: &#x27;dingbudaohang&#x27;, label: &#x27;顶部导航&#x27; &#125;] &#125;] &#125;] &#125;; &#125;, methods: &#123; handleChange() &#123; this.value = &quot;&quot;; this.$refs[&quot;cascader&quot;].checkedValue = []; &#125; &#125; &#125;;&lt;/script&gt;","categories":[],"tags":[{"name":"element-ui","slug":"element-ui","permalink":"https://wisiw.github.io.git/tags/element-ui/"}]},{"title":"【npm】postcss-pxtorem","slug":"【npm】postcss-pxtorem","date":"2022-11-22T02:10:13.000Z","updated":"2022-11-22T02:13:24.280Z","comments":true,"path":"2022/11/22/【npm】postcss-pxtorem/","link":"","permalink":"https://wisiw.github.io.git/2022/11/22/%E3%80%90npm%E3%80%91postcss-pxtorem/","excerpt":"","text":"postcss-pxtorem A plugin for PostCSS that generates rem units from pixel units. Install1$ npm install postcss postcss-pxtorem --save-dev UsagePixels are the easiest unit to use (opinion). The only issue with them is that they don’t let browsers change the default font size of 16. This script converts every px value to a rem from the properties you choose to allow the browser to set the font size. Input/OutputWith the default settings, only font related properties are targeted. 123456789101112131415// inputh1 &#123; margin: 0 0 20px; font-size: 32px; line-height: 1.2; letter-spacing: 1px;&#125;// outputh1 &#123; margin: 0 0 20px; font-size: 2rem; line-height: 1.2; letter-spacing: 0.0625rem;&#125; Example123456789101112131415var fs = require(&#x27;fs&#x27;);var postcss = require(&#x27;postcss&#x27;);var pxtorem = require(&#x27;postcss-pxtorem&#x27;);var css = fs.readFileSync(&#x27;main.css&#x27;, &#x27;utf8&#x27;);var options = &#123; replace: false&#125;;var processedCss = postcss(pxtorem(options)).process(css).css;fs.writeFile(&#x27;main-rem.css&#x27;, processedCss, function (err) &#123; if (err) &#123; throw err; &#125; console.log(&#x27;Rem file written.&#x27;);&#125;); optionsType: Object | NullDefault: 12345678910&#123; rootValue: 16, unitPrecision: 5, propList: [&#x27;font&#x27;, &#x27;font-size&#x27;, &#x27;line-height&#x27;, &#x27;letter-spacing&#x27;], selectorBlackList: [], replace: true, mediaQuery: false, minPixelValue: 0, exclude: /node_modules/i&#125; rootValue (Number | Function) Represents the root element font size or returns the root element font size based on the input parameter unitPrecision (Number) The decimal numbers to allow the REM units to grow to. propList (Array) The properties that can change from px to rem. Values need to be exact matches. Use wildcard * to enable all properties. Example: [&#39;*&#39;] Use * at the start or end of a word. ([&#39;*position*&#39;] will match background-position-y) Use ! to not match a property. Example: [&#39;*&#39;, &#39;!letter-spacing&#39;] Combine the “not” prefix with the other prefixes. Example: [&#39;*&#39;, &#39;!font*&#39;] selectorBlackList (Array) The selectors to ignore and leave as px. If value is string, it checks to see if selector contains the string. [&#39;body&#39;] will match .body-class If value is regexp, it checks to see if the selector matches the regexp. [/^body$/] will match body but not .body replace (Boolean) Replaces rules containing rems instead of adding fallbacks. mediaQuery (Boolean) Allow px to be converted in media queries. minPixelValue (Number) Set the minimum pixel value to replace. exclude (String, Regexp, Function) The file path to ignore and leave as px. If value is string, it checks to see if file path contains the string. &#39;exclude&#39; will match \\project\\postcss-pxtorem\\exclude\\path If value is regexp, it checks to see if file path matches the regexp. /exclude/i will match \\project\\postcss-pxtorem\\exclude\\path If value is function, you can use exclude function to return a true and the file will be ignored. the callback will pass the file path as a parameter, it should returns a Boolean result. function (file) &#123; return file.indexOf(&#39;exclude&#39;) !== -1; &#125; Use with gulp-postcss and autoprefixer1234567891011121314151617181920var gulp = require(&#x27;gulp&#x27;);var postcss = require(&#x27;gulp-postcss&#x27;);var autoprefixer = require(&#x27;autoprefixer&#x27;);var pxtorem = require(&#x27;postcss-pxtorem&#x27;);gulp.task(&#x27;css&#x27;, function () &#123; var processors = [ autoprefixer(&#123; browsers: &#x27;last 1 version&#x27; &#125;), pxtorem(&#123; replace: false &#125;) ]; return gulp.src([&#x27;build/css/**/*.css&#x27;]) .pipe(postcss(processors)) .pipe(gulp.dest(&#x27;build/css&#x27;));&#125;); A message about ignoring propertiesCurrently, the easiest way to have a single property ignored is to use a capital in the pixel unit declaration. 12345678910// `px` is converted to `rem`.convert &#123; font-size: 16px; // converted to 1rem&#125;// `Px` or `PX` is ignored by `postcss-pxtorem` but still accepted by browsers.ignore &#123; border: 1Px solid; // ignored border-width: 2PX; // ignored&#125;","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"https://wisiw.github.io.git/tags/npm/"},{"name":"postcss","slug":"postcss","permalink":"https://wisiw.github.io.git/tags/postcss/"},{"name":"适配","slug":"适配","permalink":"https://wisiw.github.io.git/tags/%E9%80%82%E9%85%8D/"}]},{"title":"【Node】SystemJS安装","slug":"【Node】SystemJS安装","date":"2022-11-06T19:36:51.000Z","updated":"2022-11-06T20:21:22.933Z","comments":true,"path":"2022/11/07/【Node】SystemJS安装/","link":"","permalink":"https://wisiw.github.io.git/2022/11/07/%E3%80%90Node%E3%80%91SystemJS%E5%AE%89%E8%A3%85/","excerpt":"","text":"SystemJS 1. whatSystemJS是一个可配置的模块加载器（Configurable Module Loader），它能在浏览器或Node.js上动态加载模块，并且支持CommonJS、AMD、全局模块对象及ES 6模块等。 2. how2-1. 构建运行环境12345mkdir testcd testnpm init -ynpm install typescript systemjs@0.19.47 --savenpm install lite-server --save 注：SystemJS安装时使用@标记出具体的版本号，这是因为从SystemJS v0.2版开始将TypeScript加载变成插件方式了，而SystemJS v0.2之前的版本则直接内置TypeScript加载功能，为了简单起见，这里就直接使用SystemJS v0.19.47版了。 2-2.使用SystemJS2-2-1. 创建index.html12345678910111213141516// ./index.html&lt;head&gt; &lt;script src=&quot;node_modules/systemjs/dist/system.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;node_modules/typescript/lib/typescript.js&quot;&gt;&lt;/script&gt; &lt;script&gt; System.config(&#123; transpiler : &#x27;typescript&#x27; , // 要使用TypeScript编译（转译）器 packages : &#123; &#x27;./ &#x27;: &#123; defaultExtension : &#x27;ts&#x27; &#125; // 要转义package.json同一目录下的所有ts文件 &#125; &#125;); System .import(&#x27;main.ts&#x27;) // 要导入的ts入口文件名 .then(null, console.error.bind(console));// 如果产生错误，将错误发送到浏览器控制台窗口 &lt;/script&gt;&lt;/head&gt; 2-2-2. 创建模块1234// ./main.tsimport &#123; name &#125; from &#x27;./src/common.ts&#x27;;alert(name); 12// ./src/common.tsexport const name = &#x27;common&#x27;; 2-3. 本地运行2-3-1. 安装lite-server1npm install lite-server 2-3-2. 添加运行脚本123456789101112131415161718// package.json&#123; &quot;name&quot;: &quot;test&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;lite-server&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;lite-server&quot;: &quot;^2.4.0&quot;, &quot;systemjs&quot;: &quot;^0.19.47&quot;, &quot;typescript&quot;: &quot;^3.4.1&quot; &#125;&#125; 2-3-3. 本地运行1npm run dev","categories":[],"tags":[{"name":"SystemJS","slug":"SystemJS","permalink":"https://wisiw.github.io.git/tags/SystemJS/"},{"name":"安装","slug":"安装","permalink":"https://wisiw.github.io.git/tags/%E5%AE%89%E8%A3%85/"}]},{"title":"【JavaScript】<script>延迟执行","slug":"【JavaScript】-script-延迟执行","date":"2022-11-05T21:33:51.000Z","updated":"2022-11-05T21:44:26.376Z","comments":true,"path":"2022/11/06/【JavaScript】-script-延迟执行/","link":"","permalink":"https://wisiw.github.io.git/2022/11/06/%E3%80%90JavaScript%E3%80%91-script-%E5%BB%B6%E8%BF%9F%E6%89%A7%E8%A1%8C/","excerpt":"","text":"why当脚本放在&lt;head&gt;标签中，并且初始化需要调用&lt;body&gt;中的节点时，由于此时&lt;body&gt;未被加载，所以脚本会运行错误 how 将&lt;script&gt;至于&lt;body&gt;之后，等节点被加载后，再执行脚本 123456&lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; console.log(docment.body.id)&lt;/script&gt; &lt;script添加defer参数 12345&lt;head&gt; &lt;script type=&quot;text/javascript&quot; defer&gt; console.log(docment.body.id) &lt;/script&gt;&lt;/head&gt; window.onload() window.onload()将会在网页加载完毕后立即执行","categories":[],"tags":[]},{"title":"【TypeScript】1.构建TypeScript开发、编译和调试环境","slug":"【TypeScript】1-构建TypeScript开发、编译和调试环境","date":"2022-11-05T21:24:11.000Z","updated":"2022-11-05T21:53:45.411Z","comments":true,"path":"2022/11/06/【TypeScript】1-构建TypeScript开发、编译和调试环境/","link":"","permalink":"https://wisiw.github.io.git/2022/11/06/%E3%80%90TypeScript%E3%80%911-%E6%9E%84%E5%BB%BATypeScript%E5%BC%80%E5%8F%91%E3%80%81%E7%BC%96%E8%AF%91%E5%92%8C%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/","excerpt":"","text":"1. 安装环境1.1 安装Node官网安装Node.js时，一般会提供两个版本：LTS版和Current版。其中，LTS是Long Term Support（官方长期支持版）的缩写，在生产环境中，请使用LTS版 1.2 全局安装ts1sudo npm install -g typescript 2. 使用2.1 手动编译（一般用法）例如将当前路径下的main.ts转译为main.js使用 1tsc main.ts 当前路径下会生成main.js文件 2.2 编译器实现自动编译 2.2.1 生成tsconfig.json文件1tsc --init 2.2.2 自动编译123456789&#123; &quot;compilerOptions&quot; : &#123; &quot;target&quot; : &quot;es5&quot; , &quot;module&quot; : &quot;commonjs&quot; , &quot;strict&quot; : true , &quot;esModuleInterop&quot; : true, &quot;watch&quot; : true // 是否开启监控.ts文件变化，实现自动编译 &#125;&#125;","categories":[],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://wisiw.github.io.git/tags/TypeScript/"},{"name":"使用","slug":"使用","permalink":"https://wisiw.github.io.git/tags/%E4%BD%BF%E7%94%A8/"}]},{"title":"【JavaScript】严格模式","slug":"【JavaScript】严格模式","date":"2022-11-05T13:29:33.000Z","updated":"2022-11-05T21:20:11.820Z","comments":true,"path":"2022/11/05/【JavaScript】严格模式/","link":"","permalink":"https://wisiw.github.io.git/2022/11/05/%E3%80%90JavaScript%E3%80%91%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"目的： 消除 JavaScript 语法中一些不合理、不严谨的地方； 消除代码中一些不安全的地方，保证代码的安全运行； 提高 JavaScript 程序的运行效率； 为以后新版本的 JavaScript 做好铺垫。 目前，主流浏览器包括 IE10 及其之后的版本都已支持严格模式 注意：”use strict”;或’use strict’;指令只有在整个脚本第一行或者函数第一行时才能被识别，除了 IE9 以及更低的版本外，所有的浏览器都支持该指令。 相较于普通模式1.不允许使用未声明的变量1234&quot;use strict&quot;;v = 1; // 此处报错：Uncaught ReferenceError: v is not definedfor(i = 0; i &lt; 2; i++) &#123; // 此处报错：Uncaught ReferenceError: i is not defined&#125; 2.不允许删除变量或函数1234567&quot;use strict&quot;;var person = &#123;name: &quot;Peter&quot;, age: 28&#125;;delete person; // 此处报错：Uncaught SyntaxError: Delete of an unqualified identifier in strict mode.function sum(a, b) &#123; return a + b;&#125;delete sum; // 此处报错：Uncaught SyntaxError: Delete of an unqualified identifier in strict mode. 3.函数中不允许同名的参数1234&quot;use strict&quot;;function square(a, a) &#123; // 此处报错：Uncaught SyntaxError: Duplicate parameter name not allowed in this context return a * a;&#125; 4.eval语句的作用域是独立的123&quot;use strict&quot;;eval(&quot;var x = 5; console.log(x);&quot;);console.log(x); // 此处报错：Uncaught ReferenceError: x is not defined 5.不允许使用with语句1234567&quot;use strict&quot;;var radius1 = 5;var area1 = Math.PI * radius1 * radius1;var radius2 = 5;with(Math) &#123; // 此处报错：Uncaught SyntaxError: Strict mode code may not include a with statement var area2 = PI * radius2 * radius2;&#125; 6.不允许写入只读属性1234&quot;use strict&quot;;var person = &#123;name: &quot;Peter&quot;, age: 28&#125;;Object.defineProperty(person, &quot;gender&quot;, &#123;value: &quot;male&quot;, writable: false&#125;);person.gender = &quot;female&quot;; // 此处报错：Uncaught TypeError: Cannot assign to read only property &#x27;gender&#x27; of object &#x27;#&lt;Object&gt;&#x27; 7.不允许使用八进制数123&quot;use strict&quot;;var x = 010; // 此处报错：Uncaught SyntaxError: Octal literals are not allowed in strict mode.console.log(parseInt(x)); 8.不能在if语句中声明函数12345678&quot;use strict&quot;;//如果在if语句中声明函数，则会产生语法错误if (true) &#123; function demo() &#123; // 此处报错：Uncaught ReferenceError: demo is not defined console.log(111); &#125;&#125;demo(); 9.禁止使用this表示全局对象123456&quot;use strict&quot;;var name = &quot;name&quot;;function demoTest() &#123; console.log(this);&#125;demoTest();","categories":[],"tags":[]},{"title":"【Node】CommonJS的模块规范","slug":"【Node】CommonJS的模块规范","date":"2022-11-03T17:03:36.000Z","updated":"2022-11-05T13:30:00.795Z","comments":true,"path":"2022/11/04/【Node】CommonJS的模块规范/","link":"","permalink":"https://wisiw.github.io.git/2022/11/04/%E3%80%90Node%E3%80%91CommonJS%E7%9A%84%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83/","excerpt":"","text":"1.模块引用1234```javascript// 示例代码var common = require(&#x27;common&#x27;) 2.模块定义对于1.中的require()方法引入的外部模块中，使用exports对象用于导出当前模块的方法或者变量 123456// 示例代码exports.name = &#x27;common&#x27;exports.changeName = function(name) =&gt; &#123; return this.name&#125; 3.模块标识模块标识其实就是传递给require()的参数，它必须是符合小驼峰命名的字符串，以.、..开头，或者绝对路径。它可以没有文件名后缀。 模块的定义十分简单，接口也十分简洁。它的意义在于将类聚的方法和变量等限定在私有的作用域中，同时支持接入和导出功能以顺畅地连接上下游依赖。 每个模块具有独立的空间，互不干扰。","categories":[],"tags":[{"name":"Node","slug":"Node","permalink":"https://wisiw.github.io.git/tags/Node/"}]},{"title":"【JavaScript】网页截图","slug":"【JavaScript】网页截图","date":"2022-10-29T13:37:57.000Z","updated":"2022-10-29T16:55:01.716Z","comments":true,"path":"2022/10/29/【JavaScript】网页截图/","link":"","permalink":"https://wisiw.github.io.git/2022/10/29/%E3%80%90JavaScript%E3%80%91%E7%BD%91%E9%A1%B5%E6%88%AA%E5%9B%BE/","excerpt":"","text":"之前使用的截图都是使用的html2canvas插件，能够满足大多数情况，但在实际使用过程中（微信浏览器），因为种类繁多的手机型号，会造成白屏。因此，在查找了相关资料后，尝试使用webrtc实现截图效果。 ps： 因为公司项目中截图功能是用来生成合同的，而且不希望有太大的改动，因此功能惨遭pass，连个上线机会都不给我。最后使用了前端只负责生成签名图片，然后传给服务器，服务器将签名图片与合同模板合成后返回地址。世事无常，大肠包小肠。","categories":[],"tags":[{"name":"网页截图","slug":"网页截图","permalink":"https://wisiw.github.io.git/tags/%E7%BD%91%E9%A1%B5%E6%88%AA%E5%9B%BE/"},{"name":"webrtc","slug":"webrtc","permalink":"https://wisiw.github.io.git/tags/webrtc/"}]},{"title":"【JavaScript】动态导入","slug":"【JavaScript】动态导入","date":"2022-10-28T15:09:17.000Z","updated":"2022-10-28T15:12:01.471Z","comments":true,"path":"2022/10/28/【JavaScript】动态导入/","link":"","permalink":"https://wisiw.github.io.git/2022/10/28/%E3%80%90JavaScript%E3%80%91%E5%8A%A8%E6%80%81%E5%AF%BC%E5%85%A5/","excerpt":"","text":"将变量作为标识符，并动态导入 123456const jsFile = new Blob([&#x27;export default true&#x27;], &#123; type: &#x27;application/javscript&#x27;&#125;);const jsURL = URL.createObjectURL(jsFile);import(jsURL).then(module =&gt; &#123; console.log(module.default); // true&#125;)","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wisiw.github.io.git/tags/JavaScript/"}]},{"title":"【JavaScript】模板引擎的实现","slug":"【JavaScript】模板引擎的实现","date":"2022-10-26T20:30:13.000Z","updated":"2023-09-13T06:32:45.949Z","comments":true,"path":"2022/10/27/【JavaScript】模板引擎的实现/","link":"","permalink":"https://wisiw.github.io.git/2022/10/27/%E3%80%90JavaScript%E3%80%91%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"什么是模板引擎使用原理","categories":[],"tags":[{"name":"模板引擎","slug":"模板引擎","permalink":"https://wisiw.github.io.git/tags/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"}]},{"title":"【npm】electron-store","slug":"【npm】electron-store","date":"2022-10-26T09:14:41.000Z","updated":"2022-10-26T09:20:55.922Z","comments":true,"path":"2022/10/26/【npm】electron-store/","link":"","permalink":"https://wisiw.github.io.git/2022/10/26/%E3%80%90npm%E3%80%91electron-store/","excerpt":"","text":"electron-store electron-store Simple data persistence for your Electron app or module - Save and load user preferences, app state, cache, etcElectron doesn’t have a built-in way to persist user preferences and other data. This module handles that for you, so you can focus on building your app. The data is saved in a JSON file named config.json in app.getPath(&#39;userData&#39;). You can use this module directly in both the main and renderer process. For use in the renderer process only, you need to call Store.initRenderer() in the main process, or create a new Store instance (new Store()) in the main process. Install1npm install electron-store Requires Electron 11 or later. Usage123456789101112const Store = require(&#x27;electron-store&#x27;);const store = new Store();store.set(&#x27;unicorn&#x27;, &#x27;🦄&#x27;);console.log(store.get(&#x27;unicorn&#x27;));//=&gt; &#x27;🦄&#x27;// Use dot-notation to access nested propertiesstore.set(&#x27;foo.bar&#x27;, true);console.log(store.get(&#x27;foo&#x27;));//=&gt; &#123;bar: true&#125;store.delete(&#x27;unicorn&#x27;);console.log(store.get(&#x27;unicorn&#x27;));//=&gt; undefined APIChanges are written to disk atomically, so if the process crashes during a write, it will not corrupt the existing config. Store(options?)Returns a new instance. optionsType: object defaultsType: object Default values for the store items. Note: The values in defaults will overwrite the default key in the schema option. schematype: object JSON Schema to validate your config data. Under the hood, the JSON Schema validator ajv is used to validate your config. We use JSON Schema draft-07 and support all validation keywords and formats. You should define your schema as an object where each key is the name of your data’s property and each value is a JSON schema used to validate that property. See more here. Example: 123456789101112131415161718const Store = require(&#x27;electron-store&#x27;);const schema = &#123; foo: &#123; type: &#x27;number&#x27;, maximum: 100, minimum: 1, default: 50 &#125;, bar: &#123; type: &#x27;string&#x27;, format: &#x27;url&#x27; &#125;&#125;;const store = new Store(&#123;schema&#125;);console.log(store.get(&#x27;foo&#x27;));//=&gt; 50store.set(&#x27;foo&#x27;, &#x27;1&#x27;);// [Error: Config schema violation: `foo` should be number] Note: The default value will be overwritten by the defaults option if set. migrationsType: object You can use migrations to perform operations to the store whenever a version is upgraded. The migrations object should consist of a key-value pair of &#39;version&#39;: handler. The version can also be a semver range. Example: 123456789101112131415161718const Store = require(&#x27;electron-store&#x27;);const store = new Store(&#123; migrations: &#123; &#x27;0.0.1&#x27;: store =&gt; &#123; store.set(&#x27;debugPhase&#x27;, true); &#125;, &#x27;1.0.0&#x27;: store =&gt; &#123; store.delete(&#x27;debugPhase&#x27;); store.set(&#x27;phase&#x27;, &#x27;1.0.0&#x27;); &#125;, &#x27;1.0.2&#x27;: store =&gt; &#123; store.set(&#x27;phase&#x27;, &#x27;1.0.2&#x27;); &#125;, &#x27;&gt;=2.0.0&#x27;: store =&gt; &#123; store.set(&#x27;phase&#x27;, &#x27;&gt;=2.0.0&#x27;); &#125; &#125;&#125;); beforeEachMigrationType: FunctionDefault: undefined The given callback function will be called before each migration step. The function receives the store as the first argument and a context object as the second argument with the following properties: fromVersion - The version the migration step is being migrated from. toVersion - The version the migration step is being migrated to. finalVersion - The final version after all the migrations are applied. versions - All the versions with a migration step. This can be useful for logging purposes, preparing migration data, etc. Example: 12345678910111213141516171819202122const Store = require(&#x27;electron-store&#x27;);console.log = someLogger.log;const mainConfig = new Store(&#123; beforeEachMigration: (store, context) =&gt; &#123; console.log(`[main-config] migrate from $&#123;context.fromVersion&#125; → $&#123;context.toVersion&#125;`); &#125;, migrations: &#123; &#x27;0.4.0&#x27;: store =&gt; &#123; store.set(&#x27;debugPhase&#x27;, true); &#125; &#125;&#125;);const secondConfig = new Store(&#123; beforeEachMigration: (store, context) =&gt; &#123; console.log(`[second-config] migrate from $&#123;context.fromVersion&#125; → $&#123;context.toVersion&#125;`); &#125;, migrations: &#123; &#x27;1.0.1&#x27;: store =&gt; &#123; store.set(&#x27;debugPhase&#x27;, true); &#125; &#125;&#125;); nameType: stringDefault: &#39;config&#39; Name of the storage file (without extension). This is useful if you want multiple storage files for your app. Or if you’re making a reusable Electron module that persists some data, in which case you should not use the name config. cwdType: stringDefault: app.getPath(&#39;userData&#39;) Storage file location. Don’t specify this unless absolutely necessary! By default, it will pick the optimal location by adhering to system conventions. You are very likely to get this wrong and annoy users. If a relative path, it’s relative to the default cwd. For example, &#123;cwd: &#39;unicorn&#39;&#125; would result in a storage file in ~/Library/Application Support/App Name/unicorn. encryptionKeyType: string | Buffer | TypedArray | DataViewDefault: undefined Note that this is not intended for security purposes, since the encryption key would be easily found inside a plain-text Node.js app. Its main use is for obscurity. If a user looks through the config directory and finds the config file, since it’s just a JSON file, they may be tempted to modify it. By providing an encryption key, the file will be obfuscated, which should hopefully deter any users from doing so. When specified, the store will be encrypted using the aes-256-cbc encryption algorithm. fileExtensionType: stringDefault: &#39;json&#39; Extension of the config file. You would usually not need this, but could be useful if you want to interact with a file with a custom file extension that can be associated with your app. These might be simple save/export/preference files that are intended to be shareable or saved outside of the app. clearInvalidConfigType: booleanDefault: false The config is cleared if reading the config file causes a SyntaxError. This is a good behavior for unimportant data, as the config file is not intended to be hand-edited, so it usually means the config is corrupt and there’s nothing the user can do about it anyway. However, if you let the user edit the config file directly, mistakes might happen and it could be more useful to throw an error when the config is invalid instead of clearing. serializeType: FunctionDefault: value =&gt; JSON.stringify(value, null, &#39;\\t&#39;) Function to serialize the config object to a UTF-8 string when writing the config file. You would usually not need this, but it could be useful if you want to use a format other than JSON. deserializeType: FunctionDefault: JSON.parse Function to deserialize the config object from a UTF-8 string when reading the config file. You would usually not need this, but it could be useful if you want to use a format other than JSON. accessPropertiesByDotNotationType: booleanDefault: true Accessing nested properties by dot notation. For example: 1234567891011const Store = require(&#x27;electron-store&#x27;);const store = new Store();store.set(&#123; foo: &#123; bar: &#123; foobar: &#x27;🦄&#x27; &#125; &#125;&#125;);console.log(store.get(&#x27;foo.bar.foobar&#x27;));//=&gt; &#x27;🦄&#x27; Alternatively, you can set this option to false so the whole string would be treated as one key. 123456const store = new Store(&#123;accessPropertiesByDotNotation: false&#125;);store.set(&#123; `foo.bar.foobar`: &#x27;🦄&#x27;&#125;);console.log(store.get(&#x27;foo.bar.foobar&#x27;));//=&gt; &#x27;🦄&#x27; watchType: booleanDefault: false Watch for any changes in the config file and call the callback for onDidChange or onDidAnyChange if set. This is useful if there are multiple processes changing the same config file, for example, if you want changes done in the main process to be reflected in a renderer process. InstanceYou can use dot-notation in a key to access nested properties. The instance is iterable so you can use it directly in a for…of loop. .set(key, value)Set an item. The value must be JSON serializable. Trying to set the type undefined, function, or symbol will result in a TypeError. .set(object)Set multiple items at once. .get(key, defaultValue?)Get an item or defaultValue if the item does not exist. .reset(…keys)Reset items to their default values, as defined by the defaults or schema option. Use .clear() to reset all items. .has(key)Check if an item exists. .delete(key)Delete an item. .clear()Delete all items. This resets known items to their default values, if defined by the defaults or schema option. .onDidChange(key, callback)callback: (newValue, oldValue) =&gt; &#123;&#125; Watches the given key, calling callback on any changes. When a key is first set oldValue will be undefined, and when a key is deleted newValue will be undefined. Returns a function which you can use to unsubscribe: 12const unsubscribe = store.onDidChange(key, callback);unsubscribe(); .onDidAnyChange(callback)callback: (newValue, oldValue) =&gt; &#123;&#125; Watches the whole config object, calling callback on any changes. oldValue and newValue will be the config object before and after the change, respectively. You must compare oldValue to newValue to find out what changed. Returns a function which you can use to unsubscribe: 12const unsubscribe = store.onDidAnyChange(callback);unsubscribe(); .sizeGet the item count. .storeGet all the data as an object or replace the current data with an object: 12345const Store = require(&#x27;electron-store&#x27;);const store = new Store();store.store = &#123; hello: &#x27;world&#x27;&#125;; .pathGet the path to the storage file. .openInEditor()Open the storage file in the user’s editor. initRenderer()Initializer to set up the required ipc communication channels for the module when a Store instance is not created in the main process and you are creating a Store instance in the Electron renderer process only. In the main process: 12const Store = require(&#x27;electron-store&#x27;);Store.initRenderer(); And in the renderer process: 12345const Store = require(&#x27;electron-store&#x27;);const store = new Store();store.set(&#x27;unicorn&#x27;, &#x27;🦄&#x27;);console.log(store.get(&#x27;unicorn&#x27;));//=&gt; &#x27;🦄&#x27; FAQAdvantages over window.localStorageCan I use YAML or another serialization format?The serialize and deserialize options can be used to customize the format of the config file, as long as the representation is compatible with utf8 encoding. Example using YAML: 1234567const Store = require(&#x27;electron-store&#x27;);const yaml = require(&#x27;js-yaml&#x27;);const store = new Store(&#123; fileExtension: &#x27;yaml&#x27;, serialize: yaml.safeDump, deserialize: yaml.safeLoad&#125;); How do I get store values in the renderer process when my store was initialized in the main process?The store is not a singleton, so you will need to either initialize the store in a file that is imported in both the main and renderer process, or you have to pass the values back and forth as messages. Electron provides a handy invoke/handle API that works well for accessing these values. 123ipcMain.handle(&#x27;getStoreValue&#x27;, (event, key) =&gt; &#123; return store.get(key);&#125;); 1const foo = await ipcRenderer.invoke(&#x27;getStoreValue&#x27;, &#x27;foo&#x27;); Can I use it for large amounts of data?This package is not a database. It simply uses a JSON file that is read/written on every change. Prefer using it for smaller amounts of data like user settings, value caching, state, etc. If you need to store large blobs of data, I recommend saving it to disk and to use this package to store the path to the file instead. Related electron-util - Useful utilities for developing Electron apps and modules electron-debug - Adds useful debug features to your Electron app electron-context-menu - Context menu for your Electron app electron-dl - Simplified file downloads for your Electron app electron-unhandled - Catch unhandled errors and promise rejections in your Electron app electron-reloader - Simple auto-reloading for Electron apps during development electron-serve - Static file serving for Electron apps conf - Simple config handling for your app or module More…","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"https://wisiw.github.io.git/tags/npm/"},{"name":"node","slug":"node","permalink":"https://wisiw.github.io.git/tags/node/"},{"name":"electron","slug":"electron","permalink":"https://wisiw.github.io.git/tags/electron/"},{"name":"使用教程","slug":"使用教程","permalink":"https://wisiw.github.io.git/tags/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"}]},{"title":"【前端架构】SPA与传统多页面","slug":"【前端架构】SPA与传统多页面","date":"2022-10-24T14:37:04.000Z","updated":"2022-10-24T14:52:53.104Z","comments":true,"path":"2022/10/24/【前端架构】SPA与传统多页面/","link":"","permalink":"https://wisiw.github.io.git/2022/10/24/%E3%80%90%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84%E3%80%91SPA%E4%B8%8E%E4%BC%A0%E7%BB%9F%E5%A4%9A%E9%A1%B5%E9%9D%A2/","excerpt":"","text":"SPA（Single Page Application）：单页面应用，渲染以及路由交由客户端运行，服务端RESTFul API只提供HTML所需的JSON数据 优点： 减轻了服务器的资源消耗 与HTML文档比起来，JSON数据的体积小很多，减少了网络请求的时间消耗 页面路由控制更快速灵活 可以离线使用 缺点： 浏览器需要等到JavaScript文件加载完成后才可以渲染后续的HTML文档内容，白屏时间影响用户体验 客户端与服务端编程语言不同，可能会存在一些诸如数据格式的差异，甚至路由逻辑冲突，增加维护难度 SPA不利于常规SEO爬虫（Google针对SPA进行了SEO优化，但是目前国内搜索殷勤支持不理想）","categories":[],"tags":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://wisiw.github.io.git/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}]},{"title":"【VUE】utils","slug":"【Vue】utils","date":"2022-10-24T10:40:35.000Z","updated":"2022-11-06T21:13:19.117Z","comments":true,"path":"2022/10/24/【Vue】utils/","link":"","permalink":"https://wisiw.github.io.git/2022/10/24/%E3%80%90Vue%E3%80%91utils/","excerpt":"","text":"1234567891011121314151617/** * Make a map and return a function for checking if a key * is in that map. */export function makeMap ( str: string, expectsLowerCase?: boolean): (key: string) =&gt; true | void &#123; const map = Object.create(null) const list: Array&lt;string&gt; = str.split(&#x27;,&#x27;) for (let i = 0; i &lt; list.length; i++) &#123; map[list[i]] = true &#125; return expectsLowerCase ? val =&gt; map[val.toLowerCase()] : val =&gt; map[val]&#125;","categories":[],"tags":[{"name":"utils","slug":"utils","permalink":"https://wisiw.github.io.git/tags/utils/"}]},{"title":"【TypeScript】重载","slug":"【TypeScript】重载","date":"2022-07-18T01:52:24.000Z","updated":"2022-07-18T09:21:47.906Z","comments":true,"path":"2022/07/18/【TypeScript】重载/","link":"","permalink":"https://wisiw.github.io.git/2022/07/18/%E3%80%90TypeScript%E3%80%91%E9%87%8D%E8%BD%BD/","excerpt":"","text":"demo12345678910111213141516171819class OverLoad &#123; // 重载签名 load(param: string): void; load(param: Array&lt;string&gt;): void; // 实现签名 load(param: string | Array&lt;string&gt;) &#123; if (param instanceof Array&lt;string&gt;) &#123; // do something &#125; else &#123; // do something &#125; &#125;&#125;const OL = new OverLoad();OL.load(&quot;a&quot;);OL.load([&quot;a&quot;, &quot;b&quot;]);// OL.load(() =&gt; &#123;&#125;) // error 说明1.重载签名是可调用的虽然实现签名实现了函数行为，但是不能直接调用，只有重载签名是可调用的。即使实现签名的入参为未在重载签名中定义的类型值，也不能调用重载签名函数 123456789101112131415function load(param: string): void;function load(param: number): void;function load(param: any): void &#123; // do something&#125;load([1,2])// 报错/**No overload matches this call. Overload 1 of 2, &#x27;(param: string): void&#x27;, gave the following error. Argument of type &#x27;number[]&#x27; is not assignable to parameter of type &#x27;string&#x27;. Overload 2 of 2, &#x27;(param: number): void&#x27;, gave the following error. Argument of type &#x27;number[]&#x27; is not assignable to parameter of type &#x27;number&#x27;.**/ 2.实现签名必须是通用的重载签名不仅签名需要保持一致，返回值也许保持一致 123456function load(param: string): string;function load(param: number): void;function load(param: any): void &#123; // do something&#125; 以上两个load的返回值不一致，因此不能实现重载 使用情况不推荐对可选参数使用函数重载1234567function load(): void;function load(param1: string): void;function load(param1: string, param2: number): void;function load(...args: any): void &#123; // do something&#125; 推荐在实现签名中使用可选参数1function load(param1?: string, param2: number): void &#123;&#125;","categories":[],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://wisiw.github.io.git/tags/TypeScript/"},{"name":"重载","slug":"重载","permalink":"https://wisiw.github.io.git/tags/%E9%87%8D%E8%BD%BD/"}]},{"title":"【读书笔记】《英雄诞生的神话》Otto Rank——神话概要","slug":"【读书笔记】《英雄诞生的神话》——神话概要","date":"2022-07-16T05:45:27.000Z","updated":"2022-07-16T06:36:54.748Z","comments":true,"path":"2022/07/16/【读书笔记】《英雄诞生的神话》——神话概要/","link":"","permalink":"https://wisiw.github.io.git/2022/07/16/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E8%8B%B1%E9%9B%84%E8%AF%9E%E7%94%9F%E7%9A%84%E7%A5%9E%E8%AF%9D%E3%80%8B%E2%80%94%E2%80%94%E7%A5%9E%E8%AF%9D%E6%A6%82%E8%A6%81/","excerpt":"","text":"“故事的主人公的父母都身居高位，通常是国王和王后” “他还在母腹中的时候就经受磨难，例如母亲戒食或难产；或者他的父母因为某些禁令或外界干扰而只能暗中保持性关系。在他母亲怀上他时或妊娠之前，某种神谕或梦境就警告他父亲，将要降生的儿子以后会对他的安全形成危险” “因此，他的父亲（或者事实上的父亲）下令杀死这个婴儿，或者把他抛到绝境中去；绝大多数情况下这个婴儿是被装在箱子里抛到河流中去。” “然后，这个婴儿被野兽或穷人如牧羊人救起，由母兽或出身低微的女人抚养。” “他长大成人后，经历了许多奇异的冒险，找到了出生高贵的父母，向父亲施行了毁灭性的报复并获得了人民的承认，赢得了伟大的声誉。” 西方神话中最久远的历史人物是B.C 2800年前后巴比伦的建立者，阿卡德的萨尔贡。","categories":[],"tags":[{"name":"神话Myth","slug":"神话Myth","permalink":"https://wisiw.github.io.git/tags/%E7%A5%9E%E8%AF%9DMyth/"},{"name":"神话概要","slug":"神话概要","permalink":"https://wisiw.github.io.git/tags/%E7%A5%9E%E8%AF%9D%E6%A6%82%E8%A6%81/"}]},{"title":"【古生物】恐龙时期","slug":"【古生物】恐龙时期","date":"2022-07-08T03:02:04.000Z","updated":"2022-07-08T03:19:17.818Z","comments":true,"path":"2022/07/08/【古生物】恐龙时期/","link":"","permalink":"https://wisiw.github.io.git/2022/07/08/%E3%80%90%E5%8F%A4%E7%94%9F%E7%89%A9%E3%80%91%E6%81%90%E9%BE%99%E6%97%B6%E6%9C%9F/","excerpt":"","text":"纪 世 代表恐龙 三叠纪 晚三叠世 卡尼期 艾沃克龙属、始盗龙属、艾雷拉龙属、圣胡安龙属、南十字龙属、曙奔龙属、理理恩龙属、滥食龙属、农神龙属、平原驰龙属、优胫龙属等 三叠纪 诺利期 原鸟属、恶魔龙属、太阳神龙属、哥斯拉龙属、敏捷龙属、腔骨龙属、坎普龙属、原美颌龙属、始奔龙属、翼椎龙属、瓜巴龙属、板龙属等 三叠纪 瑞替期 邪灵龙属、吕勒龙属、南巴尔龙属、槽齿龙属、黑丘龙属、鼠龙属、伊森龙属等 侏罗纪 早侏罗世 赫塘期～托阿尔期 腔骨龙属、大椎龙属、双冠龙属、单脊龙属、快足龙属、合踝龙属、中国龙属、斑龙属、冰脊龙属、雷前龙属、火山齿龙属、巨脚龙属等 侏罗纪 中侏罗世 阿林期～卡洛夫期 灵武龙属、石树沟爪龙属、鲸龙科、棘刺龙属、巴塔哥尼亚龙属、巧龙属、始阿贝力龙属、皮亚尼兹基龙属、斑龙属、美扭椎龙属、华阳龙属、中脊龙属、新疆巨龙属等 侏罗纪 晚侏罗世 牛津期～提通期 剑龙属、梁龙属、腕龙属、特维尔切龙属、蝴蝶龙属、马门溪龙属、峨眉龙属、迷惑龙属、雷龙属、重龙属、迪涅鲁龙属、超龙属、拖尼龙属、角鼻龙属、蛮龙属、非洲猎龙属、食蜥王龙属、异特龙属、依潘龙属、重庆龙属、祖母暴龙属、巨刺龙属、藏匿龙属等 白垩纪 早白垩世 贝利亚期～阿尔布期 禽龙属、重爪龙属、驰龙属、原始祖鸟属、孔子鸟属、小盗龙属、长羽盗龙属、羽暴龙属、犹他盗龙属、高棘龙属、冠龙属、中华龙鸟属等 白垩纪 晚白垩世 森诺曼期 鲨齿龙属、脊甲龙属、结节龙属、顶盾龙属、中原龙属、木他龙属、掘奔龙属、始鸭嘴龙属、小头龙属、安第斯龙属、阿根廷龙属、潮汐龙属、南方猎龙属、巴哈利亚龙属、南方巨兽龙属、马普龙属、奥沙拉龙属、阿克西鸟属、棘龙属等 白垩纪 晚白垩世 土伦期 郊狼暴龙属、帖木儿龙属、阿纳拜斯龙属、巴克龙属、巨谜龙属、马里龙属、祖尼角龙属、存续鸟属、发现鸟属等 白垩纪 晚白垩世 科尼亚克期～坎帕期 伶盗龙属、戟龙属、钉头龙属、包头龙、祖鲁龙属、加斯顿龙属、中华丽羽龙属、黄昏鸟属、厄兆龙属、诸城暴龙属、惧龙属、蛇发女怪龙属等 白垩纪 晚白垩世 马斯特里赫特期 暴龙属、三角龙属、甲龙属、厚头龙属、牛角龙属、似鸡龙、恐手龙属、特暴龙属、镰刀龙属、泰坦巨龙属、埃德蒙顿龙属、反鸟属、鸟龙鸟属等 古近纪 古新世 达宁期～赞尼特期 （鸟）南鸟、横谷企鹅、冠恐鸟、古恐鸟、骇鸟、普锐斯比鸟、石板鸟、维加鸟、鸭翼鸟等 古近纪 始新世 伊普雷斯期～普里阿邦期 （鸟）艾基拉鸟、弓企鹅、鹤翅雀、璃茉军舰鸟、买撒里丝鸟、齿翼鸟、古鸨、喙鸟、新秃鹫、伊卡企鹅等 古近纪 渐新世 鲁培尔期～恰特期 （鸟）拟鸸鹋、剑喙企鹅、桨翼鸟、欧洲蜂鸟、副雷鸣鸟、畸鸟、伪齿鸟等 新近纪 中新世 阿基坦期～墨西拿期 （鸟）阿根廷巨鹰、奔鸟、骨齿鸟、中新鹫、牛鸟、东方鸵鸟、恐鹤、中华河鸭等 新近纪 上新世 赞克尔期～皮亚琴期 （鸟）维氏鸵鸟、厚鸵、泰坦鸟、异美洲鸵等 第四纪 更新世 格拉斯期～晚更新期 （鸟）小鸮属、角百灵属、古巴鹤、哈斯特鹰、加州神鹫、牛顿巨鸟、山西雉等 第四纪 全新世 格陵兰期～梅加拉亚期 （鸟）你看到的鸟都是。","categories":[],"tags":[{"name":"古生物","slug":"古生物","permalink":"https://wisiw.github.io.git/tags/%E5%8F%A4%E7%94%9F%E7%89%A9/"},{"name":"恐龙","slug":"恐龙","permalink":"https://wisiw.github.io.git/tags/%E6%81%90%E9%BE%99/"}]},{"title":"【读书笔记】Web Components in action","slug":"【读书笔记】Web Components in action","date":"2022-06-28T02:51:17.000Z","updated":"2022-07-16T05:46:11.821Z","comments":true,"path":"2022/06/28/【读书笔记】Web Components in action/","link":"","permalink":"https://wisiw.github.io.git/2022/06/28/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91Web%20Components%20in%20action/","excerpt":"","text":"可能使用到的库stencil（用于生成Web 组件的编译器） 1.shadow DOM作用：防止内部的样式被外部样式影响 开启shadow Dom显示 基于Web components的库 Google’s Polymer Library (https://polymer-library.polymer-project.org) Mozilla’s X-Tags (https://x-tag.github.io) 2.Web Components的未来作为浏览器自带的API，可以支持在组件内使用前端框架，编译成单独的组件以供使用。 这也就意味着可以在React项目中使用Vue，在无框架应用中使用框架，以及最重要的：使得微前端成为可能，打破了各大框架之间的铁幕 对于未定义的tag，会像一个一样显示，继承的是HTMLUnknownElement，因为命名规范使得你如果不定义自己的元素并且不符合规范（-分隔），则会继承HTMLUnknownElement 1&lt;randomElement&gt;111&lt;/randomElement&gt; 12document.createElement(&#x27;randomElement&#x27;).constructor;// ƒ HTMLUnknownElement() &#123; [native code] &#125; 使用-分隔，则会继承HTMLElement 12document.createElement(&#x27;random-element&#x27;).constructor;// ƒ HTMLElement() &#123; [native code] &#125; 创建自定义元素 12class Ele extends HTMLElement &#123;&#125;customElements.define(&#x27;u-el&#x27;, Ele) 如果重复定义同一元素控制栏会报错 123customElements.define(&#x27;u-el&#x27;, Ele)customElements.define(&#x27;u-el&#x27;, Ele)// Failed to execute &#x27;define&#x27; on &#x27;CustomElementRegistry&#x27;: this name has alreadybeen used with this registry 因为命名是唯一的，因此添加判断逻辑 123if (!customElements.get(&#x27;u-el&#x27;)) &#123; customElements.define(&#x27;u-el&#x27;, Ele)&#125; 如果想要继承HTMLButtonElement或者其它已经定义过的元素，需要考虑浏览器的兼容性，只有HTMLElement是几乎所有浏览器都兼容的（除了IE，nmd），但是可以使用polyfills 地址：https://unpkg.com/@webcomponents/custom-elements@1.2.4/custom-elements.min.js or 使用npm安装 1npm install @webcomponents/custom-elements 并且定义的新元素需要继承HTMLElement，否则是不合法的 3.Custom Element的生命周期3.1 connectedCallback在此周期函数内可以通过this访问当前自定义元素，修改内部元素、自身样式以及添加事件 数据劫持（getters、setters） 3.2 observedAttributes与attributeChangedCallbackobservedAttributes 用于判断当前触发的attribute是不是需要监控 123456789101112两者同时使用用于过滤需要监听的元素并监控其变化```javascriptstatic get observedAttributes() &#123; return [&#x27;style&#x27;]&#125;attributeChangedCallback(name, oldV, newV) &#123; if (name === &#x27;style&#x27; &amp;&amp; oldV !== newV) &#123; this.style = newV &#125;&#125; 属性反射器 12345678910111213141516171819static get observedAttributes() &#123; return [&#x27;searchterm&#x27;, &#x27;data-v&#x27;, &#x27;checked&#x27;]&#125;attributeChangedCallback(name, oldV, newV) &#123; console.log(name, oldV, newV); if (name === &#x27;checked&#x27;) &#123; this.checked = newV &#125;&#125;set checked(v) &#123; const isChecked = Boolean(v) if (isChecked) &#123; // 这会触发无限循环 this.setAttribute(&#x27;checked&#x27;, &#x27;&#x27;) &#125; else &#123; this.removeAttribute(&#x27;checked&#x27;) &#125;&#125; 以上的写法会触发无限的循环 因此，对此属性添加一个反射器（添加一个setter和getter） 1234567891011121314static get observedAttributes() &#123; return [&#x27;checked&#x27;];&#125;get checked() &#123; return this.getAttribute(&#x27;checked&#x27;);&#125;set checked(v) &#123; this.setAttribute(&#x27;checked&#x27;, v);&#125;attributeChangedCallback(name, oldval, newval) &#123; if (name === &#x27;checked&#x27;) &#123; // do something &#125;&#125; 使用反射器后，当设置checked时，触发setter，设置当前元素的attribute（并不单独设置property），读取这个property也是返回key相同的attribute 对于一个开发者来说，保持attrbutes和properties的一致和同步是十分重要的 attributes的相关函数hasAttribute()getAttribute()setAttribute() 3.3 constructor 注意 12```javascriptdocument.createElement(&#x27;u-el&#x27;) 当Element被插入DOM中时connectedCallback才会被触发 初始化属性最好在constructor中，这样比较直观 connectedCallback在现实应用中不怎么使用的一个原因是Shadow DOM DOM```创建了一个相对独立的小型```DOM```，而```Shadow DOM```可以没有固定的创建时机1234567891011121314## 3.4 ```disconnectedCallback```当组件从```DOM```中卸载会被触发，主要用来清除定时器等方法```javascriptclass Ele extends HTMLElement &#123; connectedCallback() &#123; this.timer = setInterval(() =&gt; &#123; console.log(11); &#125;, 1000) &#125; disconnectedCallback() &#123; clearInterval(this.timer) &#125;&#125; 3.5 adoptedCallback当组件在```DOM``中移动后触发","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://wisiw.github.io.git/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"Web Componetns","slug":"Web-Componetns","permalink":"https://wisiw.github.io.git/tags/Web-Componetns/"}]},{"title":"【前端】自定义拖拽页面","slug":"【前端】自定义拖拽页面","date":"2022-06-17T09:09:32.000Z","updated":"2022-11-03T13:58:19.630Z","comments":true,"path":"2022/06/17/【前端】自定义拖拽页面/","link":"","permalink":"https://wisiw.github.io.git/2022/06/17/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%96%E6%8B%BD%E9%A1%B5%E9%9D%A2/","excerpt":"","text":"此项目适用于大多数自定义拖拽项目 项目要求：公司与多家医院对接，对于护理白板中的消息内容的样式有不同的需求，如果为此去进行定制化开发，将产生大量的人力与时间浪费，并且同一项目因此分出多个分支或项目进行管理，将会造成代码管理混乱，因此通过对页面进行自定义开发，从而避免以上问题。数据库中存储页面的DOM结构与展示数据，需要使用时进行实时渲染。 最先想到的是肯定就是后端渲染，每次请求之后刷新页面，方案一与方案二就是后端渲染，前端只负责获取页面，然后innerHTML。 方案一：模板引擎（Handlebars）原因：由vue的模板引擎想到的的mustache，Handlebars作为mustache的扩展，功能更加丰富 优点：代码量小，对后端基本无要求，只需要提供存取接口，不需要对页面进行任何处理 缺点：作为初级的模板语法，与Vue中使用的模板语法不同的是，未添加Diff功能，因此只能通过innerHtml进行整体DOM替换，因此会造成页面首页白屏，并且整体替换会造成 废除理由：项目实施不愿意学习模板语法 方案二：富文本老大提出的方案，希望实现所见即所得，类似于Notion这样在页面上直接编辑原因：需要实现所见即所得 缺点：需要对富文本进行插件开发 方案三（最终方案）：九宫格实现页面定位，拖拽实现模块的复用，重写Vue的render函数实现了模块的自定义渲染（算是符合了实施那边的需求，但算不上多么新颖的功能，只是各种技术的堆砌）这项目有点像上一家公司的自定义驾驶舱，在项目内置一些配置好的图标，然后拖拽到驾驶舱页面，当时使用的是vue-drag-resize做的页面布局，但是到最后布局太过自由，上线时使用人员总是会将各个模块重叠起来，或者布局太过怪异，因此使用了vue-grid-layout进行页面中各模块的布局，先将页面布局定下来，不需要再去各种考虑布局了。vuedraggable进行预制模块的拖拽，基本上符合了当前的需求 元数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&#123; &quot;name&quot;: &quot;呼叫提醒&quot;, &quot;key&quot;: &quot;call_reminder&quot;, &quot;vNode&quot;: &#123; &quot;tag&quot;: &quot;div&quot;, &quot;attr&quot;: &#123; &quot;style&quot;: &#123; &quot;width&quot;: &quot;100%&quot;, &quot;height&quot;: &quot;100%&quot;, &quot;overflow-y&quot;: &quot;auto&quot;, &quot;padding&quot;: &quot;16px 24px&quot;, &quot;box-sizing&quot;: &quot;border-box&quot;, &quot;font-size&quot;: &quot;12px&quot;, &#125;, &#125;, &quot;vNode&quot;: [ &#123; &quot;tag&quot;: &quot;div&quot;, &quot;attr&quot;: &#123; &quot;style&quot;: &#123; &quot;display&quot;: &quot;flex&quot;, &quot;position&quot;: &quot;fixed&quot; &#125;, &#125;, &quot;vNode&quot;: [ &#123; &quot;tag&quot;: &quot;i&quot;, &quot;attr&quot;: &#123; &quot;class&quot;: &quot;img-box call_reminder&quot;, &quot;style&quot;: &#123; &quot;width&quot;: &quot;27px&quot;, &quot;height&quot;: &quot;27px&quot;, &quot;margin-right&quot;: &quot;10px&quot;, &#125;, &#125;, &quot;vNode&quot;: null, &#125;, &#123; &quot;tag&quot;: &quot;span&quot;, &quot;attr&quot;: &#123; &quot;style&quot;: &#123; &quot;height&quot;: &quot;30px&quot;, &quot;font-size&quot;: &quot;22px&quot;, &quot;font-family&quot;: &quot;PingFangSC-Medium, PingFang SC&quot;, &quot;font-weight&quot;: 500, &quot;color&quot;: &quot;#333333&quot;, &quot;line-height&quot;: &quot;30px&quot;, &#125; &#125;, &quot;type&quot;: &quot;eval&quot;, &quot;vNode&quot;: &quot;`呼叫提醒($&#123;this.count||0&#125;)`&quot;, // 使用模板字符串，在渲染函数中自动转换 &#125;, ], &#125;, &#123; &quot;tag&quot;: &quot;div&quot;, &quot;attr&quot;: &#123; &quot;style&quot;: &#123; &quot;position&quot;: &quot;absolute&quot;, &quot;top&quot;: &quot;52px&quot;, &quot;right&quot;: &quot;24px&quot;, &quot;bottom&quot;: &quot;16px&quot;, &quot;left&quot;: &quot;24px&quot;, &quot;overflow-y&quot;: &quot;auto&quot; &#125; &#125;, &quot;vNode&quot;: [ &#123; &quot;tag&quot;: &quot;div&quot;, &quot;attr&quot;: &#123;&#125;, &quot;child&quot;: &#123; &quot;tag&quot;: &quot;span&quot;, &quot;attr&quot;: &#123; &quot;style&quot;: &#123; &quot;width&quot;: &quot;70px&quot;, &quot;text-align&quot;: &quot;center&quot;, &quot;display&quot;: &quot;inline-block&quot;, &quot;height&quot;: &quot;36px&quot;, &quot;font-size&quot;: &quot;20px&quot;, &quot;font-family&quot;: &quot;PingFangSC-Regular, PingFang SC&quot;, &quot;font-weight&quot;: 400, &quot;color&quot;: &quot;#333333&quot;, &quot;line-height&quot;: &quot;36px&quot;, &#125;, &#125;, &#125;, &quot;key&quot;: &quot;call_reminder_data&quot;, &quot;keys&quot;: &quot;bed_number&quot;, &quot;vNode&quot;: &quot;tag&quot;, &#125;, &#123; &quot;tag&quot;: &quot;div&quot;, &quot;attr&quot;: &#123; &quot;style&quot;: &#123; &quot;width&quot;: &quot;100%&quot; &#125; &#125;, &quot;child&quot;: &#123; &quot;tag&quot;: &quot;span&quot;, &quot;attr&quot;: &#123; &quot;style&quot;: &#123; &quot;width&quot;: &quot;70px&quot;, &quot;text-align&quot;: &quot;center&quot;, &quot;display&quot;: &quot;inline-block&quot;, &quot;height&quot;: &quot;36px&quot;, &quot;font-size&quot;: &quot;20px&quot;, &quot;font-family&quot;: &quot;PingFangSC-Regular, PingFang SC&quot;, &quot;font-weight&quot;: 400, &quot;color&quot;: &quot;#FEAA02&quot;, &quot;line-height&quot;: &quot;36px&quot;, &#125;, &#125;, &quot;vNode&quot;: &quot;`$&#123;textArr[0]&#125;号病房`&quot; &#125;, &quot;key&quot;: &quot;call_reminder_room_data&quot;, &quot;keys&quot;: &quot;room_name&quot;, &quot;vNode&quot;: &quot;tag&quot;, &#125;, ] &#125; ], &#125;, &#125;, 主要使用vue的$createElement函数和render函数，将元数据渲染成html模板，此方案相较于方案一，因为使用了Vue，有效避免了数据变化时的整屏数据变化 12345Vue.component(&#x27;board&#x27;, &#123; render: (h) =&gt; &#123; return h(&#x27;div&#x27;, &#123;&#125;, &quot;vNode&quot;) &#125;&#125;) 难点:先期，元数据中没有VNode这个参数，使用的函数 123456789101112131415161718// 标签渲染tag: (list, AST) =&gt; &#123; return list.map((v) =&gt; &#123; AST.vNode = v.text || &quot;&quot;; return AST; &#125;);&#125;// 表格渲染table: (list, AST) =&gt; &#123; return list.map((v) =&gt; &#123; const textArr = v.split(&quot;,&quot;); AST.vNode.map((item, i) =&gt; &#123; item.vNode = textArr[i]; return item; &#125;); return AST; &#125;);&#125;, 但是在数据结构保存到数据库时，函数会丢失，而且样式泰国复杂，只能修改成现在改写Vue的render函数，使用$createElement函数创建出虚拟DOM 标题栏需要显示当前数据的多少，因此使用了字符串模板和computed 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106Vue.component(&#x27;board&#x27;, &#123; props: &#123; vNode: &#123; type: [Array, String, Object, Number], default: () =&gt; &#123; tag: &quot;div&quot;, attr: &#123;&#125;, vNode: `标题$&#123;this.count&#125;` &#125; &#125; &#125;, data() &#123; return &#123; list: [] &#125; &#125;, computed: &#123; count() &#123; return this.list.length &#125; &#125;, render: (h) =&gt; &#123; const slots = this.$slots.default || []; const vNode = this.toVnode(this.vNode, this.keyName return h(&#x27;div&#x27;, &#123;style: &#123;width: &quot;100%&quot;&#125;&#125;, [vNode, ...slots]); &#125;, methods: &#123; toVnode(vNode) &#123; if (Array.isArray(vNode)) &#123; return vNode.map(v =&gt; this.objToVNode(v)) &#125; else if (typeof vNode === &#x27;object&#x27;) &#123; return this.objToVNode(vNode) &#125; else &#123; return &#x27;&#x27; + vNode &#125; &#125;, objToVNode(AST) &#123; if (typeof AST === &#x27;string&#x27;) return ast let &#123; key, tag, keys, attr, vNode, child, type &#125; = AST const h = this.$createElement if (Array.isArray(vNode))&#123; vNode = this.toVnode(vNode, key) &#125; else if (child) &#123; switch (vNode) &#123; case &quot;tag&quot;: vNode = list.map(v =&gt; &#123; const _child = Object.assign(&#123;&#125;, child) // ... return _child &#125;) break; case &quot;table&quot;: vNode = list.map(v =&gt; &#123; const _child = Object.assign(&#123;&#125;, child) // ... &#125;) break; default: break; &#125; // 使用深拷贝解除attr的响应式化（h的attr不支持响应式数据） attr = Object.assign(&#123;&#125;, attr) // 绑定事件监听器 if (!attr.on) &#123; if (tag === &quot;i&quot;) &#123; attr.on = &#123; click: (e) =&gt; &#123; if (this.isComponent)return e.stopPropagation() // 使用$EventBus绑定icon修改事件 this.$EventBus.$emit(&#x27;changeIcon&#x27;, &#123; attr, key: this.keyName &#125;) &#125; &#125; &#125; else &#123; attr.on = &#123; click: (e) =&gt; &#123; if (this.isComponent)&#123; window.parent.postMessage(key) return &#125; e.stopPropagation() if (!attr.style) &#123; attr.style = &#123;&#125; &#125; // 绑定元素被选中事件 this.$EventBus.$emit(&#x27;picEl&#x27;, &#123; style: attr.style, key: this.keyName &#125;) &#125; &#125; &#125; &#125; return this.objToVNode(&#123;key: key, tag, attr, vNode&#125;) &#125; else if (type === &quot;eval&quot;) &#123; vNode = eval(vNode) &#125; return h(tag, attr, vNode) &#125; &#125;&#125;) 方案四：最近在用processon，想到了写新方案 因为之前一直使用的是即时数据渲染，因此当没有数据时，页面会显得光秃秃的，因此现在添加新功能：模块底图 底层使用canvas绘制出已经修改并保存过的样式","categories":[],"tags":[{"name":"拖拽","slug":"拖拽","permalink":"https://wisiw.github.io.git/tags/%E6%8B%96%E6%8B%BD/"},{"name":"自定义","slug":"自定义","permalink":"https://wisiw.github.io.git/tags/%E8%87%AA%E5%AE%9A%E4%B9%89/"}]},{"title":"【算法】图片压缩与水印","slug":"【算法】图片压缩与水印","date":"2022-06-10T03:20:11.000Z","updated":"2022-06-10T08:42:49.872Z","comments":true,"path":"2022/06/10/【算法】图片压缩与水印/","link":"","permalink":"https://wisiw.github.io.git/2022/06/10/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E4%B8%8E%E6%B0%B4%E5%8D%B0/","excerpt":"","text":"一幅图像可以定义为一个二维函数f(x, y),当中的x和y是空间（平面）坐标，任意一对空间坐标(x, y)处的幅值f称为图像在该点的强度和灰度。 当x、y和灰度值f都是有限的离散量时，我们称该图像为数字图像。 图画元素（图像元素、像素）： 组成数字图像的有限数量的元素，每个元素都有一个特定的位置和数值 二维灰度阵列受如下能被识别和利用的三种主要数据冗余的影响： 编码冗余 编码是用于表示信息主体或事件集合的符号（字母、数字、比特等）系统。每条信息或事件被赋予一系列编码符号，我们称之为码字。每个码字中符号的数量就是该码字的长度。在多数二维灰度阵列中,用于表示灰度的8比特编码所包含的比特数，要比表示灰度所需的比特数多 空间和时间冗余 因为多数二维灰度阵列的像素是空间相关的（即每个像素类似于相邻像素或取决于相邻像素），在相关像素的表示中，信息被不必要地重复。在视频序列中，时间相关的像素（即类似于或取决于相邻帧中像素的那些像素）也是重复信息。 无关信息 多数二维灰度阵列中都含有一些被人类视觉系统忽略或与期望用途无关的信息。从未被利用的角度来看，这些信息是冗余的。","categories":[],"tags":[{"name":"图片压缩","slug":"图片压缩","permalink":"https://wisiw.github.io.git/tags/%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/"},{"name":"水印","slug":"水印","permalink":"https://wisiw.github.io.git/tags/%E6%B0%B4%E5%8D%B0/"}]},{"title":"【Spring】权限验证","slug":"【Spring】权限验证","date":"2022-06-04T15:35:01.000Z","updated":"2022-06-06T05:51:37.752Z","comments":true,"path":"2022/06/04/【Spring】权限验证/","link":"","permalink":"https://wisiw.github.io.git/2022/06/04/%E3%80%90Spring%E3%80%91%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81/","excerpt":"","text":"123456cn.weisw ├── config │ └── SecurityConfig.java ├── PermissionServer.java ├── test.java └── MainApplication.java 1.开启注解因为注解默认不可用，所以在使用前需要开启注解 @Secured：专门判断用户是否具有角色，可以写在方法或类上，参数以 ROLE_ 开头 @PreAuthorize\\PostAuthorize： PreAuthorize 访问的类或方法执行前判断权限，而 PostAuthorize 在执行之后，Post 基本不用；允许与 ROLE_ 开头。 123456789package cn.weisw.config;import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;// 开启注解@EnableGlobalMethodSecurity(prePostEnabled = true)public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;&#125; 2.注册服务使用@Service注册ps服务 123456789101112package cn.weisw;import org.springframework.stereotype.Service;@Service(&quot;ps&quot;)public class PermissionService &#123; public boolean hasPermi(String permission) &#123; System.out.println(permission); return true; &#125;&#125; 3.接口中使用使用ps的服务 1234567891011121314151617package cn.weisw;import org.springframework.security.access.prepost.PreAuthorize;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping(&quot;/&quot;)public class test &#123; @PreAuthorize(&quot;@ps.hasPermi(&#x27;system&#x27;)&quot;) @GetMapping(&quot;/aa&quot;) public void aa() &#123; System.out.println(333); &#125;&#125; 4.开启服务1234567891011package cn.weisw;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class MainApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MainApplication.class, args); &#125;&#125; 5.访问接口使用spring-boot-starter-security会打印下列日志，其中security password作为默认用户user的临时密码，是一个UUID字符串，访问接口时会进行登录校验，重定向至http://localhost:8080/login，此时输入Username:user,Password:269411c9-f772-4b90-8a48-9786dd754487登录后跳转至http://localhost:8080/aa 123Using generated security password: 269411c9-f772-4b90-8a48-9786dd754487This generated password is for development use only. Your security configuration must be updated before running your application in production. 接口访问成功后，会先进行public boolean hasPermi(String permission)进行校验，成功打印如下 12system333","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://wisiw.github.io.git/tags/JAVA/"},{"name":"Spring","slug":"Spring","permalink":"https://wisiw.github.io.git/tags/Spring/"},{"name":"权限验证","slug":"权限验证","permalink":"https://wisiw.github.io.git/tags/%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81/"}]},{"title":"【CSS】3DTextAnimation（3D文字滚动样式）","slug":"【CSS】3DTextAnimation（3D文字滚动样式）","date":"2022-01-03T16:17:11.000Z","updated":"2022-01-03T16:22:51.573Z","comments":true,"path":"2022/01/04/【CSS】3DTextAnimation（3D文字滚动样式）/","link":"","permalink":"https://wisiw.github.io.git/2022/01/04/%E3%80%90CSS%E3%80%913DTextAnimation%EF%BC%883D%E6%96%87%E5%AD%97%E6%BB%9A%E5%8A%A8%E6%A0%B7%E5%BC%8F%EF%BC%89/","excerpt":"","text":"源码","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://wisiw.github.io.git/tags/CSS/"},{"name":"文字滚动","slug":"文字滚动","permalink":"https://wisiw.github.io.git/tags/%E6%96%87%E5%AD%97%E6%BB%9A%E5%8A%A8/"}]},{"title":"【CSS】边框动画","slug":"【CSS】CSS基础","date":"2021-12-09T05:46:12.000Z","updated":"2022-04-18T05:24:22.012Z","comments":true,"path":"2021/12/09/【CSS】CSS基础/","link":"","permalink":"https://wisiw.github.io.git/2021/12/09/%E3%80%90CSS%E3%80%91CSS%E5%9F%BA%E7%A1%80/","excerpt":"","text":"源码 元素外框1&lt;div class=&quot;border-box&quot;&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637body &#123; background: #000000;&#125;.border-box &#123; width: 200px; height: 200px; box-shadow: 16px 14px 20px #000000; border-radius: 10px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: flex; justify-content: center; align-items: center;&#125;.border-box:before &#123; content: &#x27;&#x27;; width: 150%; height: 150%; position: absolute; border-radius: 10px;&#125;// 内部元素.border-box:after &#123; content: &#x27;Animation&#x27;; width: 190px; height: 190px; line-height: 190px; text-align: center; background: #000000; color: red; position: absolute; border-radius: 10px; letter-spacing: 5px; box-shadow: inset 20px 20px 20px #000000;&#125; 添加外框颜色1234.border-box:before &#123; /* ... */ background-image: conic-gradient(#ff0052 20deg, transparent 120deg);&#125; 外框旋转 1234.border-box:before &#123; /* ... */ animation: rotate 2s linear infinite;&#125; 遮挡动画外框1234.border-box &#123; /* ... */ overflow: hidden;&#125; 全部代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Border Animation&lt;/title&gt; &lt;style&gt; body &#123; background: #000000; &#125; .border-box &#123; width: 200px; height: 200px; box-shadow: 16px 14px 20px #000000; border-radius: 10px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: flex; justify-content: center; align-items: center; overflow: hidden; &#125; .border-box:before &#123; content: &#x27;&#x27;; background-image: conic-gradient(#ff0052 20deg, transparent 120deg); width: 150%; height: 150%; position: absolute; border-radius: 10px; animation: rotate 2s linear infinite; &#125; .border-box:after &#123; content: &#x27;Animation&#x27;; width: 190px; height: 190px; line-height: 190px; text-align: center; background: #000000; color: red; position: absolute; border-radius: 10px; letter-spacing: 5px; box-shadow: inset 20px 20px 20px #000000; &#125; @keyframes rotate &#123; 0% &#123; transform: rotate(0deg); &#125; 100% &#123; transform: rotate(-360deg); &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;border-box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://wisiw.github.io.git/tags/CSS/"}]},{"title":"【CSS】tips","slug":"【CSS】tips","date":"2021-12-09T05:46:12.000Z","updated":"2023-03-15T09:50:24.786Z","comments":true,"path":"2021/12/09/【CSS】tips/","link":"","permalink":"https://wisiw.github.io.git/2021/12/09/%E3%80%90CSS%E3%80%91tips/","excerpt":"","text":"1.函数1.1自定义变量1.1.1声明与使用1）在选择器中声明变量CSS选择器不能是数字开头，JS中的变量是不能直接数值的，但是，在CSS变量中，这些限制通通没有。 但不能包含$，[，^，(，%等字符，普通字符局限在只要是“数字[0-9]”“字母[a-zA-Z]”“下划线_”和“短横线-”这些组合，但是可以是中文，日文或者韩文 123:root &#123; --global-color: red;&#125; :root匹配的是文档的根元素（标签）所以常用于声明全局的CSS变量，也可以在其他选择器中 123body &#123; --global-color: red;&#125; 声明变量时需要在变量名前添加--以表名此为变量 2）使用，var()读取变量123.main &#123; color: var(--global-color);&#125; 3)组合使用使用变量时，可以组合使用，比如进行字符串拼接，如下 123456:root &#123; --content-text: &#x27;内容&#x27;&#125;span::before &#123; content: &#x27;before&#x27;var(--content-text)&#125; 当变量时数值时，必须使用calc()计算 123456:root &#123; -padding: 20;&#125;body &#123; padding: cal(var(--padding) * 1px)&#125; 2）在行内声明变量1234567&lt;style&gt; .circle &#123; width: 30px; height: 30px; background: var(--clr); &#125;&lt;/style&gt; style的选择器只能读取自身或者父元素声明在行内的变量 123&lt;div style=&quot;--clr: red&quot;&gt; &lt;div class=&quot;circle&quot;&gt;&lt;/div&gt;&lt;/div&gt; or 123&lt;div&gt; &lt;div class=&quot;circle&quot; style=&quot;--clr: red&quot;&gt;&lt;/div&gt;&lt;/div&gt; 3)默认值var(custom-property-name, value)var()第二个参数作为第一个参数为空或者错误时的值 123456789:root &#123; --clr: #fff&#125;body &#123; /* 未声明--color，因此使用第二个参数#000*/ color: var(--color, #000); /* 变量类型不对，因此使用第二个参数12px*/ font-size: var(--colr, 12px)&#125; 4）作用域:root&#123;&#125;用来声明全局变量 声明局部变量需要在某个特定的选择器下声明 12345678:root &#123; /* --clr全局可用 */ --clr: #f0f0f0;&#125;.main &#123; /* 此--clr只能在class为main的元素及其子孙元素中使用*/ --clr: #fff;&#125; 5）继承12345678910111213141516&lt;style&gt; .main &#123; --clr: #f0f0f0; &#125; .content1 &#123; --clr: #000; color: var(--clr); &#125; .content2 &#123; color: var(--clr); &#125;&lt;/style&gt;&lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;content1&quot;&gt;继承父元声明的变量&lt;/div&gt; &lt;div class=&quot;content2&quot;&gt;使用自己声明的变量&lt;/div&gt;&lt;/div&gt; 1.3 计算属性值calc()123.main &#123; width: calc(100% - 100px)&#125; 运算符前后需要保留空格，如width: calc(100%-100px)就不会起效，需要在-前后添加空格才会起效 支持+,-,*,/运算 计算时使用标准的数学运算优先级规则 1.41.51.6","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://wisiw.github.io.git/tags/CSS/"}]},{"title":"【CSS】底部栏动态切换","slug":"【CSS】底部栏动态切换","date":"2021-12-07T10:48:10.000Z","updated":"2021-12-09T05:46:49.508Z","comments":true,"path":"2021/12/07/【CSS】底部栏动态切换/","link":"","permalink":"https://wisiw.github.io.git/2021/12/07/%E3%80%90CSS%E3%80%91%E5%BA%95%E9%83%A8%E6%A0%8F%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2/","excerpt":"","text":"底部动态栏样式仓库 1.创建页面 1-2.HTML123456789101112131415161718&lt;div class=&quot;menu-box&quot;&gt; &lt;div class=&quot;menu-item active&quot;&gt; &lt;i class=&quot;menu-icon home&quot;&gt;&lt;/i&gt; &lt;span&gt;首页&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;menu-item&quot;&gt; &lt;i class=&quot;menu-icon discover&quot;&gt;&lt;/i&gt; &lt;span&gt;发现&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;menu-item&quot;&gt; &lt;i class=&quot;menu-icon search&quot;&gt;&lt;/i&gt; &lt;span&gt;探索&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;menu-item&quot;&gt; &lt;i class=&quot;menu-icon my&quot;&gt;&lt;/i&gt; &lt;span&gt;我的&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 1-2.CSS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051:root &#123; --iconSize: 80px; --borderW: 10px; --bgClr: #f0f0f0; --actClr: cadetblue; --actTextClr: #ffffff;&#125;.menu &#123; &amp;-box &#123; width: 600px; height: 80px; background: var(--bgClr); border-radius: 10px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: flex; justify-content: space-around; &#125; &amp;-item &#123; width: 25%; text-align: center; position: relative; z-index: 9; span &#123; display: none; &#125; &#125; &amp;-icon &#123; width: var(--iconSize); height: var(--iconSize); background-repeat: no-repeat; background-size: 40%; background-position: 50%; margin: 0 auto; display: inline-block; &amp;.home &#123; background-image: url(&quot;./imgs/home.svg&quot;); &#125; &amp;.discover &#123; background-image: url(&quot;./imgs/discover.svg&quot;); &#125; &amp;.search &#123; background-image: url(&quot;./imgs/search.svg&quot;); &#125; &amp;.my &#123; background-image: url(&quot;./imgs/my.svg&quot;); &#125; &#125;&#125; 2.添加选中样式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970.menu &#123; &amp;-item &#123; // ... &amp;.active &#123; .menu-icon &#123; transform: translate(0, -50%); animation: active 1s; &#125; @keyframes active &#123; 0% &#123; transform: translate(0, 0); &#125; 100% &#123; transform: translate(0, -50%); &#125; &#125; span &#123; display: block; color: var(--actTextClr); transform: translate(0, -30px); &#125; &#125; &amp;:nth-child(1).active ~ .menu-indicator &#123; left: 12.5%; &#125; &amp;:nth-child(2).active ~ .menu-indicator &#123; left: 12.5% + 25%; &#125; &amp;:nth-child(3).active ~ .menu-indicator &#123; left: 12.5% + 2 * 25%; &#125; &amp;:nth-child(4).active ~ .menu-indicator &#123; left: 12.5% + 3 * 25%; &#125; &#125; &amp;-indicator &#123; width:var(--iconSize); height: var(--iconSize); border-radius: 50%; box-sizing: border-box; border: var(--borderW) solid #ffffff; background-color: var(--actClr); position: absolute; transform: translate(-50%, -50%); &amp;:before &#123; content: &#x27;&#x27;; width: 20px; height: 20px; background: #f0f0f0; border-top-right-radius: 20px; display: inline-block; position: absolute; left: -27px; bottom: 10px; box-shadow: 0 -10px 0 0 #ffffff; &#125; &amp;:after &#123; content: &#x27;&#x27;; width: 20px; height: 20px; background: #f0f0f0; border-top-left-radius: 20px; display: inline-block; position: absolute; right: -27px; bottom: 10px; box-shadow: 0 -10px 0 0 #ffffff; &#125; &#125;&#125; 3.添加动态切换样式3-1.根据当前选中的标签和之前选中的标签动态切换样式1234567891011121314151617181920212223242526let current = 0const menus = document.getElementsByClassName(&#x27;menu-item&#x27;)for (let i = 0; i &lt; menus.length; i++) &#123; const menu = menus[i] menu.addEventListener(&#x27;click&#x27;, e =&gt; &#123; e.preventDefault() changeTab(i) &#125;)&#125;function changeTab(index) &#123; if (index === current) &#123; return &#125; const menus = document.getElementsByClassName(&#x27;menu-item&#x27;) if (!menus.length) &#123; return &#125; for (let i = 0; i &lt; menus.length; i++ ) &#123; if (i === index) &#123; menus[i].classList.add(&#x27;active&#x27;) &#125;else &#123; menus[i].classList.remove(&#x27;active&#x27;) &#125; &#125; current = index&#125; 3-2.为动态切换添加动画效果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function changeTab(index) &#123; // ... for (let i = 0; i &lt; menus.length; i++ ) &#123; if (i === index) &#123; // ... setKeyframes(`move$&#123;index + 1&#125;`, current, index) document.getElementsByClassName(&#x27;menu-indicator&#x27;)[0].style.animation = `move$&#123;index + 1&#125; 1s` &#125;else &#123; // ... &#125; &#125; // ...&#125;function setKeyframes(key_name, current, index) &#123; const token = window.WebKitCSSKeyframesRule ? &#x27;-webkit-&#x27;:&#x27;&#x27;; const nameRule = getKeyframes(key_name); let rules = ` @$&#123;token&#125;keyframes $&#123;key_name&#125;&#123; 0% &#123; left: $&#123;12.5 + 25 * current&#125;% &#125; 100% &#123; left: $&#123;12.5 + 25 * index&#125;%; &#125; &#125; ` if(JSON.stringify(nameRule) == &#x27;&#123;&#125;&#x27;)&#123; document.styleSheets[0].insertRule(rules,0); &#125;else&#123; nameRule.styleSheet.deleteRule(nameRule.index) nameRule.styleSheet.insertRule(rules,nameRule.index) &#125;&#125;function getKeyframes(name)&#123; const animation=&#123;&#125; const styleSheets=document.styleSheets for(let i=0;i&lt;styleSheets.length;i++)&#123; const item = styleSheets[i]; for (let j = 0; j &lt; item.cssRules.length; j ++) &#123; if(item.cssRules[j] &amp;&amp; item.cssRules[j].name &amp;&amp; item.cssRules[j].name == name)&#123; animation.cssRule = item.cssRules[j]; animation.styleSheet = item; animation.index = j; &#125; &#125; &#125; return animation;&#125; 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263let current = 0const menus = document.getElementsByClassName(&#x27;menu-item&#x27;)for (let i = 0; i &lt; menus.length; i++) &#123; const menu = menus[i] menu.addEventListener(&#x27;click&#x27;, e =&gt; &#123; e.preventDefault() changeTab(i) &#125;)&#125;function changeTab(index) &#123; if (index === current) &#123; return &#125; const menus = document.getElementsByClassName(&#x27;menu-item&#x27;) if (!menus.length) &#123; return &#125; for (let i = 0; i &lt; menus.length; i++ ) &#123; if (i === index) &#123; menus[i].classList.add(&#x27;active&#x27;) setKeyframes(`move$&#123;index + 1&#125;`, current, index) document.getElementsByClassName(&#x27;menu-indicator&#x27;)[0].style.animation = `move$&#123;index + 1&#125; 1s` &#125;else &#123; menus[i].classList.remove(&#x27;active&#x27;) &#125; &#125; current = index&#125;function setKeyframes(key_name, current, index) &#123; const token = window.WebKitCSSKeyframesRule ? &#x27;-webkit-&#x27;:&#x27;&#x27;; const nameRule = getKeyframes(key_name); let rules = ` @$&#123;token&#125;keyframes $&#123;key_name&#125;&#123; 0% &#123; left: $&#123;12.5 + 25 * current&#125;% &#125; 100% &#123; left: $&#123;12.5 + 25 * index&#125;%; &#125; &#125; ` if(JSON.stringify(nameRule) == &#x27;&#123;&#125;&#x27;)&#123; document.styleSheets[0].insertRule(rules,0); &#125;else&#123; nameRule.styleSheet.deleteRule(nameRule.index) nameRule.styleSheet.insertRule(rules,nameRule.index) &#125;&#125;function getKeyframes(name)&#123; const animation=&#123;&#125; const styleSheets=document.styleSheets for(let i=0;i&lt;styleSheets.length;i++)&#123; const item = styleSheets[i]; for (let j = 0; j &lt; item.cssRules.length; j ++) &#123; if(item.cssRules[j] &amp;&amp; item.cssRules[j].name &amp;&amp; item.cssRules[j].name == name)&#123; animation.cssRule = item.cssRules[j]; animation.styleSheet = item; animation.index = j; &#125; &#125; &#125; return animation;&#125; 源码HTML123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;BottomNavigationMenu&lt;/title&gt; &lt;link rel=&quot;stylesheet/less&quot; type=&quot;text/css&quot; href=&quot;./style.less&quot; /&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/less@4.1.2/dist/less.min.js&quot; &gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;menu-box&quot;&gt; &lt;div class=&quot;menu-item active&quot;&gt; &lt;i class=&quot;menu-icon home&quot;&gt;&lt;/i&gt; &lt;span&gt;首页&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;menu-item&quot;&gt; &lt;i class=&quot;menu-icon discover&quot;&gt;&lt;/i&gt; &lt;span&gt;发现&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;menu-item&quot;&gt; &lt;i class=&quot;menu-icon search&quot;&gt;&lt;/i&gt; &lt;span&gt;探索&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;menu-item&quot;&gt; &lt;i class=&quot;menu-icon my&quot;&gt;&lt;/i&gt; &lt;span&gt;我的&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;menu-indicator&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; let current = 0 const menus = document.getElementsByClassName(&#x27;menu-item&#x27;) for (let i = 0; i &lt; menus.length; i++) &#123; const menu = menus[i] menu.addEventListener(&#x27;click&#x27;, e =&gt; &#123; e.preventDefault() changeTab(i) &#125;) &#125; function changeTab(index) &#123; if (index === current) &#123; return &#125; const menus = document.getElementsByClassName(&#x27;menu-item&#x27;) if (!menus.length) &#123; return &#125; for (let i = 0; i &lt; menus.length; i++ ) &#123; if (i === index) &#123; menus[i].classList.add(&#x27;active&#x27;) setKeyframes(`move$&#123;index + 1&#125;`, current, index) document.getElementsByClassName(&#x27;menu-indicator&#x27;)[0].style.animation = `move$&#123;index + 1&#125; 1s` &#125;else &#123; menus[i].classList.remove(&#x27;active&#x27;) &#125; &#125; current = index &#125; function setKeyframes(key_name, current, index) &#123; const token = window.WebKitCSSKeyframesRule ? &#x27;-webkit-&#x27;:&#x27;&#x27;; const nameRule = getKeyframes(key_name); let rules = ` @$&#123;token&#125;keyframes $&#123;key_name&#125;&#123; 0% &#123; left: $&#123;12.5 + 25 * current&#125;% &#125; 100% &#123; left: $&#123;12.5 + 25 * index&#125;%; &#125; &#125; ` if(JSON.stringify(nameRule) == &#x27;&#123;&#125;&#x27;)&#123; document.styleSheets[0].insertRule(rules,0); &#125;else&#123; nameRule.styleSheet.deleteRule(nameRule.index) nameRule.styleSheet.insertRule(rules,nameRule.index) &#125; &#125; function getKeyframes(name)&#123; const animation=&#123;&#125; const styleSheets=document.styleSheets for(let i=0;i&lt;styleSheets.length;i++)&#123; const item = styleSheets[i]; for (let j = 0; j &lt; item.cssRules.length; j ++) &#123; if(item.cssRules[j] &amp;&amp; item.cssRules[j].name &amp;&amp; item.cssRules[j].name == name)&#123; animation.cssRule = item.cssRules[j]; animation.styleSheet = item; animation.index = j; &#125; &#125; &#125; return animation; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; CSS使用less 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116:root &#123; --iconSize: 80px; --borderW: 10px; --bgClr: #f0f0f0; --actClr: cadetblue; --actTextClr: #ffffff;&#125;.menu &#123; &amp;-box &#123; width: 600px; height: 80px; background: var(--bgClr); border-radius: 10px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: flex; justify-content: space-around; &#125; &amp;-item &#123; width: 25%; text-align: center; position: relative; z-index: 9; span &#123; display: none; &#125; &amp;.active &#123; .menu-icon &#123; transform: translate(0, -50%); animation: active 1s; &#125; @keyframes active &#123; 0% &#123; transform: translate(0, 0); &#125; 100% &#123; transform: translate(0, -50%); &#125; &#125; span &#123; display: block; color: var(--actTextClr); transform: translate(0, -30px); &#125; &#125; &amp;:nth-child(1).active ~ .menu-indicator &#123; left: 12.5%; &#125; &amp;:nth-child(2).active ~ .menu-indicator &#123; left: 12.5% + 25%; &#125; &amp;:nth-child(3).active ~ .menu-indicator &#123; left: 12.5% + 2 * 25%; &#125; &amp;:nth-child(4).active ~ .menu-indicator &#123; left: 12.5% + 3 * 25%; &#125; &#125; &amp;-icon &#123; width: var(--iconSize); height: var(--iconSize); background-repeat: no-repeat; background-size: 40%; background-position: 50%; margin: 0 auto; display: inline-block; &amp;.home &#123; background-image: url(&quot;./imgs/home.svg&quot;); &#125; &amp;.discover &#123; background-image: url(&quot;./imgs/discover.svg&quot;); &#125; &amp;.search &#123; background-image: url(&quot;./imgs/search.svg&quot;); &#125; &amp;.my &#123; background-image: url(&quot;./imgs/my.svg&quot;); &#125; &#125; &amp;-indicator &#123; width:var(--iconSize); height: var(--iconSize); border-radius: 50%; box-sizing: border-box; border: var(--borderW) solid #ffffff; background-color: var(--actClr); position: absolute; transform: translate(-50%, -50%); &amp;:before &#123; content: &#x27;&#x27;; width: 20px; height: 20px; background: #f0f0f0; border-top-right-radius: 20px; display: inline-block; position: absolute; left: -27px; bottom: 10px; box-shadow: 0 -10px 0 0 #ffffff; &#125; &amp;:after &#123; content: &#x27;&#x27;; width: 20px; height: 20px; background: #f0f0f0; border-top-left-radius: 20px; display: inline-block; position: absolute; right: -27px; bottom: 10px; box-shadow: 0 -10px 0 0 #ffffff; &#125; &#125;&#125;","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://wisiw.github.io.git/tags/CSS/"},{"name":"H5","slug":"H5","permalink":"https://wisiw.github.io.git/tags/H5/"}]},{"title":"【JavaScript】构建单页面应用","slug":"【JavaScript】构建单页面应用","date":"2021-12-06T05:13:06.000Z","updated":"2021-12-06T09:26:58.038Z","comments":true,"path":"2021/12/06/【JavaScript】构建单页面应用/","link":"","permalink":"https://wisiw.github.io.git/2021/12/06/%E3%80%90JavaScript%E3%80%91%E6%9E%84%E5%BB%BA%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8/","excerpt":"","text":"页面目录1234567891011single ├── frontend | ├── static | | ├──js | | | └─ index.js | | └─ views | | ├─ View.js | | └─ Setting.js | └─ index.html ├── package.json └── server.js 1.使用express构建应用12npm init -ynpm i express 1234567891011121314// server.jsconst express = require(&#x27;express&#x27;)const path = require(&#x27;path&#x27;)const app = express()function resolvePath(_path) &#123; return path.resolve(__dirname, &#x27;frontend&#x27;, _path)&#125;app.use(&#x27;/static&#x27;, express.static(resolvePath(&#x27;static&#x27;)))app.get(&#x27;/*&#x27;, (req, res) =&gt; &#123; res.sendFile(resolvePath(&#x27;index.html&#x27;))&#125;)app.listen(process.env.PORT || 5001 , () =&gt; console.log(&#x27;serve running...&#x27;)) 2.创建首页此时点击链接会跳转相应页面，并刷新当前页 1234567891011&lt;!-- frontend/index.html --&gt;&lt;html&gt; &lt;body&gt; &lt;nav&gt; &lt;a href=&quot;/&quot; data-link&gt;/&lt;/a&gt; &lt;a href=&quot;/post&quot; data-link&gt;post&lt;/a&gt; &lt;a href=&quot;/setting&quot; data-link&gt;setting&lt;/a&gt; &lt;/nav&gt; &lt;script type=&quot;module&quot; src=&quot;/static/js/index.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 3.创建路由12345678910111213141516171819202122// fronted/static/js/index.jsconst router = async () =&gt; &#123; const routes = [ &#123;path: &#x27;/&#x27;, view: () =&gt; console.log(&#x27;/&#x27;)&#125;, &#123;path: &#x27;/setting&#x27;, view: () =&gt; console.log(&#x27;/setting&#x27;)&#125; ] // 匹配当前路由。无匹配项则匹配根路由 const potentialMatches = routes.map(route =&gt; &#123; return &#123; route, isMatch: route.path === location.pathname &#125; &#125;) let match = potentialMatches.find(potentialMatche =&gt; potentialMatche.isMatch) if(!match) &#123; match = &#123; route: routes[0], isMatch: true &#125; &#125; console.log(match.route.view())&#125; 4.监听路由切换12345678910111213141516// fronted/static/js/index.js// 监听历史记录条目的更改window.addEventListener(&#x27;popstate&#x27;, () =&gt; &#123; console.log(&quot;popstate&quot;); router()&#125;)// 当初始的HTML文档被完全加载和解析完毕后，监听页面的click事件，当触发clik的元素包含[data-link]属性，阻止冒泡，并对路由进行处理window.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; &#123; router() document.body.addEventListener(&#x27;click&#x27;, e =&gt; &#123; if (e.target.matches(&#x27;[data-link]&#x27;)) &#123; e.preventDefault() // ... &#125; &#125;)&#125;) 5.切换路由，但DOM不刷新123456789101112131415// fronted/static/js/index.jsconst navigateTo = url =&gt; &#123; // 切换路由，但不刷新页面 history.pushState(null, null, url) router()&#125;window.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; &#123; router() document.body.addEventListener(&#x27;click&#x27;, e =&gt; &#123; if (e.target.matches(&#x27;[data-link]&#x27;)) &#123; e.preventDefault() navigateTo(e.target.href) &#125; &#125;)&#125;) 6.创建单页面6-1.创建根页面1234567891011121314// fronted/static/views/View.jsexport default class &#123; constructor() &#123; this.title = null &#125; setTitle(title) &#123; this.title = title document.title = title &#125; async getHtml() &#123; return `` &#125;&#125; 6-2.创建/setting页面12345678910111213// fronted/static/views/Setting.jsimport View from &#x27;./View.js&#x27;export default class extends View &#123; constructor() &#123; super() this.setTitle(&#x27;Setting&#x27;) &#125; async getHtml() &#123; return `&lt;h1&gt;Setting&lt;/h1&gt;` &#125;&#125; 6-3.在页面中创建展示页面的元素12345678&lt;!-- frontend/index.html --&gt;&lt;html&gt; &lt;body&gt; &lt;nav&gt;...&lt;/nav&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script type=&quot;module&quot; src=&quot;/static/js/index.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 7.在框架中应用页面12345678910111213// fronted/static/js/index.jsimport SettingView from &#x27;../views/Setting.js&#x27;import View from &#x27;../views/View.js&#x27;const router = async () =&gt; &#123; const routes = [ &#123;path: &#x27;/&#x27;, view: View&#125;, &#123;path: &#x27;/setting&#x27;, view: SettingView&#125; ] // ... const view = new match.route.view() // 将返回的当页面嵌入当前页面 document.querySelector(&#x27;#app&#x27;).innerHTML = await view.getHtml()&#125; 8.获取地址栏中的参数主要使用正则获取 8-1.路由匹配1234567891011121314151617181920212223242526const pathToRegex = path =&gt; new RegExp(&#x27;^&#x27; + path.replace(/\\//g, &#x27;\\\\/&#x27;).replace(/:\\w+/g, &#x27;(.+)&#x27;) + &#x27;$&#x27;)import SettingView from &#x27;../views/Setting.js&#x27;import View from &#x27;../views/View.js&#x27;const router = async () =&gt; &#123; const routes = [ &#123; path: &#x27;/&#x27;, view: View &#125;, &#123; path: &#x27;/setting/:id&#x27;, view: SettingView &#125; ] const potentialMatches = routes.map(route =&gt; &#123; return &#123; route, result: location.pathname.match(pathToRegex(route.path)) &#125; &#125;) let match = potentialMatches.find(potentialMatche =&gt; potentialMatche.result !== null) if(!match) &#123; match = &#123; route: routes[0], result: [location.pathname] &#125; &#125; // ...&#125; 8-2.路由传值12345678910111213const getParams = match =&gt; &#123; const values = match.result.slice(1) const keys = Array.from(match.route.path.matchAll(/:(\\w+)/g)).map(result =&gt; result[1]); return Object.fromEntries( keys.map( (key,i) =&gt; &#123; return [key, values[i]] &#125;))&#125;const router = async () =&gt; &#123; // ... const view = new match.route.view(getParams(match)) // ...&#125; 8-3.页面接受参数123456789101112131415// fronted/static/views/View.jsexport default class &#123; constructor(params) &#123; this.params = params this.title = null &#125; setTitle(title) &#123; this.title = title document.title = title &#125; async getHtml() &#123; return `` &#125;&#125; 12345678910111213// fronted/static/views/Setting.jsimport View from &#x27;./View.js&#x27;export default class extends View &#123; constructor() &#123; super(props) this.setTitle(&#x27;Setting&#x27;) &#125; async getHtml() &#123; return `&lt;h1&gt;Setting$&#123;this.params.id&#125;&lt;/h1&gt;` &#125;&#125; 源码：https://github.com/WiSiW/frontend/tree/master/single","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wisiw.github.io.git/tags/JavaScript/"},{"name":"single","slug":"single","permalink":"https://wisiw.github.io.git/tags/single/"}]},{"title":"【CSS】页面容器响应式化","slug":"【CSS】页面容器响应式化","date":"2021-12-03T05:57:22.000Z","updated":"2021-12-03T06:40:43.416Z","comments":true,"path":"2021/12/03/【CSS】页面容器响应式化/","link":"","permalink":"https://wisiw.github.io.git/2021/12/03/%E3%80%90CSS%E3%80%91%E9%A1%B5%E9%9D%A2%E5%AE%B9%E5%99%A8%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8C%96/","excerpt":"","text":"这是在1080比例下的页面容器组成 1.基础响应式化，使用%2.使用rem以上的方法适用于页面排版不固定，不会因为宽高比变化打乱排版 如果页面各个模块都已经有了固定排版，使用百分比会打乱排版顺序，这是就需要牺牲部分宽高比下的页面基础 3.使用transform来进行等比缩放保持页面中的内容排版不变化，根据窗口高度变换大小","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://wisiw.github.io.git/tags/CSS/"},{"name":"响应式","slug":"响应式","permalink":"https://wisiw.github.io.git/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"},{"name":"transform","slug":"transform","permalink":"https://wisiw.github.io.git/tags/transform/"}]},{"title":"【小程序】爬坑","slug":"【小程序】爬坑","date":"2021-12-01T02:05:09.000Z","updated":"2021-12-01T02:33:18.379Z","comments":true,"path":"2021/12/01/【小程序】爬坑/","link":"","permalink":"https://wisiw.github.io.git/2021/12/01/%E3%80%90%E5%B0%8F%E7%A8%8B%E5%BA%8F%E3%80%91%E7%88%AC%E5%9D%91/","excerpt":"","text":"Q: 为什么子组件的属性写了默认值，但是不显示**A:**父组件给组件的此属性传了值 **W:**无论父组件传给子组件的属性是否为空，都会替换子组件的属性设置的默认值 CODE 子组件 Label.wxml 12345678Component(&#123; properties: &#123; title: &#123; type: String, value: &#x27;子组件标题&#x27; &#125; &#125;&#125;) Label.wxml 1&lt;text&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; 父页面 index.wxml 1&lt;label title=&quot;&#123;&#123;title&#125;&#125;&quot;&gt;&lt;/label&gt; index.json 12345&#123; &quot;usingComponents&quot;: &#123; &quot;label&quot;: &quot;./components/label/label&quot; &#125;&#125; index.js 12345Page(&#123; data: &#123; title: &#x27;父页面标题&#x27; &#125;&#125;) 此时页面会显示【父页面标题】 12345Page(&#123; data: &#123; title: &#x27;&#x27; &#125;&#125;) 此时页面不会显示文字 需要页面显示子组件的默认值，需要 1&lt;label&gt;&lt;/label&gt; 此时会显示子组件title属性的默认值","categories":[],"tags":[{"name":"爬坑","slug":"爬坑","permalink":"https://wisiw.github.io.git/tags/%E7%88%AC%E5%9D%91/"},{"name":"小程序","slug":"小程序","permalink":"https://wisiw.github.io.git/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"【electron】爬坑","slug":"【electron】爬坑","date":"2021-12-01T01:46:54.000Z","updated":"2021-12-01T02:05:59.834Z","comments":true,"path":"2021/12/01/【electron】爬坑/","link":"","permalink":"https://wisiw.github.io.git/2021/12/01/%E3%80%90electron%E3%80%91%E7%88%AC%E5%9D%91/","excerpt":"","text":"Q: process打印不出来A: 需要在main.js中的BrowserWindow中添加配置 如果是16.X.X以下，那么 1234567const win = new BrowserWindow(&#123; // ... webPreferences: &#123; // ... nodeIntegration: true &#125;&#125;) 如果是16.X.X，则 12345678const win = new BrowserWindow(&#123; // ... webPreferences: &#123; // ... nodeIntegration: true, contextIsolation: false &#125;&#125;) **W:**16.X.X以上版本的bug","categories":[],"tags":[{"name":"electron","slug":"electron","permalink":"https://wisiw.github.io.git/tags/electron/"},{"name":"爬坑","slug":"爬坑","permalink":"https://wisiw.github.io.git/tags/%E7%88%AC%E5%9D%91/"}]},{"title":"【小程序】mixin混入","slug":"【小程序】mixin混入","date":"2021-11-30T05:28:19.000Z","updated":"2023-09-14T01:49:28.830Z","comments":true,"path":"2021/11/30/【小程序】mixin混入/","link":"","permalink":"https://wisiw.github.io.git/2021/11/30/%E3%80%90%E5%B0%8F%E7%A8%8B%E5%BA%8F%E3%80%91mixin%E6%B7%B7%E5%85%A5/","excerpt":"","text":"1.原理对Page函数进行数据拦截，将需要混入的属性与原属性先行混合再进行Page处理 对Page函数进行拦截123456789101112// 保存原Page函数的指针const _Page = Page// 对Page传入Page函数的options中的mixins进行展开处理混入options中并删除Page = (options = &#123;&#125;) =&gt; &#123; const mixins = options.mixins if (Array.isArray(mixins)) &#123; Reflect.deleteProperty(options, &#x27;mixins&#x27;) options = merge(mixins, options) &#125; console.log(options); _Page(options)&#125; 对传入的options中的mixins中的属性进行合并处理1234567891011121314151617181920212223242526272829// Page原生组件const properties = [&#x27;data&#x27;, &#x27;properties&#x27;, &#x27;options&#x27;]const methods = [&#x27;onLoad&#x27;, &#x27;onShow&#x27;, &#x27;onReady&#x27;, &#x27;onHide&#x27;, &#x27;onUnload&#x27;, &#x27;onPullDownRefresh&#x27;, &#x27;onReachBottom&#x27;, &#x27;onShareAppMessage&#x27;, &#x27;onPageScroll&#x27;, &#x27;onResize&#x27;, &#x27;onTabItemTap&#x27;]const merge = (mixins, options) =&gt; &#123; mixins.forEach(mixin =&gt; &#123; if (Object.prototype.toString.call(mixin).slice(8, -1) !== &#x27;Object&#x27;) &#123; throw new Error(&#x27;mixin is not an object&#x27;) &#125; for (const [k, v] of Object.entries(mixin)) &#123; if (properties.includes(k)) &#123; options[k] = &#123; ...v, ...options[k]&#125; &#125; else if (methods.includes(k)) &#123; const func = options[k] options[k] = function(...arg) &#123; v.call(this, ...arg) func &amp;&amp; func.call(this, ...arg) &#125; &#125; else &#123; console.log(mixin[k]) options = &#123; ...mixin, ...options&#125; console.log(options); &#125; &#125; &#125;) return options&#125; 注意 1.混入中的属性会被原页面中的属性覆盖 2.使用1.项目结构1234567891011121314mixins ├── index | ├─ index.js | ├─ index.json | ├─ index.wxml | └─ index.wxss ├── mixins | ├─ a.js | └─ b.js ├── util | └─ mixin.js ├── app.js ├── app.json └── app.wxss 2.项目引入mixin功能在app.js中引入util中的mixin.js 12345// app.jsrequire(&#x27;./util/mixin.js&#x27;)App(&#123; onLaunch() &#123;&#125;&#125;) 1234567891011121314151617181920212223242526272829303132333435363738394041// util&gt;mixin.jsconst _Page = PagePage = (options = &#123;&#125;) =&gt; &#123; const mixins = options.mixins if (Array.isArray(mixins)) &#123; Reflect.deleteProperty(options, &#x27;mixins&#x27;) options = merge(mixins, options) &#125; console.log(options); _Page(options)&#125;// Page原生组件const properties = [&#x27;data&#x27;, &#x27;properties&#x27;, &#x27;options&#x27;]const methods = [&#x27;onLoad&#x27;, &#x27;onShow&#x27;, &#x27;onReady&#x27;, &#x27;onHide&#x27;, &#x27;onUnload&#x27;, &#x27;onPullDownRefresh&#x27;, &#x27;onReachBottom&#x27;, &#x27;onShareAppMessage&#x27;, &#x27;onPageScroll&#x27;, &#x27;onResize&#x27;, &#x27;onTabItemTap&#x27;]const merge = (mixins, options) =&gt; &#123; mixins.forEach(mixin =&gt; &#123; if (Object.prototype.toString.call(mixin).slice(8, -1) !== &#x27;Object&#x27;) &#123; throw new Error(&#x27;mixin is not an object&#x27;) &#125; for (const [k, v] of Object.entries(mixin)) &#123; if (properties.includes(k)) &#123; options[k] = &#123; ...v, ...options[k]&#125; &#125; else if (methods.includes(k)) &#123; const func = options[k] options[k] = function(...arg) &#123; v.call(this, ...arg) func &amp;&amp; func.call(this, ...arg) &#125; &#125; else &#123; console.log(mixin[k]) options = &#123; ...mixin, ...options&#125; console.log(options); &#125; &#125; &#125;) return options&#125; 3.编写需要混入的js文件123456789101112// mixins&gt;a.jsmodule.exports = &#123; data: &#123; id: 1 &#125;, onload() &#123; console.log(&#x27;mixin a onload&#x27;); &#125;, a() &#123; console.log(&#x27;mixin a&#x27;); &#125;&#125; 123456789101112// mixins&gt;b.jsmodule.exports = &#123; data: &#123; id: 2 &#125;, onload() &#123; console.log(&#x27;mixin b onload&#x27;); &#125;, b() &#123; console.log(&#x27;mixin b&#x27;); &#125;&#125; 4.页面中引入mixins123456789101112// index&gt;index.jsconst app = getApp()Page(&#123; mixins: [require(&#x27;../mixins/a.js&#x27;), require(&#x27;../mixins/b.js&#x27;)], data: &#123; id: 3 &#125;, onLoad() &#123; console.log(this.a); console.log(this.b); &#125;&#125;)","categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://wisiw.github.io.git/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"混入","slug":"混入","permalink":"https://wisiw.github.io.git/tags/%E6%B7%B7%E5%85%A5/"},{"name":"mixin","slug":"mixin","permalink":"https://wisiw.github.io.git/tags/mixin/"}]},{"title":"【小程序】连接低功耗蓝牙","slug":"【小程序】连接低功耗蓝牙","date":"2021-11-24T03:33:28.000Z","updated":"2021-11-24T03:33:28.192Z","comments":true,"path":"2021/11/24/【小程序】连接低功耗蓝牙/","link":"","permalink":"https://wisiw.github.io.git/2021/11/24/%E3%80%90%E5%B0%8F%E7%A8%8B%E5%BA%8F%E3%80%91%E8%BF%9E%E6%8E%A5%E4%BD%8E%E5%8A%9F%E8%80%97%E8%93%9D%E7%89%99/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"【canvas】canvas绘制签名","slug":"【canvas】canvas绘制签名","date":"2021-11-24T03:32:49.000Z","updated":"2021-12-08T11:55:07.395Z","comments":true,"path":"2021/11/24/【canvas】canvas绘制签名/","link":"","permalink":"https://wisiw.github.io.git/2021/11/24/%E3%80%90canvas%E3%80%91canvas%E7%BB%98%E5%88%B6%E7%AD%BE%E5%90%8D/","excerpt":"","text":"pc端、手机端适配canvas绘图原理监听触摸滑动或鼠标滑动，在canvas上绘制出相应的笔迹 功能演示HTML页面，下图灰色区域为绘制区，停止绘制后会在下方方框内生成图片 12345678910111213141516171819202122232425262728293031&lt;html&gt; &lt;head&gt; &lt;style&gt; .sign-box &#123; width: 200px; &#125; .sign-box .sign-img &#123; width: 100%; height: 100px; &#125; .sign-box .btn-box&gt;p &#123; width: 60px; height: 20px; line-height: 20px; text-align: center; display: inline-block; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;sign-box&quot;&gt; &lt;div class=&quot;sign-img&quot; id=&quot;canvas&quot;&gt; &lt;/div&gt; &lt;div class=&quot;btn-box&quot;&gt; &lt;p id=&quot;btn-clear&quot;&gt;清空&lt;/p&gt; &lt;p id=&quot;btn-sub&quot;&gt;确定&lt;/p&gt; &lt;/div&gt; &lt;img class=&quot;sign-img&quot; id=&quot;img&quot;&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 绘制程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657let cxt = null;// 签名笔记的基础样式const lineStyle = &#123; lineWidth: 2, strokeStyle: &#x27;#000000&#x27;, fillStyle: &#x27;#f7f7f7&#x27;, lineCap: &#x27;round&#x27;&#125;// 绘制区const canvasEl = document.getElementById(&quot;canvas&quot;)// 清空按钮const clearBtn = document.getElementById(&quot;btn-clear&quot;)// 提交按钮const subBtn = document.getElementById(&quot;btn-sub&quot;)lineCanvas(&#123;canvasEl, clearBtn, subBtn&#125;)// 移动绘制function lineCanvas(&#123; canvasEl, clearBtn, subBtn &#125;) &#123; const canvas = document.createElement(&quot;canvas&quot;); canvas.width = canvasEl.clientWidth; canvas.height = canvasEl.clientHeight; canvasEl.appendChild(canvas); cxt = canvas.getContext(&quot;2d&quot;); console.log(cxt) Object.keys(lineStyle).forEach(key =&gt; &#123; cxt[key] = lineStyle[key]; &#125;) cxt.fillRect(0, 0, canvas.width, canvas.height) IsPC() ? addMoveEvents(canvas) : addTouchEvents(canvas) // 为【清除】按钮绑定点击事件，清空画布 clearBtn &amp;&amp; clearBtn.addEventListener(&quot;click&quot;, function() &#123; console.log(&quot;清空画布...&quot;); cxt.clearRect(0, 0, canvas.width, canvas.height); document.getElementById(&quot;img&quot;).src = &#x27;&#x27;; &#125;) // 为【确定】按钮绑定点击事件保存图片 subBtn &amp;&amp; subBtn.addEventListener(&quot;click&quot;, function(e) &#123; console.log(&quot;保存图片...&quot;); if(!signImg) &#123; alert(&quot;请签名&quot;) return &#125; // do somthing &#125;)&#125;// 判断当前是否是PC端function IsPC() &#123; var userAgentInfo = navigator.userAgent; var Agents = [&quot;Android&quot;, &quot;iPhone&quot;, &quot;SymbianOS&quot;, &quot;Windows Phone&quot;, &quot;iPad&quot;, &quot;iPod&quot;]; var flag = true; for (var v = 0; v &lt; Agents.length; v++) &#123; if (userAgentInfo.indexOf(Agents[v]) &gt; 0) &#123; flag = false; break; &#125; &#125; return flag;&#125; pc端鼠标按下绘制123456789101112131415161718192021222324252627282930313233343536373839// 鼠标绘制function addMoveEvents(canvas) &#123; // 鼠标按下事件 const mousedown = function(e) &#123; console.log(&quot;开始绘制...&quot;); cxt.beginPath(); cxt.moveTo(e.pageX, e.pageY); // 绘制中 canvas.addEventListener(&quot;mousemove&quot;, mousemove, false) &#125; // 鼠标按下移动绘制事件 const mousemove = function(e) &#123; console.log(&quot;绘制中...&quot;); cxt.lineTo(e.pageX, e.pageY); cxt.stroke(); &#125; // 鼠标松开事件 const mouseup = function(e) &#123; console.log(&quot;结束绘制...&quot;); canvas.removeEventListener(&quot;mousemove&quot;, mousemove) cxt.closePath(); signImg = canvas.toDataURL(); console.log(signImg) document.getElementById(&quot;img&quot;).src = signImg &#125; // 阻止页面滑动 window.addEventListener(&#x27;touchmove&#x27;, function(e) &#123; e.preventDefault() &#125;, &#123; passive: false &#125;); // 监听绘制开始 canvas.addEventListener(&quot;mousedown&quot;, mousedown, false) // 结束绘制 canvas.addEventListener(&quot;mouseup&quot;, mouseup, false) // 鼠标移除画板后取消绘制时间 canvas.addEventListener(&quot;mouseout&quot;, function(e) &#123; console.log(&quot;鼠标移除画板&quot;); canvas.removeEventListener(&quot;mousemove&quot;, mousemove) &#125;)&#125; mobile端触摸绘制1234567891011121314151617181920212223242526272829// 触摸绘制function addTouchEvents(canvas) &#123; // 手指点下开始事件 const touchstart = function(e) &#123; console.log(&quot;开始绘制...&quot;); cxt.beginPath(); cxt.moveTo(e.changedTouches[0].pageX, e.changedTouches[0].pageY); &#125; // 触摸移动绘制事件 const touchmove = function(e) &#123; console.log(&quot;绘制中...&quot;); cxt.lineTo(e.changedTouches[0].pageX, e.changedTouches[0].pageY); cxt.stroke(); &#125; // 手指移开事件 const touchend = function(e) &#123; console.log(&quot;结束绘制...&quot;); cxt.closePath(); signImg = canvas.toDataURL(); console.log(signImg) document.getElementById(&quot;img&quot;).src = signImg &#125; // 监听绘制开始 canvas.addEventListener(&quot;touchstart&quot;, touchstart, false) // 绘制中 canvas.addEventListener(&quot;touchmove&quot;, touchmove, false) // 结束绘制 canvas.addEventListener(&quot;touchend&quot;, touchend, false)&#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152&lt;html&gt; &lt;head&gt; &lt;style&gt; .sign-box &#123; width: 200px; &#125; .sign-box .sign-img &#123; width: 100%; height: 100px; &#125; .sign-box .btn-box&gt;p &#123; width: 60px; height: 20px; line-height: 20px; text-align: center; display: inline-block; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;sign-box&quot;&gt; &lt;div class=&quot;sign-img&quot; id=&quot;canvas&quot;&gt; &lt;/div&gt; &lt;div class=&quot;btn-box&quot;&gt; &lt;p id=&quot;btn-clear&quot;&gt;清空&lt;/p&gt; &lt;p id=&quot;btn-sub&quot;&gt;确定&lt;/p&gt; &lt;/div&gt; &lt;img class=&quot;sign-img&quot; id=&quot;img&quot;&gt; &lt;/div&gt; &lt;script&gt; let cxt = null; const lineStyle = &#123; lineWidth: 2, strokeStyle: &#x27;#000000&#x27;, fillStyle: &#x27;#f7f7f7&#x27;, lineCap: &#x27;round&#x27; &#125; const canvasEl = document.getElementById(&quot;canvas&quot;) const clearBtn = document.getElementById(&quot;btn-clear&quot;) const subBtn = document.getElementById(&quot;btn-sub&quot;) window.addEventListener(&#x27;touchmove&#x27;, function(e) &#123; e.preventDefault() &#125;, &#123; passive: false &#125;); lineCanvas(&#123;canvasEl, clearBtn, subBtn&#125;) // 移动绘制 function lineCanvas(&#123; canvasEl, clearBtn, subBtn &#125;) &#123; const canvas = document.createElement(&quot;canvas&quot;); canvas.width = canvasEl.clientWidth; canvas.height = canvasEl.clientHeight; canvasEl.appendChild(canvas); cxt = canvas.getContext(&quot;2d&quot;); console.log(cxt) Object.keys(lineStyle).forEach(key =&gt; &#123; cxt[key] = lineStyle[key]; &#125;) cxt.fillRect(0, 0, canvas.width, canvas.height) IsPC() ? addMoveEvents(canvas) : addTouchEvents(canvas) // 清空画布 clearBtn &amp;&amp; clearBtn.addEventListener(&quot;click&quot;, function() &#123; console.log(&quot;清空画布...&quot;); cxt.clearRect(0, 0, canvas.width, canvas.height); document.getElementById(&quot;img&quot;).src = &#x27;&#x27;; &#125;) // 保存图片 subBtn &amp;&amp; subBtn.addEventListener(&quot;click&quot;, function(e) &#123; console.log(&quot;保存图片...&quot;); if(!signImg) &#123; alert(&quot;请签名&quot;) return &#125; // do somthing &#125;) &#125; // 鼠标绘制 function addMoveEvents(canvas) &#123; // 鼠标按下事件 const mousedown = function(e) &#123; console.log(&quot;开始绘制...&quot;); cxt.beginPath(); cxt.moveTo(e.pageX, e.pageY); // 绘制中 canvas.addEventListener(&quot;mousemove&quot;, mousemove, false) &#125; // 鼠标按下移动绘制事件 const mousemove = function(e) &#123; console.log(&quot;绘制中...&quot;); cxt.lineTo(e.pageX, e.pageY); cxt.stroke(); &#125; // 鼠标松开事件 const mouseup = function(e) &#123; console.log(&quot;结束绘制...&quot;); canvas.removeEventListener(&quot;mousemove&quot;, mousemove) cxt.closePath(); signImg = canvas.toDataURL(); console.log(signImg) document.getElementById(&quot;img&quot;).src = signImg &#125; // 监听绘制开始 canvas.addEventListener(&quot;mousedown&quot;, mousedown, false) // 结束绘制 canvas.addEventListener(&quot;mouseup&quot;, mouseup, false) // 鼠标移除画板后取消绘制时间 canvas.addEventListener(&quot;mouseout&quot;, function(e) &#123; console.log(&quot;鼠标移除画板&quot;); canvas.removeEventListener(&quot;mousemove&quot;, mousemove) &#125;) &#125; // 触摸绘制 function addTouchEvents(canvas) &#123; // 手指点下开始事件 const touchstart = function(e) &#123; console.log(&quot;开始绘制...&quot;); cxt.beginPath(); cxt.moveTo(e.changedTouches[0].pageX, e.changedTouches[0].pageY); &#125; // 触摸移动绘制事件 const touchmove = function(e) &#123; console.log(&quot;绘制中...&quot;); cxt.lineTo(e.changedTouches[0].pageX, e.changedTouches[0].pageY); cxt.stroke(); &#125; // 手指移开事件 const touchend = function(e) &#123; console.log(&quot;结束绘制...&quot;); cxt.closePath(); signImg = canvas.toDataURL(); console.log(signImg) document.getElementById(&quot;img&quot;).src = signImg &#125; // 监听绘制开始 canvas.addEventListener(&quot;touchstart&quot;, touchstart, false) // 绘制中 canvas.addEventListener(&quot;touchmove&quot;, touchmove, false) // 结束绘制 canvas.addEventListener(&quot;touchend&quot;, touchend, false) &#125; function IsPC() &#123; var userAgentInfo = navigator.userAgent; var Agents = [&quot;Android&quot;, &quot;iPhone&quot;, &quot;SymbianOS&quot;, &quot;Windows Phone&quot;, &quot;iPad&quot;, &quot;iPod&quot;]; var flag = true; for (var v = 0; v &lt; Agents.length; v++) &#123; if (userAgentInfo.indexOf(Agents[v]) &gt; 0) &#123; flag = false; break; &#125; &#125; return flag; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"canvas","slug":"canvas","permalink":"https://wisiw.github.io.git/tags/canvas/"},{"name":"绘图","slug":"绘图","permalink":"https://wisiw.github.io.git/tags/%E7%BB%98%E5%9B%BE/"},{"name":"签名","slug":"签名","permalink":"https://wisiw.github.io.git/tags/%E7%AD%BE%E5%90%8D/"}]},{"title":"【npm】包使用（模板）","slug":"【npm】包使用（模板）","date":"2021-11-22T06:33:11.000Z","updated":"2021-11-22T06:35:16.698Z","comments":true,"path":"2021/11/22/【npm】包使用（模板）/","link":"","permalink":"https://wisiw.github.io.git/2021/11/22/%E3%80%90npm%E3%80%91%E5%8C%85%E4%BD%BF%E7%94%A8%EF%BC%88%E6%A8%A1%E6%9D%BF%EF%BC%89/","excerpt":"","text":"","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"https://wisiw.github.io.git/tags/npm/"},{"name":"node","slug":"node","permalink":"https://wisiw.github.io.git/tags/node/"},{"name":"使用教程","slug":"使用教程","permalink":"https://wisiw.github.io.git/tags/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"}]},{"title":"【CSS】样式功能","slug":"【CSS】样式功能","date":"2021-11-16T08:00:41.000Z","updated":"2021-11-16T08:29:05.855Z","comments":true,"path":"2021/11/16/【CSS】样式功能/","link":"","permalink":"https://wisiw.github.io.git/2021/11/16/%E3%80%90CSS%E3%80%91%E6%A0%B7%E5%BC%8F%E5%8A%9F%E8%83%BD/","excerpt":"","text":"点闪烁 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;html&gt; &lt;head&gt; &lt;style&gt; .point &#123; background: #06DFF9; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); &#125; .point-level1 &#123; width: 10px; height: 10px; border-radius: 50%; &#125; .point-level2 &#123; width: 20px; height: 20px; border-radius: 50%; opacity: 0.45; animation: twinkle2 1s linear infinite; &#125; @keyframes twinkle2 &#123; 0% &#123; width: 10px; height: 10px; &#125; 100% &#123; width: 20px; height: 20px; &#125; &#125; .point-level3 &#123; width: 30px; height: 30px; border-radius: 50%; opacity: 0.35; animation: twinkle3 1s linear infinite; &#125; @keyframes twinkle3 &#123; 0% &#123; width: 10px; height: 10px; &#125; 100% &#123; width: 30px; height: 30px; &#125; &#125; .point-level4 &#123; width: 40px; height: 40px; border-radius: 50%; opacity: 0.25; animation: twinkle4 1s linear infinite; &#125; @keyframes twinkle4 &#123; 0% &#123; width: 10px; height: 10px; &#125; 100% &#123; width: 40px; height: 40px; &#125; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;point point-level1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;point point-level2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;point point-level3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;point point-level4&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://wisiw.github.io.git/tags/CSS/"}]},{"title":"【Echarts】踩坑","slug":"【Echarts】踩坑","date":"2021-11-16T02:45:43.000Z","updated":"2021-11-16T08:00:12.863Z","comments":true,"path":"2021/11/16/【Echarts】踩坑/","link":"","permalink":"https://wisiw.github.io.git/2021/11/16/%E3%80%90Echarts%E3%80%91%E8%B8%A9%E5%9D%91/","excerpt":"","text":"label设置不同的样式12345678910111213141516171819202122232425262728options = &#123; //... series: [ &#123; // ... label: &#123; show: true, formatter: function(v) &#123; return `&#123;d|$&#123;v.percent&#125;%&#125;\\n\\n&#123;b|$&#123;v.name&#125;&#125;` &#125;, rich: &#123; d: &#123; fontSize: 20, fontFamily: &#x27;PingFang SC&#x27;, fontWeight: 500, color: &#x27;rgba(248, 181, 43, 1)&#x27; &#125;, b: &#123; fontSize: 18, fontFamily: &#x27;PingFang SC&#x27;, fontWeight: 400, color: &#x27;#48AAFE&#x27; &#125; &#125; &#125; &#125; ]&#125; &#123;styleName|text content text content&#125;使用|隔开，前面是样式名，后面是值 标签的视觉引导线消失的原因 设置了label.position","categories":[],"tags":[{"name":"echarts","slug":"echarts","permalink":"https://wisiw.github.io.git/tags/echarts/"},{"name":"踩坑","slug":"踩坑","permalink":"https://wisiw.github.io.git/tags/%E8%B8%A9%E5%9D%91/"}]},{"title":"【架构】前端工程化（三）：git分支管理","slug":"【架构】前端工程化（三）：git分支管理","date":"2021-11-12T02:51:48.000Z","updated":"2021-12-01T02:34:29.816Z","comments":true,"path":"2021/11/12/【架构】前端工程化（三）：git分支管理/","link":"","permalink":"https://wisiw.github.io.git/2021/11/12/%E3%80%90%E6%9E%B6%E6%9E%84%E3%80%91%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Agit%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/","excerpt":"","text":"注意： 负责修复线上紧急Bug的hotfix分支在开发完成后必须合并到当前正在开发的develop分支，否则会造成下次版本发布后丢失hotfix的修复代码 release分支在测试阶段可能会有频繁的修复Bug行为，如果在此过程中同时进行下一个版本的迭代，必须在修复Bug之前将release分支合并到develop分支，否则会引起下一版本发布后上一版本Bug再次出现 参考来源： 前端工程化：体系设计与实践:http://product.dangdang.com/25204506.html","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://wisiw.github.io.git/tags/git/"},{"name":"前端工程化","slug":"前端工程化","permalink":"https://wisiw.github.io.git/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"分支管理","slug":"分支管理","permalink":"https://wisiw.github.io.git/tags/%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/"}]},{"title":"【源码】tips","slug":"【源码】tips","date":"2021-11-08T01:43:08.000Z","updated":"2021-11-18T05:38:21.485Z","comments":true,"path":"2021/11/08/【源码】tips/","link":"","permalink":"https://wisiw.github.io.git/2021/11/08/%E3%80%90%E6%BA%90%E7%A0%81%E3%80%91tips/","excerpt":"","text":"babel解析12345678class Person &#123; constructor () &#123; this.name = &quot;haimeimei&quot; &#125; getName() &#123; return this.name &#125;&#125; 结果 12345678910111213141516171819202122232425262728293031323334353637383940function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError(&quot;Cannot call a class as a function&quot;); &#125;&#125;function _defineProperties(target, props) &#123; for (var i = 0; i &lt; props.length; i++) &#123; var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (&quot;value&quot; in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); &#125;&#125;function _createClass(Constructor, protoProps, staticProps) &#123; if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor;&#125;var Person = /*#__PURE__*/function () &#123; &quot;use strict&quot;; function Person() &#123; _classCallCheck(this, Person); this.name = &quot;haimeimei&quot;; &#125; _createClass(Person, [&#123; key: &quot;getName&quot;, value: function getName() &#123; return this.name; &#125; &#125;]); return Person;&#125;(); /*#__PURE__*/terser的行内注释，标识当前函数是一个纯函数，可以被安全的删除 AnnotationsAnnotations in Terser are a way to tell it to treat a certain function call differently. The following annotations are available: /*@__INLINE__*/ - forces a function to be inlined somewhere. /*@__NOINLINE__*/ - Makes sure the called function is not inlined into the call site. /*@__PURE__*/ - Marks a function call as pure. That means, it can safely be dropped. You can use either a @ sign at the start, or a #. Here are some examples on how to use them: 1234567/*@__INLINE__*/function_always_inlined_here()/*#__NOINLINE__*/function_cant_be_inlined_into_here()const x = /*#__PURE__*/i_am_dropped_if_x_is_not_used() terser源码https://github.com/terser/terser","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://wisiw.github.io.git/tags/webpack/"}]},{"title":"【代码片段】base64<——>图片","slug":"【代码片段】base64<——>图片","date":"2021-11-04T09:45:00.000Z","updated":"2022-03-16T10:00:28.780Z","comments":true,"path":"2021/11/04/【代码片段】base64<——>图片/","link":"","permalink":"https://wisiw.github.io.git/2021/11/04/%E3%80%90%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E3%80%91base64%3C%E2%80%94%E2%80%94%3E%E5%9B%BE%E7%89%87/","excerpt":"","text":"1.base64转图片12345678910111213141516var app = require(&#x27;express&#x27;)();app.post(&#x27;/upload&#x27;, function(req, res)&#123; //接收前台POST过来的base64 var imgData = req.body.imgData; //过滤data:URL var base64Data = imgData.replace(/^data:image\\/\\w+;base64,/, &quot;&quot;); var dataBuffer = new Buffer(base64Data, &#x27;base64&#x27;); // 解码图片 // var dataBuffer = Buffer.from(base64Data, &#x27;base64&#x27;); // 这是另一种写法 fs.writeFile(&quot;image.png&quot;, dataBuffer, function(err) &#123; if(err)&#123; res.send(err); &#125;else&#123; res.send(&quot;保存成功！&quot;); &#125; &#125;);&#125;); 2.url转base6412345678910111213141516var app = require(&#x27;express&#x27;)();app.get(url,function(res)&#123; var chunks = []; //用于保存网络请求不断加载传输的缓冲数据 var size = 0; //保存缓冲数据的总长度 res.on(&#x27;data&#x27;,function(chunk)&#123; chunks.push(chunk); //在进行网络请求时，会不断接收到数据(数据不是一次性获取到的) size += chunk.length; //累加缓冲数据的长度 &#125;); res.on(&#x27;end&#x27;,function(err)&#123; var data = Buffer.concat(chunks, size); //Buffer.concat将chunks数组中的缓冲数据拼接起来，返回一个新的Buffer对象赋值给data var base64Img = data.toString(&#x27;base64&#x27;); //将Buffer对象转换为字符串并以base64编码格式显示 console.log(base64Img); //进入终端terminal,然后进入index.js所在的目录， &#125;);&#125;); 3.图片转base6412345const fs = require(&#x27;fs&#x27;);let bitmap = fs.readFileSync(&#x27;start.jpg&#x27;);let base64str = Buffer.from(bitmap, &#x27;binary&#x27;).toString(&#x27;base64&#x27;); // base64编码console.log(base64str);","categories":[],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://wisiw.github.io.git/tags/NodeJs/"}]},{"title":"【功能模块】即时通讯","slug":"【功能模块】即时通讯","date":"2021-11-04T09:45:00.000Z","updated":"2022-03-16T09:51:23.143Z","comments":true,"path":"2021/11/04/【功能模块】即时通讯/","link":"","permalink":"https://wisiw.github.io.git/2021/11/04/%E3%80%90%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97%E3%80%91%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"【功能模块】权限管理（Vue版）","slug":"【功能模块】权限管理","date":"2021-11-04T07:11:37.000Z","updated":"2022-11-06T21:14:56.851Z","comments":true,"path":"2021/11/04/【功能模块】权限管理/","link":"","permalink":"https://wisiw.github.io.git/2021/11/04/%E3%80%90%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97%E3%80%91%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/","excerpt":"","text":"使用场景 需要进行权限管理的组件或元素进行显示/隐藏和点击事件拦截 使用自定义指令与data-*12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const rights = &#123;&#125;rights.install = function(vue) &#123; vue.directive(&#x27;right-click&#x27;, &#123; inserted(el, binding, vNode) &#123; /* 第一次初始化点击事件*/ roleClickChange(el, binding, vNode) &#125;, componentUpdated(el, binding, vNode) &#123; /* 数据更新后，更新点击事件，重新绑定参数（这一步操作是为了解决在调用时，传了自定义的动态参数，参数不更新问题）*/ roleClickChange(el, binding, vNode) &#125; &#125;)&#125;const roleClickChange = (el, binding, vNode) =&gt; &#123; // 获取元素上的自定义数据 const tag = vNode.data.attrs[&#x27;data-pre&#x27;] /* 验证表达式是函数*/ if (typeof binding.value !== &#x27;function&#x27;) &#123; const compName = vNode.context.name // 获取组件名称 // 将警告传递给控制台 let error = `[right-click:] provided expression &#x27;$&#123;binding.expression&#125;&#x27; is not a function` if (compName) &#123; error += `Found in component &#x27;$&#123;compName&#125;&#x27; ` &#125; console.error(error) return &#125; /* 绑定点击事件*/ el.onclick = function(e) &#123; // 阻止冒泡处理兼容 const evt = e || window.event if (evt.stopPropagation) &#123; evt.stopPropagation() &#125; else &#123; evt.cancelBubble = true &#125; // 判断是否传递给指令参数 if (binding.arg === undefined) &#123; // 没有参数直接执行函数 binding.value(true) &#125; else &#123; // 有参数 &#125; &#125;&#125;export &#123; rights &#125; 1vue.use(rights) 使用组件权限组件12345678910111213141516171819202122232425&lt;template&gt; &lt;div v-if=&quot;isShow&quot;&gt; &lt;slot :handleClick=&quot;handleClick&quot;&gt; 需要处理权限的组件 &lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;Btn&#x27;, props: &#123; isShow: &#123; type: Boolean, default: true &#125; &#125;, methods: &#123; handleClick() &#123; console.log(11) &#125; &#125;&#125;&lt;/script&gt; 使用123456789101112131415161718192021&lt;template&gt; &lt;btn :pre=&quot;1&quot;&gt; &lt;template slot-scope=&quot;&#123; handleClick &#125;&quot;&gt; &lt;div @click=&quot;handleClick(a)&quot;&gt; 按钮 &lt;/div&gt; &lt;/template&gt; &lt;/btn&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;Index&#x27;, methods: &#123; a() &#123; console.log(111) &#125; &#125;&#125;&lt;/script&gt; 区别 directive components 能否控制按钮的隐藏 ✅，隐藏修改el.style.display=’none’，按钮卸载使用el.remove() ✅，隐藏使用v-show，卸载使用v-if 对原来的代码的影响 小，只需要添加自定义指令和data-* 大，需要在原来的按钮之外包裹一层组价 使用场景 按钮一直显示，只对按钮的出发时间进行权限判断 会依照权限显示/隐藏按钮 优点 对原代码改动少 能在封装组件中使用其他的封装好的组件 缺点 使用弹窗或消息提示之类的组件繁琐 对原代码改动较大","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://wisiw.github.io.git/tags/Vue/"},{"name":"代码片段","slug":"代码片段","permalink":"https://wisiw.github.io.git/tags/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"},{"name":"权限管理","slug":"权限管理","permalink":"https://wisiw.github.io.git/tags/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"}]},{"title":"【JavaScript】CommonJS与ES6的区别","slug":"【JavaScript】CommonJs与ES6的区别","date":"2021-10-26T09:22:08.000Z","updated":"2022-10-27T01:44:24.516Z","comments":true,"path":"2021/10/26/【JavaScript】CommonJs与ES6的区别/","link":"","permalink":"https://wisiw.github.io.git/2021/10/26/%E3%80%90JavaScript%E3%80%91CommonJs%E4%B8%8EES6%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"Differences between ES modules and CommonJS Differences between ES modules and CommonJSNo require, exports, or module.exportsIn most cases, the ES module import can be used to load CommonJS modules. If needed, a require function can be constructed within an ES module using module.createRequire(). No __filename or __dirnameThese CommonJS variables are not available in ES modules. __filename and __dirname use cases can be replicated via import.meta.url. No Native Module LoadingNative modules are not currently supported with ES module imports. They can instead be loaded with module.createRequire() or process.dlopen. No require.resolveRelative resolution can be handled via new URL(‘./local’, import.meta.url). For a complete require.resolve replacement, there is a flagged experimental import.meta.resolve API. Alternatively module.createRequire() can be used. No NODE_PATHNODE_PATH is not part of resolving import specifiers. Please use symlinks if this behavior is desired. No require.extensionsrequire.extensions is not used by import. The expectation is that loader hooks can provide this workflow in the future. No require.cacherequire.cache is not used by import as the ES module loader has its own separate cache. 导入导出 功能 CommonJS ES6 导入 ```exports module.export``` 导出 require import export指向module.exports 补充CommonJS输出的是一个值的拷贝，ES6输出的是值的引用CommonJS模块作为一个对象被导出，会加载一个新的对象，直接修改变量中的参数，会造成对象中的参数变化如果通过解构获取模块中的变量，然后通过模块中暴露的方法修改模块内部的变量，不会造成当前模块创建的变量的变化 123456// common.jsexports.name = &#x27;aaa&#x27;exports.changeName = (name) =&gt; &#123; this.name = name&#125; 12345678// index.jsconst common = require(&#x27;./common&#x27;)console.log(common.name); // aaacommon.changeName(&#x27;bbb&#x27;);console.log(common.name); // bbb 12345678// index.jsconst &#123;name, changeName&#125; = require(&#x27;./common&#x27;)console.log(name); // aaachangeName(&#x27;bbb&#x27;);console.log(name); // aaa ES6的运行机制与CommonJS不一样，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6的import 有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 1234567891011// es.jsexport const name = &quot;aaa&quot;export const changeName = name =&gt; &#123; console.log(this); this.name = name&#125;export default &#123; name, changeName&#125; 12345678&lt;body&gt; &lt;script type=&quot;module&quot; src=&quot;./common.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;module&quot;&gt; import common from &#x27;./common.js&#x27; console.log(common.name); // aaa common.changeName(&quot;bbb&quot;); // Uncaught TypeError: Cannot set properties of undefined (setting &#x27;name&#x27;) &lt;/script&gt;&lt;/body&gt; ES6支持再导出 123export &#123; es &#125; from &#x27;./es.js&#x27;export default &#123;&#125;; 动态导入 1234import(&#x27;es.js&#x27;).then(es =&gt; &#123; console.log(es); // Module &#123;Symbol(Symbol.toStringTag): &#x27;Module&#x27;&#125; console.log(es.default); // &#123;name: &#x27;aaa&#x27;, changeName: ƒ&#125;&#125;) 加载 功能 CommonJS ES6 加载 运行时 编译时 详情 CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法 ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块 文件命名Node.js 会将.cjs文件视为 CommonJS 模块，将.mjs文件视为 ECMAScript 模块。它会将.js文件视为项目的默认模块系统（除非package.json说的是 CommonJS “type”: “module”,）。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wisiw.github.io.git/tags/JavaScript/"},{"name":"CommonJS","slug":"CommonJS","permalink":"https://wisiw.github.io.git/tags/CommonJS/"},{"name":"ES6","slug":"ES6","permalink":"https://wisiw.github.io.git/tags/ES6/"},{"name":"module","slug":"module","permalink":"https://wisiw.github.io.git/tags/module/"}]},{"title":"【npm】diff","slug":"【npm】diff","date":"2021-10-26T07:21:39.000Z","updated":"2022-10-26T09:21:06.130Z","comments":true,"path":"2021/10/26/【npm】diff/","link":"","permalink":"https://wisiw.github.io.git/2021/10/26/%E3%80%90npm%E3%80%91diff/","excerpt":"","text":"diff jsdiff A javascript text differencing implementation. Based on the algorithm proposed in“An O(ND) Difference Algorithm and its Variations” (Myers, 1986). Installation1npm install diff --save API Diff.diffChars(oldStr, newStr[, options]) - diffs two blocks of text, comparing character by character. Returns a list of change objects (See below). Options ignoreCase: true to ignore casing difference. Defaults to false. Diff.diffWords(oldStr, newStr[, options]) - diffs two blocks of text, comparing word by word, ignoring whitespace. Returns a list of change objects (See below). Options ignoreCase: Same as in diffChars. Diff.diffWordsWithSpace(oldStr, newStr[, options]) - diffs two blocks of text, comparing word by word, treating whitespace as significant. Returns a list of change objects (See below). Diff.diffLines(oldStr, newStr[, options]) - diffs two blocks of text, comparing line by line. Options ignoreWhitespace: true to ignore leading and trailing whitespace. This is the same as diffTrimmedLines newlineIsToken: true to treat newline characters as separate tokens. This allows for changes to the newline structure to occur independently of the line content and to be treated as such. In general this is the more human friendly form of diffLines and diffLines is better suited for patches and other computer friendly output. Returns a list of change objects (See below). Diff.diffTrimmedLines(oldStr, newStr[, options]) - diffs two blocks of text, comparing line by line, ignoring leading and trailing whitespace. Returns a list of change objects (See below). Diff.diffSentences(oldStr, newStr[, options]) - diffs two blocks of text, comparing sentence by sentence. Returns a list of change objects (See below). Diff.diffCss(oldStr, newStr[, options]) - diffs two blocks of text, comparing CSS tokens. Returns a list of change objects (See below). Diff.diffJson(oldObj, newObj[, options]) - diffs two JSON objects, comparing the fields defined on each. The order of fields, etc does not matter in this comparison. Returns a list of change objects (See below). Diff.diffArrays(oldArr, newArr[, options]) - diffs two arrays, comparing each item for strict equality (===). Options comparator: function(left, right) for custom equality checks Returns a list of change objects (See below). Diff.createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader) - creates a unified diff patch. Parameters: oldFileName : String to be output in the filename section of the patch for the removals newFileName : String to be output in the filename section of the patch for the additions oldStr : Original string value newStr : New string value oldHeader : Additional information to include in the old file header newHeader : Additional information to include in the new file header options : An object with options. context describes how many lines of context should be included. ignoreWhitespace: true to ignore leading and trailing whitespace. newlineIsToken: true to treat newline characters as separate tokens. This allows for changes to the newline structure to occur independently of the line content and to be treated as such. In general this is the more human friendly form of diffLines and diffLines is better suited for patches and other computer friendly output. Diff.createPatch(fileName, oldStr, newStr, oldHeader, newHeader) - creates a unified diff patch. Just like Diff.createTwoFilesPatch, but with oldFileName being equal to newFileName. Diff.structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) - returns an object with an array of hunk objects. This method is similar to createTwoFilesPatch, but returns a data structure suitable for further processing. Parameters are the same as createTwoFilesPatch. The data structure returned may look like this: 12345678&#123; oldFileName: &#x27;oldfile&#x27;, newFileName: &#x27;newfile&#x27;, oldHeader: &#x27;header1&#x27;, newHeader: &#x27;header2&#x27;, hunks: [&#123; oldStart: 1, oldLines: 3, newStart: 1, newLines: 3, lines: [&#x27; line2&#x27;, &#x27; line3&#x27;, &#x27;-line4&#x27;, &#x27;+line5&#x27;, &#x27;\\\\ No newline at end of file&#x27;], &#125;]&#125; Diff.applyPatch(source, patch[, options]) - applies a unified diff patch. Return a string containing new version of provided data. patch may be a string diff or the output from the parsePatch or structuredPatch methods. The optional options object may have the following keys: fuzzFactor: Number of lines that are allowed to differ before rejecting a patch. Defaults to 0. compareLine(lineNumber, line, operation, patchContent): Callback used to compare to given lines to determine if they should be considered equal when patching. Defaults to strict equality but may be overridden to provide fuzzier comparison. Should return false if the lines should be rejected. Diff.applyPatches(patch, options) - applies one or more patches. This method will iterate over the contents of the patch and apply to data provided through callbacks. The general flow for each patch index is: options.loadFile(index, callback) is called. The caller should then load the contents of the file and then pass that to the callback(err, data) callback. Passing an err will terminate further patch execution. options.patched(index, content, callback) is called once the patch has been applied. content will be the return value from applyPatch. When it’s ready, the caller should call callback(err) callback. Passing an err will terminate further patch execution. Once all patches have been applied or an error occurs, the options.complete(err) callback is made. Diff.parsePatch(diffStr) - Parses a patch into structured data Return a JSON object representation of the a patch, suitable for use with the applyPatch method. This parses to the same structure returned by Diff.structuredPatch. convertChangesToXML(changes) - converts a list of changes to a serialized XML format All methods above which accept the optional callback method will run in sync mode when that parameter is omitted and in async mode when supplied. This allows for larger diffs without blocking the event loop. This may be passed either directly as the final parameter or as the callback field in the options object. Change ObjectsMany of the methods above return change objects. These objects consist of the following fields: value: Text content added: True if the value was inserted into the new string removed: True if the value was removed from the old string Note that some cases may omit a particular flag field. Comparison on the flag fields should always be done in a truthy or falsy manner. ExamplesBasic example in Node 12345678910111213require(&#x27;colors&#x27;);const Diff = require(&#x27;diff&#x27;);const one = &#x27;beep boop&#x27;;const other = &#x27;beep boob blah&#x27;;const diff = Diff.diffChars(one, other);diff.forEach((part) =&gt; &#123; // green for additions, red for deletions // grey for common parts const color = part.added ? &#x27;green&#x27; : part.removed ? &#x27;red&#x27; : &#x27;grey&#x27;; process.stderr.write(part.value[color]);&#125;);console.log(); Running the above program should yield Basic example in a web page 123456789101112131415161718192021222324&lt;pre id=&quot;display&quot;&gt;&lt;/pre&gt;&lt;script src=&quot;diff.js&quot;&gt;&lt;/script&gt;&lt;script&gt;const one = &#x27;beep boop&#x27;, other = &#x27;beep boob blah&#x27;, color = &#x27;&#x27;; let span = null;const diff = Diff.diffChars(one, other), display = document.getElementById(&#x27;display&#x27;), fragment = document.createDocumentFragment();diff.forEach((part) =&gt; &#123; // green for additions, red for deletions // grey for common parts const color = part.added ? &#x27;green&#x27; : part.removed ? &#x27;red&#x27; : &#x27;grey&#x27;; span = document.createElement(&#x27;span&#x27;); span.style.color = color; span.appendChild(document .createTextNode(part.value)); fragment.appendChild(span);&#125;);display.appendChild(fragment);&lt;/script&gt; Open the above .html file in a browser and you should see Full online demo Compatibility jsdiff supports all ES3 environments with some known issues on IE8 and below. Under these browsers some diff algorithms such as word diff and others may fail due to lack of support for capturing groups in the split operation. LicenseSee LICENSE.","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"https://wisiw.github.io.git/tags/npm/"},{"name":"node","slug":"node","permalink":"https://wisiw.github.io.git/tags/node/"},{"name":"使用教程","slug":"使用教程","permalink":"https://wisiw.github.io.git/tags/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"}]},{"title":"【npm】hash-sum","slug":"【npm】hash-sum","date":"2021-10-26T07:20:18.000Z","updated":"2022-10-26T07:32:49.122Z","comments":true,"path":"2021/10/26/【npm】hash-sum/","link":"","permalink":"https://wisiw.github.io.git/2021/10/26/%E3%80%90npm%E3%80%91hash-sum/","excerpt":"","text":"hash-sum hash-sum blazing fast unique hash generator install1npm i hash-sum -S features no dependencies minimal footprint works in all of node.js, io.js, and the browser hashes functions based on their source code produces different hashes for different object types support for circular references in objects ignores property assignment order sum(value)yields a four-byte hexadecimal hash based off of value. 1234567891011121314151617181920212223242526272829303132333435363738394041424344# creates unique hashes00a34759 from: [ 0, 1, 2, 3 ]a8996f0c from: &#123; &#x27;0&#x27;: 0, &#x27;1&#x27;: 1, &#x27;2&#x27;: 2, &#x27;3&#x27;: 3 &#125;5b4c2116 from: &#123; &#x27;0&#x27;: 0, &#x27;1&#x27;: 1, &#x27;2&#x27;: 2, &#x27;3&#x27;: 3, length: 4 &#125;2c937c45 from: &#123; url: 12 &#125;31d55010 from: &#123; headers: 12 &#125;2d2e11bc from: &#123; headers: 122 &#125;ec99d958 from: &#123; headers: &#x27;122&#x27; &#125;18c00eee from: &#123; headers: &#123; accept: &#x27;text/plain&#x27; &#125; &#125;6cb332c8 from: &#123; payload: [ 0, 1, 2, 3 ], headers: [ &#123; a: &#x27;b&#x27; &#125; ] &#125;12ff55db from: &#123; a: [Function: a] &#125;46f806d2 from: &#123; b: [Function: b] &#125;0660d9c4 from: &#123; b: [Function: b] &#125;6c95fc65 from: function () &#123;&#125;2941766e from: function (a) &#123;&#125;294f8def from: function (b) &#123;&#125;2d9c0cb8 from: function (a) &#123; return a;&#125;ed5c63fc from: function (a) &#123;return a;&#125;bba68bf6 from: &#x27;&#x27;2d27667d from: &#x27;null&#x27;774b96ed from: &#x27;false&#x27;2d2a1684 from: &#x27;true&#x27;8daa1a0c from: &#x27;0&#x27;8daa1a0a from: &#x27;1&#x27;e38f07cc from: &#x27;void 0&#x27;6037ea1a from: &#x27;undefined&#x27;9b7df12e from: null3c206f76 from: false01e34ba8 from: true8a8f9624 from: Infinity0315bf8f from: -Infinity64a48b16 from: NaN1a96284a from: 01a96284b from: 129172c1a from: undefined59322f29 from: &#123;&#125;095b3a22 from: &#123; a: &#123;&#125;, b: &#123;&#125; &#125;63be56dd from: &#123; valueOf: [Function: valueOf] &#125;63be4f5c from: &#123; valueOf: [Function: valueOf] &#125;5d844489 from: []ba0bfa14 from: 2019-06-28T21:24:31.215Z49324d16 from: 2019-06-28T03:00:00.000Z434c9188 from: 1988-06-09T03:00:00.000Zce1b5e44 from: global licenseMIT","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"https://wisiw.github.io.git/tags/npm/"},{"name":"node","slug":"node","permalink":"https://wisiw.github.io.git/tags/node/"},{"name":"使用教程","slug":"使用教程","permalink":"https://wisiw.github.io.git/tags/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"}]},{"title":"【npm】sharp（images format）","slug":"【npm】sharp（images-format）","date":"2021-10-26T07:18:33.000Z","updated":"2022-10-26T07:20:26.279Z","comments":true,"path":"2021/10/26/【npm】sharp（images-format）/","link":"","permalink":"https://wisiw.github.io.git/2021/10/26/%E3%80%90npm%E3%80%91sharp%EF%BC%88images-format%EF%BC%89/","excerpt":"","text":"sharp sharp The typical use case for this high speed Node.js moduleis to convert large images in common formats tosmaller, web-friendly JPEG, PNG, WebP, GIF and AVIF images of varying dimensions. Resizing an image is typically 4x-5x faster than using thequickest ImageMagick and GraphicsMagick settingsdue to its use of libvips. Colour spaces, embedded ICC profiles and alpha transparency channels are all handled correctly.Lanczos resampling ensures quality is not sacrificed for speed. As well as image resizing, operations such asrotation, extraction, compositing and gamma correction are available. Most modern macOS, Windows and Linux systems running Node.js &gt;= 14.15.0do not require any additional install or runtime dependencies. DocumentationVisit sharp.pixelplumbing.com for completeinstallation instructions,API documentation,benchmark tests andchangelog. Examples1npm install sharp 1const sharp = require(&#x27;sharp&#x27;); Callback123sharp(inputBuffer) .resize(320, 240) .toFile(&#x27;output.webp&#x27;, (err, info) =&gt; &#123; ... &#125;); Promise1234567sharp(&#x27;input.jpg&#x27;) .rotate() .resize(200) .jpeg(&#123; mozjpeg: true &#125;) .toBuffer() .then( data =&gt; &#123; ... &#125;) .catch( err =&gt; &#123; ... &#125;); Async/await12345678910const semiTransparentRedPng = await sharp(&#123; create: &#123; width: 48, height: 48, channels: 4, background: &#123; r: 255, g: 0, b: 0, alpha: 0.5 &#125; &#125;&#125;) .png() .toBuffer(); Stream1234567891011121314const roundedCorners = Buffer.from( &#x27;&lt;svg&gt;&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;200&quot; height=&quot;200&quot; rx=&quot;50&quot; ry=&quot;50&quot;/&gt;&lt;/svg&gt;&#x27;);const roundedCornerResizer = sharp() .resize(200, 200) .composite([&#123; input: roundedCorners, blend: &#x27;dest-in&#x27; &#125;]) .png();readableStream .pipe(roundedCornerResizer) .pipe(writableStream); ContributingA guide for contributorscovers reporting bugs, requesting features and submitting code changes. LicensingCopyright 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022 Lovell Fuller and contributors. Licensed under the Apache License, Version 2.0 (the “License”);you may not use this file except in compliance with the License.You may obtain a copy of the License athttps://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an “AS IS” BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License.","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"https://wisiw.github.io.git/tags/npm/"},{"name":"node","slug":"node","permalink":"https://wisiw.github.io.git/tags/node/"},{"name":"使用教程","slug":"使用教程","permalink":"https://wisiw.github.io.git/tags/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"}]},{"title":"【npm】images（Node.js轻量级跨平台图像编解码库）","slug":"【npm】images（Node.js轻量级跨平台图像编解码库）","date":"2021-10-26T06:47:47.000Z","updated":"2022-10-26T06:49:23.377Z","comments":true,"path":"2021/10/26/【npm】images（Node.js轻量级跨平台图像编解码库）/","link":"","permalink":"https://wisiw.github.io.git/2021/10/26/%E3%80%90npm%E3%80%91images%EF%BC%88Node.js%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%9B%BE%E5%83%8F%E7%BC%96%E8%A7%A3%E7%A0%81%E5%BA%93%EF%BC%89/","excerpt":"","text":"images Cross-platform image decoder(png/jpeg/gif) and encoder(png/jpeg) for Node.jsNode.js轻量级跨平台图像编解码库 12345678910var images = require(&quot;images&quot;);images(&quot;input.jpg&quot;) //Load image from file //加载图像文件 .size(400) //Geometric scaling the image to 400 pixels width //等比缩放图像到400像素宽 .draw(images(&quot;logo.png&quot;), 10, 10) //Drawn logo at coordinates (10,10) //在(10,10)处绘制Logo .save(&quot;output.jpg&quot;, &#123; //Save the image to a file, with the quality of 50 quality : 50 //保存图片到文件,图片质量为50 &#125;); Support 支持情况if node &gt;= 10.x, please install images@latest Platform Architecture Node Version Windows x64 8, 9, 10, 11, 12 OSX X64 8, 9, 10, 11, 12 Linux* x64 8, 9, 10, 11, 12 The 32-bit system is not supported for the time being. if node &lt;= 9.x, please install &#x69;&#109;&#x61;&#103;&#x65;&#115;&#64;&#51;&#46;&#x31;&#x2e;&#49; Platform Architecture Node Version Windows x86 &amp; x64 0.9.11, 0.10, 0.12, 1, 2, 3, 4, 5, 6, 8, 10 OSX X64 0.9.11, 0.10, 0.12, 1, 2, 3, 4, 5, 6, 8, 9, 10 Linux* x86 &amp; x64 0.9.11, 0.10, 0.12, 1, 2, 3, 4, 5, 6, 8, 10 Features 功能特性 Lightweight: no need to install any image processing library. 轻量级：无需安装任何图像处理库。 Cross-platform: Released a compiled .node file on windows, just download and start. 跨平台：Windows下发布了编译好的.node文件,下载就能用。 Easy-to-use: Provide jQuery-like chaining API. Simple and reliable! 方便用：jQuery风格的API，简单可依赖。 Installation 安装$ npm install images API 接口node-images provide jQuery-like Chaining API,You can start the chain like this:node-images 提供了类似jQuery的链式调用API,您可以这样开始: 123456789101112/* Load and decode image from file *//* 从指定文件加载并解码图像 */images(file)/* Create a new transparent image *//* 创建一个指定宽高的透明图像 */images(width, height)/* Load and decode image from a buffer *//* 从Buffer数据中解码图像 */images(buffer[, start[, end]])/* Copy from another image *//* 从另一个图像中复制区域来创建图像 */images(image[, x, y, width, height]) images(file)Load and decode image from file从指定文件加载并解码图像 images(width, height)Create a new transparent image创建一个指定宽高的透明图像 images(buffer[, start[, end]])Load and decode image from a buffer从Buffer数据中解码图像 images(image[, x, y, width, height])Copy from another image从另一个图像中复制区域来创建图像 .fill(red, green, blue[, alpha])eg:images(200, 100).fill(0xff, 0x00, 0x00, 0.5)Fill image with color以指定颜色填充图像 .draw(image, x, y)Draw image on the current image position( x , y )在当前图像( x , y )上绘制 image 图像 .encode(type[, config])eg:images(&quot;input.png&quot;).encode(&quot;jpg&quot;, &#123;operation:50&#125;)Encode image to buffer, config is image setting.以指定格式编码当前图像到Buffer，config为图片设置，目前支持设置JPG图像质量Return buffer返回填充好的BufferNote:The operation will cut off the chain注意:该操作将会切断调用链See:.save(file[, type[, config]])参考:.save(file[, type[, config]]) .save(file[, type[, config]])eg:images(&quot;input.png&quot;).encode(&quot;output.jpg&quot;, &#123;operation:50&#125;)Encoding and save the current image to a file, if the type is not specified, type well be automatically determined according to the file, config is image setting. eg: &#123; operation:50 &#125;编码并保存当前图像到 file ,如果type未指定,则根据 file 自动判断文件类型，config为图片设置，目前支持设置JPG图像质量 .size([width[, height]])Get size of the image or set the size of the image,if the height is not specified, then scaling based on the current width and height获取或者设置图像宽高，如果height未指定，则根据当前宽高等比缩放 .resize(width[, height])Set the size of the image,if the height is not specified, then scaling based on the current width and height设置图像宽高，如果height未指定，则根据当前宽高等比缩放, 默认采用 bicubic 算法。 .width([width])Get width for the image or set width of the image获取或设置图像宽度 .height([height])Get height for the image or set height of the image获取或设置图像高度 images.setLimit(width, height)Set the limit size of each image设置库处理图片的大小限制,设置后对所有新的操作生效(如果超限则抛出异常) images.setGCThreshold(value)Set the garbage collection threshold设置图像处理库自动gc的阈值(当新增内存使用超过该阈值时，执行垃圾回收) images.getUsedMemory()Get used memory (in bytes)得到图像处理库占用的内存大小(单位为字节) images.gc()Forced garbage collection强制调用V8的垃圾回收机制","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"https://wisiw.github.io.git/tags/npm/"},{"name":"node","slug":"node","permalink":"https://wisiw.github.io.git/tags/node/"},{"name":"使用教程","slug":"使用教程","permalink":"https://wisiw.github.io.git/tags/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"}]},{"title":"【npm】inquirer命令行工具","slug":"【npm】inquirer命令行工具","date":"2021-10-26T06:33:53.000Z","updated":"2022-10-26T06:43:27.424Z","comments":true,"path":"2021/10/26/【npm】inquirer命令行工具/","link":"","permalink":"https://wisiw.github.io.git/2021/10/26/%E3%80%90npm%E3%80%91inquirer%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/","excerpt":"","text":"inquirer Inquirer.js A collection of common interactive command line user interfaces. Table of Contents Documentation Installation Examples Methods Objects Questions Answers Separator Prompt Types User Interfaces and Layouts Reactive Interface Support Known issues News Contributing License Plugins Goal and PhilosophyInquirer.js strives to be an easily embeddable and beautiful command line interface for Node.js (and perhaps the “CLI Xanadu“). Inquirer.js should ease the process of providing error feedback asking questions parsing input validating answers managing hierarchical prompts Note: Inquirer.js provides the user interface and the inquiry session flow. If you’re searching for a full blown command line program utility, then check out commander, vorpal or args. Documentation Installation 1npm install --save inquirer 123456789101112131415import inquirer from &#x27;inquirer&#x27;;inquirer .prompt([ /* Pass your questions in here */ ]) .then((answers) =&gt; &#123; // Use user feedback for... whatever!! &#125;) .catch((error) =&gt; &#123; if (error.isTtyError) &#123; // Prompt couldn&#x27;t be rendered in the current environment &#125; else &#123; // Something else went wrong &#125; &#125;); Inquirer v9 and higher are native esm modules, this mean you cannot use the commonjs syntax require(&#39;inquirer&#39;) anymore. If you want to learn more about using native esm in Node, I’d recommend reading the following guide. Alternatively, you can rely on an older version until you’re ready to upgrade your environment: 1npm install --save inquirer@^8.0.0 This will then allow import inquirer with the commonjs require: 1const inquirer = require(&#x27;inquirer&#x27;); Examples (Run it and see it)Check out the packages/inquirer/examples/ folder for code and interface examples. 123node packages/inquirer/examples/pizza.jsnode packages/inquirer/examples/checkbox.js# etc... Methods inquirer.prompt(questions, answers) -&gt; promiseLaunch the prompt interface (inquiry session) questions (Array) containing Question Object (using the reactive interface, you can also pass a Rx.Observable instance) answers (object) contains values of already answered questions. Inquirer will avoid asking answers already provided here. Defaults &#123;&#125;. returns a Promise inquirer.registerPrompt(name, prompt)Register prompt plugins under name. name (string) name of the this new prompt. (used for question type) prompt (object) the prompt object itself (the plugin) inquirer.createPromptModule() -&gt; prompt functionCreate a self contained inquirer module. If you don’t want to affect other libraries that also rely on inquirer when you overwrite or add new prompt types. 12const prompt = inquirer.createPromptModule();prompt(questions).then(/* ... */); Objects QuestionA question object is a hash containing question related values: type: (String) Type of the prompt. Defaults: input - Possible values: input, number, confirm, list, rawlist, expand, checkbox, password, editor name: (String) The name to use when storing the answer in the answers hash. If the name contains periods, it will define a path in the answers hash. message: (String|Function) The question to print. If defined as a function, the first parameter will be the current inquirer session answers. Defaults to the value of name (followed by a colon). default: (String|Number|Boolean|Array|Function) Default value(s) to use if nothing is entered, or a function that returns the default value(s). If defined as a function, the first parameter will be the current inquirer session answers. choices: (Array|Function) Choices array or a function returning a choices array. If defined as a function, the first parameter will be the current inquirer session answers.Array values can be simple numbers, strings, or objects containing a name (to display in list), a value (to save in the answers hash), and a short (to display after selection) properties. The choices array can also contain a Separator. validate: (Function) Receive the user input and answers hash. Should return true if the value is valid, and an error message (String) otherwise. If false is returned, a default error message is provided. filter: (Function) Receive the user input and answers hash. Returns the filtered value to be used inside the program. The value returned will be added to the Answers hash. transformer: (Function) Receive the user input, answers hash and option flags, and return a transformed value to display to the user. The transformation only impacts what is shown while editing. It does not modify the answers hash. when: (Function, Boolean) Receive the current user answers hash and should return true or false depending on whether or not this question should be asked. The value can also be a simple boolean. pageSize: (Number) Change the number of lines that will be rendered when using list, rawList, expand or checkbox. prefix: (String) Change the default prefix message. suffix: (String) Change the default suffix message. askAnswered: (Boolean) Force to prompt the question if the answer already exists. loop: (Boolean) Enable list looping. Defaults: true waitUserInput: (Boolean) Flag to enable/disable wait for user input before opening system editor - Defaults: true default, choices(if defined as functions), validate, filter and when functions can be called asynchronously. Either return a promise or use this.async() to get a callback you’ll call with the final value. 123456789101112131415161718192021&#123; /* Preferred way: with promise */ filter() &#123; return new Promise(/* etc... */); &#125;, /* Legacy way: with this.async */ validate: function (input) &#123; // Declare function as asynchronous, and save the done callback const done = this.async(); // Do async stuff setTimeout(function() &#123; if (typeof input !== &#x27;number&#x27;) &#123; // Pass the return value in the done callback done(&#x27;You need to provide a number&#x27;); return; &#125; // Pass the return value in the done callback done(null, true); &#125;, 3000); &#125;&#125; AnswersA key/value hash containing the client answers in each prompt. Key The name property of the question object Value (Depends on the prompt) confirm: (Boolean) input : User input (filtered if filter is defined) (String) number: User input (filtered if filter is defined) (Number) rawlist, list : Selected choice value (or name if no value specified) (String) SeparatorA separator can be added to any choices array: 123456789// In the question objectchoices: [ &quot;Choice A&quot;, new inquirer.Separator(), &quot;choice B&quot; ]// Which&#x27;ll be displayed this way[?] What do you want to do? &gt; Order a pizza Make a reservation -------- Ask opening hours Talk to the receptionist The constructor takes a facultative String value that’ll be use as the separator. If omitted, the separator will be --------. Separator instances have a property type equal to separator. This should allow tools façading Inquirer interface from detecting separator types in lists. Prompt types Note:: allowed options written inside square brackets ([]) are optional. Others are required. List - &#123;type: &#39;list&#39;&#125;Take type, name, message, choices[, default, filter, loop] properties.(Note: default must be set to the index or value of one of the entries in choices) Raw List - &#123;type: &#39;rawlist&#39;&#125;Take type, name, message, choices[, default, filter, loop] properties.(Note: default must be set to the index of one of the entries in choices) Expand - &#123;type: &#39;expand&#39;&#125;Take type, name, message, choices[, default] properties.Note: default must be the index of the desired default selection of the array. If default key not provided, then help will be used as default choice Note that the choices object will take an extra parameter called key for the expand prompt. This parameter must be a single (lowercased) character. The h option is added by the prompt and shouldn’t be defined by the user. See examples/expand.js for a running example. Checkbox - &#123;type: &#39;checkbox&#39;&#125;Take type, name, message, choices[, filter, validate, default, loop] properties. default is expected to be an Array of the checked choices value. Choices marked as &#123;checked: true&#125; will be checked by default. Choices whose property disabled is truthy will be unselectable. If disabled is a string, then the string will be outputted next to the disabled choice, otherwise it’ll default to &quot;Disabled&quot;. The disabled property can also be a synchronous function receiving the current answers as argument and returning a boolean or a string. Confirm - &#123;type: &#39;confirm&#39;&#125;Take type, name, message, [default] properties. default is expected to be a boolean if used. Input - &#123;type: &#39;input&#39;&#125;Take type, name, message[, default, filter, validate, transformer] properties. Input - &#123;type: &#39;number&#39;&#125;Take type, name, message[, default, filter, validate, transformer] properties. Password - &#123;type: &#39;password&#39;&#125;Take type, name, message, mask,[, default, filter, validate] properties. Note that mask is required to hide the actual user input. Editor - &#123;type: &#39;editor&#39;&#125;Take type, name, message[, default, filter, validate, postfix, waitUserInput] properties Launches an instance of the users preferred editor on a temporary file. Once the user exits their editor, the contents of the temporary file are read in as the result. The editor to use is determined by reading the $VISUAL or $EDITOR environment variables. If neither of those are present, notepad (on Windows) or vim (Linux or Mac) is used. The postfix property is useful if you want to provide an extension. Use in Non-Interactive Environmentsprompt() requires that it is run in an interactive environment. (I.e. One where process.stdin.isTTY is true). If prompt() is invoked outside of such an environment, then prompt() will return a rejected promise with an error. For convenience, the error will have a isTtyError property to programmatically indicate the cause. User Interfaces and layoutsAlong with the prompts, Inquirer offers some basic text UI. Bottom Bar - inquirer.ui.BottomBarThis UI present a fixed text at the bottom of a free text zone. This is useful to keep a message to the bottom of the screen while outputting command outputs on the higher section. 123456789const ui = new inquirer.ui.BottomBar();// pipe a Stream to the log zoneoutputStream.pipe(ui.log);// Or simply write outputui.log.write(&#x27;something just happened.&#x27;);ui.log.write(&#x27;Almost over, standby!&#x27;);// During processing, update the bottom bar content to display a loader// or output a progress bar, etcui.updateBottomBar(&#x27;new bottom bar content&#x27;); Reactive interfaceInternally, Inquirer uses the JS reactive extension to handle events and async flows. This mean you can take advantage of this feature to provide more advanced flows. For example, you can dynamically add questions to be asked: 1234567891011const prompts = new Rx.Subject();inquirer.prompt(prompts);// At some point in the future, push new questionsprompts.next(&#123; /* question... */&#125;);prompts.next(&#123; /* question... */&#125;);// When you&#x27;re doneprompts.complete(); And using the return value process property, you can access more fine grained callbacks: 1inquirer.prompt(prompts).ui.process.subscribe(onEachAnswer, onError, onComplete); Support (OS Terminals) You should expect mostly good support for the CLI below. This does not mean we won’tlook at issues found on other command line - feel free to report any! Mac OS: Terminal.app iTerm Windows (Known issues): Windows Terminal ConEmu cmd.exe Powershell Cygwin Linux (Ubuntu, openSUSE, Arch Linux, etc): gnome-terminal (Terminal GNOME) konsole Known issues Running Inquirer together with network streams in Windows platform inside some terminals can result in process hang.Workaround: run inside another terminal.Please refer to the https://github.com/nodejs/node/issues/21771 Calling a node script that uses Inquirer from grunt-exec can cause the program to crash. To fix this, add to your grunt-exec config stdio: &#39;inherit&#39;.Please refer to https://github.com/jharding/grunt-exec/issues/85 News on the march (Release notes) Please refer to the GitHub releases section for the changelog Contributing Unit testUnit test are written in Mocha. Please add a unit test for every new feature or bug fix. npm test to run the test suite. DocumentationAdd documentation for every API change. Feel free to send typo fixes and better docs! We’re looking to offer good support for multiple prompts and environments. If you want tohelp, we’d like to keep a list of testers for each terminal/OS so we can contact you andget feedback before release. Let us know if you want to be added to the list (just tweetto @vaxilart) or just add your name to the wiki License Copyright (c) 2022 Simon Boudrias (twitter: @vaxilart)Licensed under the MIT license. Plugins PromptsautocompletePresents a list of options as the user types, compatible with other packages such as fuzzy (for search) checkbox-plusCheckbox list with autocomplete and other additions inquirer-date-promptCustomizable date/time selector with localization support datetimeCustomizable date/time selector using both number pad and arrow keys inquirer-select-linePrompt for selecting index in array where add new element commandSimple prompt with command history and dynamic autocomplete inquirer-fuzzy-pathPrompt for fuzzy file/directory selection. inquirer-emojiPrompt for inputting emojis. inquirer-chalk-pipePrompt for input chalk-pipe style strings inquirer-search-checkboxSearchable Inquirer checkbox inquirer-search-listSearchable Inquirer list inquirer-prompt-suggestInquirer prompt for your less creative users. inquirer-s3An S3 object selector for Inquirer. inquirer-autosubmit-promptAuto submit based on your current input, saving one extra enter inquirer-file-tree-selection-promptInquirer prompt for to select a file or directory in file tree inquirer-tree-promptInquirer prompt to select from a tree inquirer-table-promptA table-like prompt for Inquirer. inquirer-interrupted-promptTurning any existing inquirer and its plugin prompts into prompts that can be interrupted with a custom key. inquirer-press-to-continueA “press any key to continue” prompt for Inquirer.js","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"https://wisiw.github.io.git/tags/npm/"},{"name":"node","slug":"node","permalink":"https://wisiw.github.io.git/tags/node/"},{"name":"使用教程","slug":"使用教程","permalink":"https://wisiw.github.io.git/tags/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"}]},{"title":"【算法】数据压缩","slug":"【算法】数据压缩","date":"2021-10-21T05:39:04.000Z","updated":"2021-11-18T05:50:56.774Z","comments":true,"path":"2021/10/21/【算法】数据压缩/","link":"","permalink":"https://wisiw.github.io.git/2021/10/21/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/","excerpt":"","text":"还在学~","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://wisiw.github.io.git/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据压缩","slug":"数据压缩","permalink":"https://wisiw.github.io.git/tags/%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/"}]},{"title":"【算法】二叉树","slug":"【算法】二叉树","date":"2021-10-21T05:38:46.000Z","updated":"2022-06-17T06:57:06.008Z","comments":true,"path":"2021/10/21/【算法】二叉树/","link":"","permalink":"https://wisiw.github.io.git/2021/10/21/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"树 树 由称作根（root）的节点r以及0个或者多个非空的（子）树T1，T2，…，Tk组成，这些子树中每一颗的根都来自根的一条有向的边（edge）所连结","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://wisiw.github.io.git/tags/%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","permalink":"https://wisiw.github.io.git/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【算法】哈希表","slug":"【算法】哈希表","date":"2021-10-21T05:38:40.000Z","updated":"2021-11-18T05:51:47.706Z","comments":true,"path":"2021/10/21/【算法】哈希表/","link":"","permalink":"https://wisiw.github.io.git/2021/10/21/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%93%88%E5%B8%8C%E8%A1%A8/","excerpt":"","text":"还在学~","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://wisiw.github.io.git/tags/%E7%AE%97%E6%B3%95/"},{"name":"哈希表","slug":"哈希表","permalink":"https://wisiw.github.io.git/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"【算法】斐波那契查找","slug":"【算法】斐波那契查找","date":"2021-10-21T05:38:24.000Z","updated":"2021-11-18T05:51:38.584Z","comments":true,"path":"2021/10/21/【算法】斐波那契查找/","link":"","permalink":"https://wisiw.github.io.git/2021/10/21/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE/","excerpt":"","text":"还在学~","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://wisiw.github.io.git/tags/%E7%AE%97%E6%B3%95/"},{"name":"斐波那契查找","slug":"斐波那契查找","permalink":"https://wisiw.github.io.git/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE/"}]},{"title":"【算法】插值查找","slug":"【算法】插值查找","date":"2021-10-21T05:38:05.000Z","updated":"2021-11-18T05:51:18.467Z","comments":true,"path":"2021/10/21/【算法】插值查找/","link":"","permalink":"https://wisiw.github.io.git/2021/10/21/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE/","excerpt":"","text":"还在学~","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://wisiw.github.io.git/tags/%E7%AE%97%E6%B3%95/"},{"name":"插值查找","slug":"插值查找","permalink":"https://wisiw.github.io.git/tags/%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE/"}]},{"title":"【算法】二分查找","slug":"【算法】二分查找","date":"2021-10-21T05:37:50.000Z","updated":"2021-11-18T05:49:58.959Z","comments":true,"path":"2021/10/21/【算法】二分查找/","link":"","permalink":"https://wisiw.github.io.git/2021/10/21/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","excerpt":"","text":"还在学~","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://wisiw.github.io.git/tags/%E7%AE%97%E6%B3%95/"},{"name":"二分查找","slug":"二分查找","permalink":"https://wisiw.github.io.git/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"【算法】时间复杂度计算","slug":"【算法】时间复杂度计算","date":"2021-10-21T05:37:20.000Z","updated":"2021-11-18T05:51:00.246Z","comments":true,"path":"2021/10/21/【算法】时间复杂度计算/","link":"","permalink":"https://wisiw.github.io.git/2021/10/21/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97/","excerpt":"","text":"还在学~","categories":[],"tags":[{"name":"算法 -时间复杂度计算","slug":"算法-时间复杂度计算","permalink":"https://wisiw.github.io.git/tags/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97/"}]},{"title":"【算法】排序算法","slug":"【算法】排序算法","date":"2021-10-21T05:36:56.000Z","updated":"2022-03-16T09:51:08.185Z","comments":true,"path":"2021/10/21/【算法】排序算法/","link":"","permalink":"https://wisiw.github.io.git/2021/10/21/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"还在学~","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://wisiw.github.io.git/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://wisiw.github.io.git/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"【算法】八皇后问题","slug":"【算法】八皇后问题","date":"2021-10-21T05:36:46.000Z","updated":"2021-11-18T05:51:15.230Z","comments":true,"path":"2021/10/21/【算法】八皇后问题/","link":"","permalink":"https://wisiw.github.io.git/2021/10/21/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/","excerpt":"","text":"还在学~","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://wisiw.github.io.git/tags/%E7%AE%97%E6%B3%95/"},{"name":"八皇后问题","slug":"八皇后问题","permalink":"https://wisiw.github.io.git/tags/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"}]},{"title":"【算法】迷宫回溯","slug":"【算法】迷宫回溯","date":"2021-10-21T05:36:38.000Z","updated":"2021-11-18T05:51:54.452Z","comments":true,"path":"2021/10/21/【算法】迷宫回溯/","link":"","permalink":"https://wisiw.github.io.git/2021/10/21/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E8%BF%B7%E5%AE%AB%E5%9B%9E%E6%BA%AF/","excerpt":"","text":"还在学~","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://wisiw.github.io.git/tags/%E7%AE%97%E6%B3%95/"},{"name":"迷宫回溯","slug":"迷宫回溯","permalink":"https://wisiw.github.io.git/tags/%E8%BF%B7%E5%AE%AB%E5%9B%9E%E6%BA%AF/"}]},{"title":"【算法】逆波兰式计算器","slug":"【算法】逆波兰式计算器","date":"2021-10-21T05:36:13.000Z","updated":"2021-11-18T05:51:57.145Z","comments":true,"path":"2021/10/21/【算法】逆波兰式计算器/","link":"","permalink":"https://wisiw.github.io.git/2021/10/21/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F%E8%AE%A1%E7%AE%97%E5%99%A8/","excerpt":"","text":"还在学~","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://wisiw.github.io.git/tags/%E7%AE%97%E6%B3%95/"},{"name":"逆波兰式","slug":"逆波兰式","permalink":"https://wisiw.github.io.git/tags/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/"}]},{"title":"【算法】前缀、中缀、后缀表达式","slug":"【算法】前缀、中缀、后缀表达式","date":"2021-10-21T05:35:55.000Z","updated":"2021-11-18T05:52:07.151Z","comments":true,"path":"2021/10/21/【算法】前缀、中缀、后缀表达式/","link":"","permalink":"https://wisiw.github.io.git/2021/10/21/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%89%8D%E7%BC%80%E3%80%81%E4%B8%AD%E7%BC%80%E3%80%81%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"还在学~","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://wisiw.github.io.git/tags/%E7%AE%97%E6%B3%95/"},{"name":"前缀、中缀、后缀表达式","slug":"前缀、中缀、后缀表达式","permalink":"https://wisiw.github.io.git/tags/%E5%89%8D%E7%BC%80%E3%80%81%E4%B8%AD%E7%BC%80%E3%80%81%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"【算法】栈","slug":"【算法】栈","date":"2021-10-21T05:35:24.000Z","updated":"2022-05-25T09:05:08.697Z","comments":true,"path":"2021/10/21/【算法】栈/","link":"","permalink":"https://wisiw.github.io.git/2021/10/21/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%A0%88/","excerpt":"","text":"实际应用平衡符号应用：编译器语法检查 12&quot;[&#123;()&#125;]&quot; =&gt; true&quot;[&#123;(&#125;]&quot; =&gt; false 12345678910111213141516171819202122232425function check(str) &#123; console.log(str) const obj = &#123; &quot;[&quot;: &quot;]&quot;, &quot;&lt;&quot;: &quot;&gt;&quot;, &quot;&#123;&quot;: &quot;&#125;&quot;, &#125;; const zhan = []; for (let i = 0; i &lt; str.length; i++) &#123; const s = str[i] if ([&quot;&lt;&quot;, &quot;[&quot;, &quot;&#123;&quot;].includes(s)) &#123; zhan.push(s); &#125; if ([&quot;&gt;&quot;, &quot;]&quot;, &quot;&#125;&quot;].includes(s)) &#123; if (zhan.length === 0) &#123; return false &#125; const pop = zhan.pop(); if (s !== obj[pop]) &#123; return false &#125; &#125; &#125; return zhan.length === 0 || true&#125; test 12345678check(&#x27;&#125;&#x27;) // ==&gt; falsecheck(&#x27;&#123;&#x27;) // ==&gt; falsecheck(&#x27;&#123;&#125;&#x27;) // ==&gt; truecheck(&#x27;&#123;&lt;&#125;&#x27;) // ==&gt; falsecheck(&#x27;&#123;&lt;&gt;&#125;&#x27;) // ==&gt; truecheck(&#x27;&#123;&lt;[&gt;&#125;&#x27;) // ==&gt; falsecheck(&#x27;&#123;&lt;[]&gt;&#125;&#x27;) // ==&gt; truecheck(&#x27;&#123;&lt;[&gt;]&#125;&#x27;) // ==&gt; false","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://wisiw.github.io.git/tags/%E7%AE%97%E6%B3%95/"},{"name":"栈","slug":"栈","permalink":"https://wisiw.github.io.git/tags/%E6%A0%88/"}]},{"title":"【算法】约瑟夫问题","slug":"【算法】约瑟夫问题","date":"2021-10-21T05:35:14.000Z","updated":"2021-11-18T05:51:05.227Z","comments":true,"path":"2021/10/21/【算法】约瑟夫问题/","link":"","permalink":"https://wisiw.github.io.git/2021/10/21/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/","excerpt":"","text":"还在学~","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://wisiw.github.io.git/tags/%E7%AE%97%E6%B3%95/"},{"name":"约瑟夫问题","slug":"约瑟夫问题","permalink":"https://wisiw.github.io.git/tags/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/"}]},{"title":"【算法】链表","slug":"【算法】链表","date":"2021-10-21T05:34:24.000Z","updated":"2022-03-24T02:18:55.920Z","comments":true,"path":"2021/10/21/【算法】链表/","link":"","permalink":"https://wisiw.github.io.git/2021/10/21/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E9%93%BE%E8%A1%A8/","excerpt":"","text":"链表：由一系列节点组成，这些节点在内存中不必在内存中相连，没哟个节点均包含表元素和到包含钙元素后继元的节点的链，被称之为next链，最后一个单元的next链引用null 链表主要是为了解决对表的一些插入和删除操作，特别是对表的前端进行的（使用数组实现表的插入和删除可能会造成昂贵的开销，特别是发生在表的前端，需要将整个数组移动） 经典链表：每个节点均存储到其下一节点的链，而拥有指向最后节点的链并不提供最后节点前驱节点的任何信息 [^前驱]:对于除空表外的任何表（表的长度为N），Ai后继Ai-1（或继Ai-1），Ai-1前驱Ai（i&gt;0） 经典链表删除最后一项比较复杂，因为必须要找出指向最后节点的项，把它的next链改成null，然后再更新持有最后节点的链，花费时间较久，双链表应运而生","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://wisiw.github.io.git/tags/%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"链表","permalink":"https://wisiw.github.io.git/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"【算法】队列","slug":"【算法】队列","date":"2021-10-21T05:34:14.000Z","updated":"2021-11-18T06:35:22.960Z","comments":true,"path":"2021/10/21/【算法】队列/","link":"","permalink":"https://wisiw.github.io.git/2021/10/21/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E9%98%9F%E5%88%97/","excerpt":"","text":"介绍是一个有序列表，可以用数组或者是链表来实现遵循先入先出的原则。即：先存入队列，要先取出。后存入的要后取出","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://wisiw.github.io.git/tags/%E7%AE%97%E6%B3%95/"},{"name":"队列","slug":"队列","permalink":"https://wisiw.github.io.git/tags/%E9%98%9F%E5%88%97/"}]},{"title":"【算法】稀疏数组","slug":"【算法】稀疏数组","date":"2021-10-20T02:48:06.000Z","updated":"2021-11-18T05:50:54.035Z","comments":true,"path":"2021/10/20/【算法】稀疏数组/","link":"","permalink":"https://wisiw.github.io.git/2021/10/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/","excerpt":"","text":"介绍使用场景棋盘存储 实现思路二维数组转稀疏数组1.遍历原始数组arr，得到有效数据的个数sum2.根据sum创建稀疏数组sparseArr int[sum+1][3]3.将二维数组的有效数据存入到稀疏数组 js版 12345678910111213141516function sparseArr (arr) &#123; const sparseArr = [[]] sparseArr[0][0] = arr.length sparseArr[0][1] = arr[1].length sparseArr[0][2] = 0 for (let i = 0; i &lt; arr.length; i++) &#123; for(let j = 0; j &lt; arr[i].length; j++) &#123; if(arr[i][j] !== 0) &#123; sparseArr[0][2]++ sparseArr.push([i, j, arr[i][j]]) &#125; &#125; &#125; return sparseArr&#125; Java版 1234567891011121314151617181920212223242526public static int[][] sparseArr(int[][] arr) &#123; int sum = 0; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr[i].length; j++) &#123; if (arr[i][j] != 0) &#123; sum++; &#125; &#125; &#125; int sparseArr[][] = new int[sum+1][3]; sparseArr[0][0] = arr.length; sparseArr[0][1] = arr[0].length; sparseArr[0][2] = sum; int count = 0; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr[i].length; j++) &#123; if (arr[i][j] != 0) &#123; count++; sparseArr[count][0] = i; sparseArr[count][1] = j; sparseArr[count][2] = arr[i][j]; &#125; &#125; &#125; return sparseArr;&#125; 稀疏数组转二维数据1.先读取稀疏数组的第一行，创建二维数组2.读取稀疏数组后几行数据，赋值给二维数组 js版 1234567function reductionArr(sparseArr) &#123; const arr = Array(sparseArr[0][0]).fill(0).map(x =&gt; Array(sparseArr[0][1]).fill(0)); for(let i = 1; i &lt; sparseArr.length; i++) &#123; arr[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2] &#125; return arr&#125; Java版 1234567public static int[][] reductionArr(int[][] sparseArr) &#123; int arr[][] = new int[sparseArr[0][0]][sparseArr[0][1]]; for (int i = 1; i &lt; sparseArr.length; i++) &#123; arr[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2]; &#125; return arr;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://wisiw.github.io.git/tags/%E7%AE%97%E6%B3%95/"},{"name":"稀疏数组","slug":"稀疏数组","permalink":"https://wisiw.github.io.git/tags/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/"}]},{"title":"【面试题】Vue-cli","slug":"【面试题】Vue-cli","date":"2021-10-18T03:46:44.000Z","updated":"2021-12-01T02:37:48.839Z","comments":true,"path":"2021/10/18/【面试题】Vue-cli/","link":"","permalink":"https://wisiw.github.io.git/2021/10/18/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%91Vue-cli/","excerpt":"","text":"assets与static的区别","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://wisiw.github.io.git/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"Vue-cli","slug":"Vue-cli","permalink":"https://wisiw.github.io.git/tags/Vue-cli/"}]},{"title":"【代码片段】Vue组件化技巧","slug":"【代码片段】Vue组件化技巧","date":"2021-10-18T02:44:30.000Z","updated":"2022-11-06T21:12:57.946Z","comments":true,"path":"2021/10/18/【代码片段】Vue组件化技巧/","link":"","permalink":"https://wisiw.github.io.git/2021/10/18/%E3%80%90%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E3%80%91Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E6%8A%80%E5%B7%A7/","excerpt":"","text":"使用插槽prop实现组件的事件封装子组件 12345678910Vue.component(&#x27;Child&#x27;, &#123; template: `&lt;div&gt; &lt;slot :handle=&#x27;handle&#x27;&gt;&lt;/slot&gt; &lt;/div&gt;`, methods: &#123; handle() &#123; console.log(1) &#125; &#125;&#125;) 父组件 1234567var parent = new Vue(&#123; name: &#x27;Parent&#x27;, el: &#x27;#app&#x27;, template: `&lt;child v-slot=&#x27;&#123; handle &#125;&#x27;&gt; &lt;div @click=&#x27;handle&#x27;&gt;子组件&lt;/div&gt; &lt;/child&gt;`&#125;) 完整代码12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/vue/2.6.9/vue.common.dev.js&quot;&gt;&lt;/script&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;Vue.component(&#x27;Child&#x27;, &#123; template: `&lt;div&gt; &lt;slot :handle=&#x27;handle&#x27;&gt;&lt;/slot&gt; &lt;/div&gt;`, methods: &#123; handle() &#123; console.log(1) &#125; &#125;&#125;)var parent = new Vue(&#123; name: &#x27;Parent&#x27;, el: &#x27;#app&#x27;, template: `&lt;child v-slot=&#x27;&#123; handle &#125;&#x27;&gt; &lt;div @click=&#x27;handle&#x27;&gt;子组件&lt;/div&gt; &lt;/child&gt;`&#125;)&lt;/script&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://wisiw.github.io.git/tags/Vue/"},{"name":"组件化","slug":"组件化","permalink":"https://wisiw.github.io.git/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"}]},{"title":"【代码片段】文件断点续传——上传（Java）","slug":"【代码片段】文件断点续传——上传（Java）","date":"2021-10-09T01:30:58.000Z","updated":"2021-10-18T02:43:50.990Z","comments":true,"path":"2021/10/09/【代码片段】文件断点续传——上传（Java）/","link":"","permalink":"https://wisiw.github.io.git/2021/10/09/%E3%80%90%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E3%80%91%E6%96%87%E4%BB%B6%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E2%80%94%E2%80%94%E4%B8%8A%E4%BC%A0%EF%BC%88Java%EF%BC%89/","excerpt":"","text":"java版依赖包 1234567891011121314151617181920212223242526272829303132&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt; &lt;version&gt;2.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpcore&lt;/artifactId&gt; &lt;version&gt;4.4.14&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.13&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; UploadController123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.fileupload.servlet.ServletFileUpload;import org.apache.commons.io.FileUtils;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.*;import java.util.List;@Controllerpublic class UploadController &#123; private final static String utf8 = &quot;utf-8&quot;; @RequestMapping(&quot;/upload&quot;) @ResponseBody public void upload(HttpServletRequest req, HttpServletResponse res) throws Exception &#123; res.setCharacterEncoding(utf8); Integer schunk = null; Integer schunks = null; String name = null; String uploadPath = &quot;F:\\\\fileItem&quot;; BufferedOutputStream os = null; try &#123; DiskFileItemFactory factory = new DiskFileItemFactory(); factory.setSizeThreshold(1024); factory.setRepository(new File(uploadPath)); ServletFileUpload upload = new ServletFileUpload(factory); upload.setFileSizeMax(51 * 10241 * 10241 * 10241); upload.setSizeMax(101 * 10241 * 10241 * 10241); List&lt;FileItem&gt; items = upload.parseRequest(req); for (FileItem item : items) &#123; if (item.isFormField()) &#123; if (&quot;chunk&quot;.equals(item.getFieldName())) &#123; schunk = Integer.parseInt(item.getString(utf8)); &#125; if (&quot;chunks&quot;.equals(item.getFieldName())) &#123; schunks = Integer.parseInt(item.getString(utf8)); &#125; if (&quot;name&quot;.equals(item.getFieldName())) &#123; name = item.getString(utf8); &#125; &#125; &#125; for (FileItem item : items) &#123; if (!item.isFormField()) &#123; String temFileName = name; if (name != null) &#123; if (schunk != null) &#123; temFileName = schunk + &quot;_&quot; + name; &#125; File temFile = new File(uploadPath, temFileName); // 断点续传 if (!temFile.exists()) &#123; item.write(temFile); &#125; &#125; &#125; &#125; // 文件合并 if (schunk != null &amp;&amp; schunk.intValue() == schunks.intValue()-1) &#123; File tempFile = new File(uploadPath, name); os = new BufferedOutputStream(new FileOutputStream(tempFile)); for (int i = 0; i &lt; schunks; i++) &#123; File file = new File(uploadPath, i + &quot;_&quot; + name); while (!file.exists()) &#123; Thread.sleep(100); &#125; byte[] bytes = FileUtils.readFileToByteArray(file); os.write(bytes); os.flush(); file.delete(); &#125; os.flush(); &#125; res.getWriter().write(&quot;上传成功&quot;); &#125;finally &#123; try &#123; if (os != null) &#123; os.close(); &#125; &#125;catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"代码片段","slug":"代码片段","permalink":"https://wisiw.github.io.git/tags/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"},{"name":"断点续传","slug":"断点续传","permalink":"https://wisiw.github.io.git/tags/%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0/"}]},{"title":"【解析器】Markdown解析","slug":"【解析器】Markdown解析","date":"2021-09-30T09:22:14.000Z","updated":"2021-09-30T09:46:09.788Z","comments":true,"path":"2021/09/30/【解析器】Markdown解析/","link":"","permalink":"https://wisiw.github.io.git/2021/09/30/%E3%80%90%E8%A7%A3%E6%9E%90%E5%99%A8%E3%80%91Markdown%E8%A7%A3%E6%9E%90/","excerpt":"","text":"解析基于https://github.com/evilstreak/markdown-js 暴露出去的方法为toHTML 12const mk = require(&#x27;markdown&#x27;).markdownmk.toHTML(&#x27;# 1.&#x27;) // &lt;h1&gt;1.&lt;/h1&gt;","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://wisiw.github.io.git/tags/Markdown/"}]},{"title":"【React】局部样式","slug":"【React】局部样式","date":"2021-09-30T02:11:07.000Z","updated":"2022-02-05T02:56:06.918Z","comments":true,"path":"2021/09/30/【React】局部样式/","link":"","permalink":"https://wisiw.github.io.git/2021/09/30/%E3%80%90React%E3%80%91%E5%B1%80%E9%83%A8%E6%A0%B7%E5%BC%8F/","excerpt":"","text":"","categories":[],"tags":[{"name":"局部样式","slug":"局部样式","permalink":"https://wisiw.github.io.git/tags/%E5%B1%80%E9%83%A8%E6%A0%B7%E5%BC%8F/"},{"name":"React","slug":"React","permalink":"https://wisiw.github.io.git/tags/React/"},{"name":"vue-loader","slug":"vue-loader","permalink":"https://wisiw.github.io.git/tags/vue-loader/"}]},{"title":"【VUE】局部样式的实现原理","slug":"【Vue】局部样式的实现原理","date":"2021-09-30T02:11:07.000Z","updated":"2023-09-13T01:30:00.688Z","comments":true,"path":"2021/09/30/【Vue】局部样式的实现原理/","link":"","permalink":"https://wisiw.github.io.git/2021/09/30/%E3%80%90Vue%E3%80%91%E5%B1%80%E9%83%A8%E6%A0%B7%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","excerpt":"","text":"使用方式通过在style标签上添加scoped标签实现样式局部化 1&lt;style scoped&gt;&lt;/style&gt; 原理vue-loader在解析.vue文件时，识别到style的scoped标签，会在生成的元素上绑定[data-v-*]标签并在css样式中添加[data-v-*] 比如： 12345678&lt;template&gt; &lt;div class=&quot;main&quot;&gt;111&lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .main &#123; color: red; &#125;&lt;/style&gt; 会被解析成 12345678910&lt;head&gt; &lt;style&gt; .main[data-v-6542a5cf] &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div data-v-6542a5cf class=&quot;main&quot;&gt;111&lt;/div&gt;&lt;/body&gt; 这时.main[data-v-6542a5cf]的样式只会对&lt;div data-v-6542a5cf class=&quot;main&quot;&gt;111&lt;/div&gt;起作用 主要起作用的就是[data-v-*]这个标签，这个其实是当前这个vue组件的根id，可以从vue-loader的源码中看到生成原理 https://github.com/vuejs/vue-loader/blob/3597f6d2b5dd6b4b47fbc30b8ff0902278444d1f/lib/utils/gen-id.jshttps://github.com/search?q=repo%3Avuejs%2Fvue-loader+genId&amp;type=issues 12345678910111213// utility for generating a uid for each component file// used in scoped CSS rewritingvar path = require(&#x27;path&#x27;)var hash = require(&#x27;hash-sum&#x27;)var cache = Object.create(null)var sepRE = new RegExp(path.sep.replace(&#x27;\\\\&#x27;, &#x27;\\\\\\\\&#x27;), &#x27;g&#x27;)module.exports = function genId (file, context, key) &#123; var contextPath = context.split(path.sep) var rootId = contextPath[contextPath.length - 1] file = rootId + &#x27;/&#x27; + path.relative(context, file).replace(sepRE, &#x27;/&#x27;) + (key || &#x27;&#x27;) return cache[file] || (cache[file] = hash(file))&#125; 其实就是根据文件在文件中的相对地址和key生成的唯一id","categories":[],"tags":[{"name":"局部样式","slug":"局部样式","permalink":"https://wisiw.github.io.git/tags/%E5%B1%80%E9%83%A8%E6%A0%B7%E5%BC%8F/"},{"name":"vue-loader","slug":"vue-loader","permalink":"https://wisiw.github.io.git/tags/vue-loader/"}]},{"title":"【Webpack】模块打包原理","slug":"【Webpack】模块打包原理","date":"2021-09-30T02:11:07.000Z","updated":"2022-10-29T21:10:13.661Z","comments":true,"path":"2021/09/30/【Webpack】模块打包原理/","link":"","permalink":"https://wisiw.github.io.git/2021/09/30/%E3%80%90Webpack%E3%80%91%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E5%8E%9F%E7%90%86/","excerpt":"","text":"源码 文件列表 123456├── example│ ├── entry.js│ ├── message.js│ └── name.js├── bundle.js└── package.json 1.createAsset函数创建AST，主要使用babel库此方法主要获取一下几个值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112```dependencies```传入文件的内部依赖```code```转译成一般js的当前文件代码通过```fs.readFileSync```读取文件，```babylon.parse()```转换为```AST```语法树```json// example/entry.js转译为NodeNode &#123; type: &#x27;File&#x27;, start: 0, end: 57, loc: SourceLocation &#123; start: Position &#123; line: 1, column: 0 &#125;, end: Position &#123; line: 3, column: 21 &#125; &#125;, program: Node &#123; type: &#x27;Program&#x27;, start: 0, end: 57, loc: SourceLocation &#123; start: [Position], end: [Position] &#125;, sourceType: &#x27;module&#x27;, body: [ [Node], [Node] ], directives: [] &#125;, comments: [], tokens: [ Token &#123; type: [KeywordTokenType], value: &#x27;import&#x27;, start: 0, end: 6, loc: [SourceLocation] &#125;, Token &#123; type: [TokenType], value: &#x27;message&#x27;, start: 7, end: 14, loc: [SourceLocation] &#125;, Token &#123; type: [TokenType], value: &#x27;from&#x27;, start: 15, end: 19, loc: [SourceLocation] &#125;, Token &#123; type: [TokenType], value: &#x27;./message.js&#x27;, start: 20, end: 34, loc: [SourceLocation] &#125;, Token &#123; type: [TokenType], value: &#x27;console&#x27;, start: 36, end: 43, loc: [SourceLocation] &#125;, Token &#123; type: [TokenType], value: undefined, start: 43, end: 44, loc: [SourceLocation] &#125;, Token &#123; type: [TokenType], value: &#x27;log&#x27;, start: 44, end: 47, loc: [SourceLocation] &#125;, Token &#123; type: [TokenType], value: undefined, start: 47, end: 48, loc: [SourceLocation] &#125;, Token &#123; type: [TokenType], value: &#x27;message&#x27;, start: 48, end: 55, loc: [SourceLocation] &#125;, Token &#123; type: [TokenType], value: undefined, start: 55, end: 56, loc: [SourceLocation] &#125;, Token &#123; type: [TokenType], value: undefined, start: 56, end: 57, loc: [SourceLocation] &#125;, Token &#123; type: [TokenType], value: undefined, start: 57, end: 57, loc: [SourceLocation] &#125; ]&#125; 经过traverse检索出导入的模块路径 12// example/entry.jsimport message from &#x27;./message.js&#x27; example/entry.js中引用了同目录下的message.js因此 12345traverse(ast, &#123; ImportDeclaration: (&#123; node &#125;) =&gt; &#123; // node即为entrt.js中导入的message.js &#125;,&#125;); 将获取到的依赖路径放入依赖树中 1dependencies.push(node.source.value); 通过babel-core的transformFromAst转译成一般浏览器能识别的js代码 123const &#123; code &#125; = transformFromAst(ast, null, &#123; presets: [&quot;env&quot;],&#125;); 123456789&quot;use strict&quot;;var _message = require(&quot;./message.js&quot;);var _message2 = _interopRequireDefault(_message);function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;console.log(_message2.default) 最后返回需要的参数 123456return &#123; id, fileName, dependencies, code,&#125; 全部代码 123456789101112131415161718192021222324252627282930313233const fs = require(&#x27;fs&#x27;)const babylon = require(&#x27;babylon&#x27;)const traverse = require(&#x27;babel-traverse&#x27;).defaultconst &#123; transformFromAst &#125; = require(&#x27;babel-core&#x27;)/** * @function 创建AST * @param &#123;String&#125; fileName * @returns &#123;&#125; id, fileName, dependenciescode, code */let ID = 0function createAsset(fileName) &#123; const content = fs.readFileSync(fileName, &#x27;utf-8&#x27;) const ast = babylon.parse(content, &#123; sourceType: &#x27;module&#x27; &#125;) const dependencies = [] traverse(ast,&#123; ImportDeclaration: (&#123;node&#125;) =&gt; &#123; dependencies.push(node.source.value) &#125; &#125;) const id = ID++ const &#123; code &#125; = transformFromAst(ast, null, &#123; presets: [&#x27;env&#x27;] &#125;) return &#123; id, fileName, dependencies, code &#125;&#125; 2.创建模块依赖树根据获取到的文件AST，遍历依赖获取AST，生成模块依赖树，并将当前模块的依赖模块以&#123;key: relationPath: value: id&#125;的格式存入map中 1234567891011121314151617const path = require(&#x27;path&#x27;)function createGraph(entry) &#123; const mainAsset = createAsset(entry) const queue = [mainAsset] for(const ast of queue) &#123; const dirname = path.dirname(ast.fileName) ast.mapping = &#123;&#125; ast.dependencies.forEach(relationPath =&gt; &#123; const absolutePath = path.join(dirname, relationPath) const child = createAsset(absolutePath) ast.mapping[relationPath] = child.id queue.push(child) &#125;) &#125; return queue&#125; 3.源代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182const fs = require(&quot;fs&quot;);const path = require(&quot;path&quot;);const babylon = require(&quot;babylon&quot;);const traverse = require(&quot;babel-traverse&quot;).default;const &#123; transformFromAst &#125; = require(&quot;babel-core&quot;);let ID = 0;function createAsset(fileName) &#123; const content = fs.readFileSync(fileName, &quot;utf-8&quot;); const ast = babylon.parse(content, &#123; sourceType: &quot;module&quot;, &#125;); const dependencies = []; traverse(ast, &#123; ImportDeclaration: (&#123; node &#125;) =&gt; &#123; dependencies.push(node.source.value); &#125;, &#125;); const id = ID++; const &#123; code &#125; = transformFromAst(ast, null, &#123; presets: [&quot;env&quot;], &#125;); return &#123; id, fileName, dependencies, code, &#125;;&#125;function createGraph(entry) &#123; const mainAsset = createAsset(entry); const queue = [mainAsset]; for (const ast of queue) &#123; const dirname = path.dirname(ast.fileName); ast.mapping = &#123;&#125;; ast.dependencies.forEach((relationPath) =&gt; &#123; const absolutePath = path.join(dirname, relationPath); const child = createAsset(absolutePath); ast.mapping[relationPath] = child.id; queue.push(child); &#125;); &#125; return queue;&#125;function bundle(graph) &#123; let modules = &quot;&quot;; graph.forEach((mod) =&gt; &#123; modules += `$&#123;mod.id&#125;: [ function(require, module, exports) &#123; $&#123;mod.code&#125; &#125;, $&#123;JSON.stringify(mod.mapping)&#125; ],`; &#125;); const res = ` (function(modules) &#123; function require(id) &#123; const [fn, mapping] = modules[id] function localRequire(relativePath) &#123; return require(mapping[relativePath]) &#125; const module = &#123; exports: &#123;&#125; &#125; fn(localRequire, module, module.exports) return module.exports &#125; require(0) &#125;)(&#123;$&#123;modules&#125;&#125;) `; return res;&#125;const graph = createGraph(&quot;./example/entry.js&quot;);const res = bundle(graph);console.log(res);","categories":[],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"https://wisiw.github.io.git/tags/Webpack/"},{"name":"模块打包","slug":"模块打包","permalink":"https://wisiw.github.io.git/tags/%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85/"}]},{"title":"【面试题】Webpack","slug":"【面试题】Webpack","date":"2021-09-28T05:57:46.000Z","updated":"2021-12-01T02:38:13.593Z","comments":true,"path":"2021/09/28/【面试题】Webpack/","link":"","permalink":"https://wisiw.github.io.git/2021/09/28/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%91Webpack/","excerpt":"","text":"是什么打包模块化js的工具，可以通过loader转换文件，通过plugin扩展功能 webpack原理loder输入什么产出什么提高构建速度的方法动态加载的原理","categories":[],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"https://wisiw.github.io.git/tags/Webpack/"},{"name":"面试题","slug":"面试题","permalink":"https://wisiw.github.io.git/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"【Uni】功能代码","slug":"【Uni】功能代码","date":"2021-09-28T03:00:02.000Z","updated":"2021-09-28T03:04:52.949Z","comments":true,"path":"2021/09/28/【Uni】功能代码/","link":"","permalink":"https://wisiw.github.io.git/2021/09/28/%E3%80%90Uni%E3%80%91%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/","excerpt":"","text":"锚点定位123456789101112131415161718192021const topTabList = [ &#123; name: &#x27;锚点一&#x27;, point: 0 &#125;, &#123; name: &#x27;锚点二&#x27;, point: 0 &#125;, &#123; name: &#x27;锚点三&#x27;, point: 0 &#125;,]getScrollPoint(className) &#123; const systemInfo = uni.getSystemInfoSync() let query = &#x27;&#x27; // 在微信小程序中，如果把骨架屏放入组件中使用的话，需要调in(this)上下文为父组件才有效 // #ifdef MP-WEIXIN query = uni.createSelectorQuery().in(this.$parent) // #endif // #ifndef MP-WEIXIN query = uni.createSelectorQuery() // #endif query.selectAll(`.$&#123;className&#125;`).boundingClientRect().exec((res) =&gt; &#123; res[0].forEach((v, i) =&gt; &#123; topTabList[i].point = v.top - v.height - 20 - (systemInfo.platform === &#x27;ios&#x27; ? 44 : 48) &#125;) &#125;)&#125;","categories":[],"tags":[{"name":"功能代码","slug":"功能代码","permalink":"https://wisiw.github.io.git/tags/%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"name":"Uni","slug":"Uni","permalink":"https://wisiw.github.io.git/tags/Uni/"}]},{"title":"【JavaScript】文件上传","slug":"【JavaScript】文件上传","date":"2021-09-26T07:50:34.000Z","updated":"2021-11-18T05:59:13.968Z","comments":true,"path":"2021/09/26/【JavaScript】文件上传/","link":"","permalink":"https://wisiw.github.io.git/2021/09/26/%E3%80%90JavaScript%E3%80%91%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","excerpt":"","text":"","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wisiw.github.io.git/tags/JavaScript/"},{"name":"fileUpload","slug":"fileUpload","permalink":"https://wisiw.github.io.git/tags/fileUpload/"}]},{"title":"【JavaScript】文件下载","slug":"【JavaScript】文件下载","date":"2021-09-26T07:50:06.000Z","updated":"2021-11-18T05:59:08.976Z","comments":true,"path":"2021/09/26/【JavaScript】文件下载/","link":"","permalink":"https://wisiw.github.io.git/2021/09/26/%E3%80%90JavaScript%E3%80%91%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/","excerpt":"","text":"","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wisiw.github.io.git/tags/JavaScript/"},{"name":"fileDownload","slug":"fileDownload","permalink":"https://wisiw.github.io.git/tags/fileDownload/"}]},{"title":"【CSS】样式","slug":"【CSS】样式","date":"2021-09-26T02:06:53.000Z","updated":"2021-11-18T05:31:33.774Z","comments":true,"path":"2021/09/26/【CSS】样式/","link":"","permalink":"https://wisiw.github.io.git/2021/09/26/%E3%80%90CSS%E3%80%91%E6%A0%B7%E5%BC%8F/","excerpt":"","text":"文字超出隐藏单行文字多行文字中英文自动换行div垂直居中div中图片和文字同时上下居中图片保持宽高比placeholder样式滚动条样式隐藏滚动条三角形吸顶滚动出现元素占满整个屏幕禁止用户选择字母大小写转换识别字符串中的’\\n’并换行加载动画文字渐变阴影立体字全屏背景文字描边水流的实现","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://wisiw.github.io.git/tags/CSS/"}]},{"title":"【JavaScript】功能代码","slug":"【JavaScript】功能代码","date":"2021-09-23T07:05:51.000Z","updated":"2021-12-06T05:13:49.313Z","comments":true,"path":"2021/09/23/【JavaScript】功能代码/","link":"","permalink":"https://wisiw.github.io.git/2021/09/23/%E3%80%90JavaScript%E3%80%91%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/","excerpt":"","text":"获取数组深度12345678910111213const arr = [1,2,[3,[4,5]],[1,2,3,[1,2,[1,[2,2],2],3]]]console.log(getArrDepth(arr)) // 5function getArrDepth (arr, num = 0) &#123; if (Array.isArray(arr)) &#123; num+=1 const depArr = [] arr.map((v) =&gt; &#123; depArr.push(getArrDepth(v, num)) &#125;) num = depArr.sort((a,b) =&gt; b - a)[0] &#125; return num&#125; 数额转化1 时长转化123456789101112131415161718192021// 时长转xx天xx小时xx分钟 （默认分钟单位）function timeStamp(time, isSecond = false) &#123; let StatusMin = isSecond ? time / 60 : time const day = parseInt(StatusMin / 60 / 24) const hour = parseInt((StatusMin / 60) % 24) let min = parseInt(StatusMin % 60) if (StatusMin &gt; 0 &lt; 60) &#123; min = Math.ceil(StatusMin % 60) &#125; let res = &#x27;&#x27; if (day &gt; 0) &#123; res = day + &#x27;天&#x27; &#125; if (hour &gt; 0) &#123; res += hour + &#x27;小时&#x27; &#125; if (min &gt; 0) &#123; res += parseFloat(min) + &#x27;分钟&#x27; &#125; return res || &#x27;--&#x27;&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wisiw.github.io.git/tags/JavaScript/"},{"name":"功能代码","slug":"功能代码","permalink":"https://wisiw.github.io.git/tags/%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"}]},{"title":"【route】导航基础","slug":"【Route】导航基础","date":"2021-09-23T01:58:28.000Z","updated":"2021-12-05T10:47:12.534Z","comments":true,"path":"2021/09/23/【Route】导航基础/","link":"","permalink":"https://wisiw.github.io.git/2021/09/23/%E3%80%90Route%E3%80%91%E5%AF%BC%E8%88%AA%E5%9F%BA%E7%A1%80/","excerpt":"","text":"1.URI与URLURO（Uniform Resource Identifier），允许用户对网络中的资源通过特定的协议进行交互操作。 Uniform：规定统一的语法格式，以方便处理多种不同类型的资源，而无需根据上下文环境来识别资源类型 Resource：科表示的任何资源，资源不仅可以为单一对象，也可以为多个对象的集合体 Identifier：表示可标识的对象，也称为标识符","categories":[],"tags":[{"name":"route","slug":"route","permalink":"https://wisiw.github.io.git/tags/route/"},{"name":"基础","slug":"基础","permalink":"https://wisiw.github.io.git/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"【代码片段】自动化导入组件模块","slug":"【代码片段】根据组件目录全局注册组件","date":"2021-09-22T05:55:54.000Z","updated":"2021-11-30T07:40:45.608Z","comments":true,"path":"2021/09/22/【代码片段】根据组件目录全局注册组件/","link":"","permalink":"https://wisiw.github.io.git/2021/09/22/%E3%80%90%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E3%80%91%E6%A0%B9%E6%8D%AE%E7%BB%84%E4%BB%B6%E7%9B%AE%E5%BD%95%E5%85%A8%E5%B1%80%E6%B3%A8%E5%86%8C%E7%BB%84%E4%BB%B6/","excerpt":"","text":"使用require.context代替大量使用import1.require.context()123456/** * dir:要查找的文件路径 * useSubdirectories:是否查找子目录 * regExp:要匹配文件的正则 */require.context(dir, useSubdirectories, regExp) 2.使用 目录结构 123456src ├── components | ├─ A.js | ├─ B.js | └─ C.js └── index.js 1234567// index.jsconst ctx = require.context(&#x27;./components/&#x27;, true, /\\.js$/)console.log(ctx.id) // &#x27;./src/components&#x27;// 返回的是模块内部变量map的keys，通过模块提供的keys()方法访问console.log(ctx.keys()) // [&#x27;./A.js&#x27;, &#x27;./B.js&#x27;, &#x27;./C.js&#x27; ]// 返回相对于整个工程的相对路径console.log(ctx.resolve(&#x27;./A.js&#x27;)) // &#x27;./src/components/A.js&#x27; 12345678910111213141516171819202122232425var map = &#123; &quot;./A.js&quot;: &quot;./src/components/A.js&quot;, &quot;./B.js&quot;: &quot;./src/components/B.js&quot;, &quot;./C.js&quot;: &quot;./src/components/C.js&quot;&#125;;function webpackContext(req) &#123; var id = webpackContextResolve(req); return __webpack_require__(id);&#125;function webpackContextResolve(req) &#123; var id = map[req]; if(!(id + 1)) &#123; // check for number or string var e = new Error(&quot;Cannot find module &#x27;&quot; + req + &quot;&#x27;&quot;); e.code = &#x27;MODULE_NOT_FOUND&#x27;; throw e; &#125; return id;&#125;webpackContext.keys = function webpackContextKeys() &#123; return Object.keys(map);&#125;;webpackContext.resolve = webpackContextResolve;webpackContext.id = &quot;./src/components sync recursive \\\\.js$&quot;;module.exports = webpackContext; 2.实际使用1234567891011121314// ./src/components/index.js// 查找当前目录下所有的index.vueconst ctx = require.context(&#x27;./&#x27;, true, /index\\.vue$/)// install() 被Vue.use()调用export default &#123; install: (Vue) =&gt; &#123; ctx.keys().forEach(i =&gt; &#123; const component = ctx(i).default Vue.component(component.name, component) &#125;) &#125;&#125; 123456// ./src/main.jsimport Vue from &#x27;vue&#x27;import Components from &#x27;@/components/index.js&#x27;// 全局注册公用组件Vue.use(Components)","categories":[],"tags":[{"name":"代码片段","slug":"代码片段","permalink":"https://wisiw.github.io.git/tags/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"},{"name":"组件","slug":"组件","permalink":"https://wisiw.github.io.git/tags/%E7%BB%84%E4%BB%B6/"},{"name":"前端组件化","slug":"前端组件化","permalink":"https://wisiw.github.io.git/tags/%E5%89%8D%E7%AB%AF%E7%BB%84%E4%BB%B6%E5%8C%96/"}]},{"title":"【Node】module.exports与exports的区别","slug":"【Node】module-exports与exports的区别","date":"2021-09-14T07:03:30.000Z","updated":"2021-09-23T05:57:04.390Z","comments":true,"path":"2021/09/14/【Node】module-exports与exports的区别/","link":"","permalink":"https://wisiw.github.io.git/2021/09/14/%E3%80%90Node%E3%80%91module-exports%E4%B8%8Eexports%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://wisiw.github.io.git/tags/node/"}]},{"title":"app相关代码","slug":"app相关代码","date":"2021-09-13T03:14:23.000Z","updated":"2021-09-13T03:17:34.994Z","comments":true,"path":"2021/09/13/app相关代码/","link":"","permalink":"https://wisiw.github.io.git/2021/09/13/app%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/","excerpt":"","text":"跳转到应用商店: 1(https)|(itms-apps)://itunes.apple.com/app/id&#123;appID&#125; 跳转到撰写评价： 1(https)|(itms-apps)://itunes.apple.com/app/id&#123;appID&#125;?action=write-review 跳转到查看评价： 1(https)|(itms-apps)://itunes.apple.com/app/viewContentsUserReviews?id=&#123;appID&#125; 示例： 1window.location.href = &#x27;itms-apps://itunes.apple.com/app/id414478124?action=write-review&#x27;","categories":[],"tags":[{"name":"app","slug":"app","permalink":"https://wisiw.github.io.git/tags/app/"}]},{"title":"【源码解析】backbone.js","slug":"【源码解析】backbone.js","date":"2021-09-10T06:55:28.000Z","updated":"2021-09-23T06:18:28.181Z","comments":true,"path":"2021/09/10/【源码解析】backbone.js/","link":"","permalink":"https://wisiw.github.io.git/2021/09/10/%E3%80%90%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91backbone.js/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221122212231224122512261227122812291230123112321233123412351236123712381239124012411242124312441245124612471248124912501251125212531254125512561257125812591260126112621263126412651266126712681269127012711272127312741275127612771278127912801281128212831284128512861287128812891290129112921293129412951296129712981299130013011302130313041305130613071308130913101311131213131314131513161317131813191320132113221323132413251326132713281329133013311332133313341335133613371338133913401341134213431344134513461347134813491350135113521353135413551356135713581359136013611362136313641365136613671368136913701371137213731374137513761377137813791380138113821383138413851386138713881389139013911392139313941395139613971398139914001401140214031404140514061407140814091410141114121413141414151416141714181419142014211422142314241425142614271428142914301431143214331434143514361437143814391440144114421443144414451446144714481449145014511452145314541455145614571458145914601461146214631464146514661467146814691470147114721473147414751476147714781479148014811482148314841485148614871488148914901491149214931494149514961497149814991500150115021503150415051506150715081509151015111512151315141515151615171518151915201521152215231524152515261527152815291530153115321533153415351536153715381539154015411542154315441545154615471548154915501551155215531554155515561557155815591560156115621563156415651566156715681569157015711572157315741575157615771578157915801581158215831584158515861587158815891590159115921593159415951596159715981599160016011602160316041605160616071608160916101611161216131614161516161617161816191620162116221623162416251626162716281629163016311632163316341635163616371638163916401641164216431644164516461647164816491650165116521653165416551656165716581659166016611662166316641665166616671668166916701671167216731674167516761677167816791680168116821683168416851686168716881689169016911692169316941695169616971698169917001701170217031704170517061707170817091710171117121713171417151716171717181719172017211722172317241725172617271728172917301731173217331734173517361737173817391740174117421743174417451746174717481749175017511752175317541755175617571758175917601761176217631764176517661767176817691770177117721773177417751776177717781779178017811782178317841785178617871788178917901791179217931794179517961797179817991800180118021803180418051806180718081809181018111812181318141815181618171818181918201821182218231824182518261827182818291830183118321833183418351836183718381839184018411842184318441845184618471848184918501851185218531854185518561857185818591860186118621863186418651866186718681869187018711872187318741875187618771878187918801881188218831884188518861887188818891890189118921893189418951896189718981899190019011902190319041905190619071908190919101911191219131914191519161917191819191920192119221923192419251926192719281929193019311932193319341935193619371938193919401941194219431944194519461947194819491950195119521953195419551956195719581959196019611962196319641965196619671968196919701971197219731974197519761977197819791980198119821983198419851986198719881989199019911992199319941995199619971998199920002001200220032004200520062007200820092010201120122013201420152016201720182019202020212022202320242025202620272028202920302031203220332034203520362037203820392040204120422043204420452046204720482049205020512052205320542055205620572058205920602061206220632064206520662067206820692070207120722073207420752076207720782079208020812082208320842085208620872088208920902091209220932094209520962097// Backbone.js 1.4.0// (c) 2010-2019 Jeremy Ashkenas and DocumentCloud// Backbone may be freely distributed under the MIT license.// For all details and documentation:// http://backbonejs.org(function(factory) &#123; // Establish the root object, `window` (`self`) in the browser, or `global` on the server. // We use `self` instead of `window` for `WebWorker` support. var root = typeof self == &#x27;object&#x27; &amp;&amp; self.self === self &amp;&amp; self || typeof global == &#x27;object&#x27; &amp;&amp; global.global === global &amp;&amp; global; // Set up Backbone appropriately for the environment. Start with AMD. if (typeof define === &#x27;function&#x27; &amp;&amp; define.amd) &#123; define([&#x27;underscore&#x27;, &#x27;jquery&#x27;, &#x27;exports&#x27;], function(_, $, exports) &#123; // Export global even in AMD case in case this script is loaded with // others that may still expect a global Backbone. root.Backbone = factory(root, exports, _, $); &#125;); // Next for Node.js or CommonJS. jQuery may not be needed as a module. &#125; else if (typeof exports !== &#x27;undefined&#x27;) &#123; var _ = require(&#x27;underscore&#x27;), $; try &#123; $ = require(&#x27;jquery&#x27;); &#125; catch (e) &#123;&#125; factory(root, exports, _, $); // Finally, as a browser global. &#125; else &#123; root.Backbone = factory(root, &#123;&#125;, root._, root.jQuery || root.Zepto || root.ender || root.$); &#125;&#125;)(function(root, Backbone, _, $) &#123; // Initial Setup // ------------- // Save the previous value of the `Backbone` variable, so that it can be // restored later on, if `noConflict` is used. var previousBackbone = root.Backbone; // Create a local reference to a common array method we&#x27;ll want to use later. var slice = Array.prototype.slice; // Current version of the library. Keep in sync with `package.json`. Backbone.VERSION = &#x27;1.4.0&#x27;; // For Backbone&#x27;s purposes, jQuery, Zepto, Ender, or My Library (kidding) owns // the `$` variable. Backbone.$ = $; // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable // to its previous owner. Returns a reference to this Backbone object. Backbone.noConflict = function() &#123; root.Backbone = previousBackbone; return this; &#125;; // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option // will fake `&quot;PATCH&quot;`, `&quot;PUT&quot;` and `&quot;DELETE&quot;` requests via the `_method` parameter and // set a `X-Http-Method-Override` header. Backbone.emulateHTTP = false; // Turn on `emulateJSON` to support legacy servers that can&#x27;t deal with direct // `application/json` requests ... this will encode the body as // `application/x-www-form-urlencoded` instead and will send the model in a // form param named `model`. Backbone.emulateJSON = false; // Backbone.Events // --------------- // A module that can be mixed in to *any object* in order to provide it with // a custom event channel. You may bind a callback to an event with `on` or // remove with `off`; `trigger`-ing an event fires all callbacks in // succession. // // var object = &#123;&#125;; // _.extend(object, Backbone.Events); // object.on(&#x27;expand&#x27;, function()&#123; alert(&#x27;expanded&#x27;); &#125;); // object.trigger(&#x27;expand&#x27;); // var Events = Backbone.Events = &#123;&#125;; // Regular expression used to split event strings. var eventSplitter = /\\s+/; // A private global variable to share between listeners and listenees. var _listening; // Iterates over the standard `event, callback` (as well as the fancy multiple // space-separated events `&quot;change blur&quot;, callback` and jQuery-style event // maps `&#123;event: callback&#125;`). var eventsApi = function(iteratee, events, name, callback, opts) &#123; var i = 0, names; if (name &amp;&amp; typeof name === &#x27;object&#x27;) &#123; // Handle event maps. if (callback !== void 0 &amp;&amp; &#x27;context&#x27; in opts &amp;&amp; opts.context === void 0) opts.context = callback; for (names = _.keys(name); i &lt; names.length ; i++) &#123; events = eventsApi(iteratee, events, names[i], name[names[i]], opts); &#125; &#125; else if (name &amp;&amp; eventSplitter.test(name)) &#123; // Handle space-separated event names by delegating them individually. for (names = name.split(eventSplitter); i &lt; names.length; i++) &#123; events = iteratee(events, names[i], callback, opts); &#125; &#125; else &#123; // Finally, standard events. events = iteratee(events, name, callback, opts); &#125; return events; &#125;; // Bind an event to a `callback` function. Passing `&quot;all&quot;` will bind // the callback to all events fired. Events.on = function(name, callback, context) &#123; this._events = eventsApi(onApi, this._events || &#123;&#125;, name, callback, &#123; context: context, ctx: this, listening: _listening &#125;); if (_listening) &#123; var listeners = this._listeners || (this._listeners = &#123;&#125;); listeners[_listening.id] = _listening; // Allow the listening to use a counter, instead of tracking // callbacks for library interop _listening.interop = false; &#125; return this; &#125;; // Inversion-of-control versions of `on`. Tell *this* object to listen to // an event in another object... keeping track of what it&#x27;s listening to // for easier unbinding later. Events.listenTo = function(obj, name, callback) &#123; if (!obj) return this; var id = obj._listenId || (obj._listenId = _.uniqueId(&#x27;l&#x27;)); var listeningTo = this._listeningTo || (this._listeningTo = &#123;&#125;); var listening = _listening = listeningTo[id]; // This object is not listening to any other events on `obj` yet. // Setup the necessary references to track the listening callbacks. if (!listening) &#123; this._listenId || (this._listenId = _.uniqueId(&#x27;l&#x27;)); listening = _listening = listeningTo[id] = new Listening(this, obj); &#125; // Bind callbacks on obj. var error = tryCatchOn(obj, name, callback, this); _listening = void 0; if (error) throw error; // If the target obj is not Backbone.Events, track events manually. if (listening.interop) listening.on(name, callback); return this; &#125;; // The reducing API that adds a callback to the `events` object. var onApi = function(events, name, callback, options) &#123; if (callback) &#123; var handlers = events[name] || (events[name] = []); var context = options.context, ctx = options.ctx, listening = options.listening; if (listening) listening.count++; handlers.push(&#123;callback: callback, context: context, ctx: context || ctx, listening: listening&#125;); &#125; return events; &#125;; // An try-catch guarded #on function, to prevent poisoning the global // `_listening` variable. var tryCatchOn = function(obj, name, callback, context) &#123; try &#123; obj.on(name, callback, context); &#125; catch (e) &#123; return e; &#125; &#125;; // Remove one or many callbacks. If `context` is null, removes all // callbacks with that function. If `callback` is null, removes all // callbacks for the event. If `name` is null, removes all bound // callbacks for all events. Events.off = function(name, callback, context) &#123; if (!this._events) return this; this._events = eventsApi(offApi, this._events, name, callback, &#123; context: context, listeners: this._listeners &#125;); return this; &#125;; // Tell this object to stop listening to either specific events ... or // to every object it&#x27;s currently listening to. Events.stopListening = function(obj, name, callback) &#123; var listeningTo = this._listeningTo; if (!listeningTo) return this; var ids = obj ? [obj._listenId] : _.keys(listeningTo); for (var i = 0; i &lt; ids.length; i++) &#123; var listening = listeningTo[ids[i]]; // If listening doesn&#x27;t exist, this object is not currently // listening to obj. Break out early. if (!listening) break; listening.obj.off(name, callback, this); if (listening.interop) listening.off(name, callback); &#125; if (_.isEmpty(listeningTo)) this._listeningTo = void 0; return this; &#125;; // The reducing API that removes a callback from the `events` object. var offApi = function(events, name, callback, options) &#123; if (!events) return; var context = options.context, listeners = options.listeners; var i = 0, names; // Delete all event listeners and &quot;drop&quot; events. if (!name &amp;&amp; !context &amp;&amp; !callback) &#123; for (names = _.keys(listeners); i &lt; names.length; i++) &#123; listeners[names[i]].cleanup(); &#125; return; &#125; names = name ? [name] : _.keys(events); for (; i &lt; names.length; i++) &#123; name = names[i]; var handlers = events[name]; // Bail out if there are no events stored. if (!handlers) break; // Find any remaining events. var remaining = []; for (var j = 0; j &lt; handlers.length; j++) &#123; var handler = handlers[j]; if ( callback &amp;&amp; callback !== handler.callback &amp;&amp; callback !== handler.callback._callback || context &amp;&amp; context !== handler.context ) &#123; remaining.push(handler); &#125; else &#123; var listening = handler.listening; if (listening) listening.off(name, callback); &#125; &#125; // Replace events if there are any remaining. Otherwise, clean up. if (remaining.length) &#123; events[name] = remaining; &#125; else &#123; delete events[name]; &#125; &#125; return events; &#125;; // Bind an event to only be triggered a single time. After the first time // the callback is invoked, its listener will be removed. If multiple events // are passed in using the space-separated syntax, the handler will fire // once for each event, not once for a combination of all events. Events.once = function(name, callback, context) &#123; // Map the event into a `&#123;event: once&#125;` object. var events = eventsApi(onceMap, &#123;&#125;, name, callback, this.off.bind(this)); if (typeof name === &#x27;string&#x27; &amp;&amp; context == null) callback = void 0; return this.on(events, callback, context); &#125;; // Inversion-of-control versions of `once`. Events.listenToOnce = function(obj, name, callback) &#123; // Map the event into a `&#123;event: once&#125;` object. var events = eventsApi(onceMap, &#123;&#125;, name, callback, this.stopListening.bind(this, obj)); return this.listenTo(obj, events); &#125;; // Reduces the event callbacks into a map of `&#123;event: onceWrapper&#125;`. // `offer` unbinds the `onceWrapper` after it has been called. var onceMap = function(map, name, callback, offer) &#123; if (callback) &#123; var once = map[name] = _.once(function() &#123; offer(name, once); callback.apply(this, arguments); &#125;); once._callback = callback; &#125; return map; &#125;; // Trigger one or many events, firing all bound callbacks. Callbacks are // passed the same arguments as `trigger` is, apart from the event name // (unless you&#x27;re listening on `&quot;all&quot;`, which will cause your callback to // receive the true name of the event as the first argument). Events.trigger = function(name) &#123; if (!this._events) return this; var length = Math.max(0, arguments.length - 1); var args = Array(length); for (var i = 0; i &lt; length; i++) args[i] = arguments[i + 1]; eventsApi(triggerApi, this._events, name, void 0, args); return this; &#125;; // Handles triggering the appropriate event callbacks. var triggerApi = function(objEvents, name, callback, args) &#123; if (objEvents) &#123; var events = objEvents[name]; var allEvents = objEvents.all; if (events &amp;&amp; allEvents) allEvents = allEvents.slice(); if (events) triggerEvents(events, args); if (allEvents) triggerEvents(allEvents, [name].concat(args)); &#125; return objEvents; &#125;; // A difficult-to-believe, but optimized internal dispatch function for // triggering events. Tries to keep the usual cases speedy (most internal // Backbone events have 3 arguments). var triggerEvents = function(events, args) &#123; var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2]; switch (args.length) &#123; case 0: while (++i &lt; l) (ev = events[i]).callback.call(ev.ctx); return; case 1: while (++i &lt; l) (ev = events[i]).callback.call(ev.ctx, a1); return; case 2: while (++i &lt; l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return; case 3: while (++i &lt; l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return; default: while (++i &lt; l) (ev = events[i]).callback.apply(ev.ctx, args); return; &#125; &#125;; // A listening class that tracks and cleans up memory bindings // when all callbacks have been offed. var Listening = function(listener, obj) &#123; this.id = listener._listenId; this.listener = listener; this.obj = obj; this.interop = true; this.count = 0; this._events = void 0; &#125;; Listening.prototype.on = Events.on; // Offs a callback (or several). // Uses an optimized counter if the listenee uses Backbone.Events. // Otherwise, falls back to manual tracking to support events // library interop. Listening.prototype.off = function(name, callback) &#123; var cleanup; if (this.interop) &#123; this._events = eventsApi(offApi, this._events, name, callback, &#123; context: void 0, listeners: void 0 &#125;); cleanup = !this._events; &#125; else &#123; this.count--; cleanup = this.count === 0; &#125; if (cleanup) this.cleanup(); &#125;; // Cleans up memory bindings between the listener and the listenee. Listening.prototype.cleanup = function() &#123; delete this.listener._listeningTo[this.obj._listenId]; if (!this.interop) delete this.obj._listeners[this.id]; &#125;; // Aliases for backwards compatibility. Events.bind = Events.on; Events.unbind = Events.off; // Allow the `Backbone` object to serve as a global event bus, for folks who // want global &quot;pubsub&quot; in a convenient place. _.extend(Backbone, Events); // Backbone.Model // -------------- // Backbone **Models** are the basic data object in the framework -- // frequently representing a row in a table in a database on your server. // A discrete chunk of data and a bunch of useful, related methods for // performing computations and transformations on that data. // Create a new model with the specified attributes. A client id (`cid`) // is automatically generated and assigned for you. var Model = Backbone.Model = function(attributes, options) &#123; var attrs = attributes || &#123;&#125;; options || (options = &#123;&#125;); this.preinitialize.apply(this, arguments); this.cid = _.uniqueId(this.cidPrefix); this.attributes = &#123;&#125;; if (options.collection) this.collection = options.collection; if (options.parse) attrs = this.parse(attrs, options) || &#123;&#125;; var defaults = _.result(this, &#x27;defaults&#x27;); attrs = _.defaults(_.extend(&#123;&#125;, defaults, attrs), defaults); this.set(attrs, options); this.changed = &#123;&#125;; this.initialize.apply(this, arguments); &#125;; // Attach all inheritable methods to the Model prototype. _.extend(Model.prototype, Events, &#123; // A hash of attributes whose current and previous value differ. changed: null, // The value returned during the last failed validation. validationError: null, // The default name for the JSON `id` attribute is `&quot;id&quot;`. MongoDB and // CouchDB users may want to set this to `&quot;_id&quot;`. idAttribute: &#x27;id&#x27;, // The prefix is used to create the client id which is used to identify models locally. // You may want to override this if you&#x27;re experiencing name clashes with model ids. cidPrefix: &#x27;c&#x27;, // preinitialize is an empty function by default. You can override it with a function // or object. preinitialize will run before any instantiation logic is run in the Model. preinitialize: function()&#123;&#125;, // Initialize is an empty function by default. Override it with your own // initialization logic. initialize: function()&#123;&#125;, // Return a copy of the model&#x27;s `attributes` object. toJSON: function(options) &#123; return _.clone(this.attributes); &#125;, // Proxy `Backbone.sync` by default -- but override this if you need // custom syncing semantics for *this* particular model. sync: function() &#123; return Backbone.sync.apply(this, arguments); &#125;, // Get the value of an attribute. get: function(attr) &#123; return this.attributes[attr]; &#125;, // Get the HTML-escaped value of an attribute. escape: function(attr) &#123; return _.escape(this.get(attr)); &#125;, // Returns `true` if the attribute contains a value that is not null // or undefined. has: function(attr) &#123; return this.get(attr) != null; &#125;, // Special-cased proxy to underscore&#x27;s `_.matches` method. matches: function(attrs) &#123; return !!_.iteratee(attrs, this)(this.attributes); &#125;, // Set a hash of model attributes on the object, firing `&quot;change&quot;`. This is // the core primitive operation of a model, updating the data and notifying // anyone who needs to know about the change in state. The heart of the beast. set: function(key, val, options) &#123; if (key == null) return this; // Handle both `&quot;key&quot;, value` and `&#123;key: value&#125;` -style arguments. var attrs; if (typeof key === &#x27;object&#x27;) &#123; attrs = key; options = val; &#125; else &#123; (attrs = &#123;&#125;)[key] = val; &#125; options || (options = &#123;&#125;); // Run validation. if (!this._validate(attrs, options)) return false; // Extract attributes and options. var unset = options.unset; var silent = options.silent; var changes = []; var changing = this._changing; this._changing = true; if (!changing) &#123; this._previousAttributes = _.clone(this.attributes); this.changed = &#123;&#125;; &#125; var current = this.attributes; var changed = this.changed; var prev = this._previousAttributes; // For each `set` attribute, update or delete the current value. for (var attr in attrs) &#123; val = attrs[attr]; if (!_.isEqual(current[attr], val)) changes.push(attr); if (!_.isEqual(prev[attr], val)) &#123; changed[attr] = val; &#125; else &#123; delete changed[attr]; &#125; unset ? delete current[attr] : current[attr] = val; &#125; // Update the `id`. if (this.idAttribute in attrs) this.id = this.get(this.idAttribute); // Trigger all relevant attribute changes. if (!silent) &#123; if (changes.length) this._pending = options; for (var i = 0; i &lt; changes.length; i++) &#123; this.trigger(&#x27;change:&#x27; + changes[i], this, current[changes[i]], options); &#125; &#125; // You might be wondering why there&#x27;s a `while` loop here. Changes can // be recursively nested within `&quot;change&quot;` events. if (changing) return this; if (!silent) &#123; while (this._pending) &#123; options = this._pending; this._pending = false; this.trigger(&#x27;change&#x27;, this, options); &#125; &#125; this._pending = false; this._changing = false; return this; &#125;, // Remove an attribute from the model, firing `&quot;change&quot;`. `unset` is a noop // if the attribute doesn&#x27;t exist. unset: function(attr, options) &#123; return this.set(attr, void 0, _.extend(&#123;&#125;, options, &#123;unset: true&#125;)); &#125;, // Clear all attributes on the model, firing `&quot;change&quot;`. clear: function(options) &#123; var attrs = &#123;&#125;; for (var key in this.attributes) attrs[key] = void 0; return this.set(attrs, _.extend(&#123;&#125;, options, &#123;unset: true&#125;)); &#125;, // Determine if the model has changed since the last `&quot;change&quot;` event. // If you specify an attribute name, determine if that attribute has changed. hasChanged: function(attr) &#123; if (attr == null) return !_.isEmpty(this.changed); return _.has(this.changed, attr); &#125;, // Return an object containing all the attributes that have changed, or // false if there are no changed attributes. Useful for determining what // parts of a view need to be updated and/or what attributes need to be // persisted to the server. Unset attributes will be set to undefined. // You can also pass an attributes object to diff against the model, // determining if there *would be* a change. changedAttributes: function(diff) &#123; if (!diff) return this.hasChanged() ? _.clone(this.changed) : false; var old = this._changing ? this._previousAttributes : this.attributes; var changed = &#123;&#125;; var hasChanged; for (var attr in diff) &#123; var val = diff[attr]; if (_.isEqual(old[attr], val)) continue; changed[attr] = val; hasChanged = true; &#125; return hasChanged ? changed : false; &#125;, // Get the previous value of an attribute, recorded at the time the last // `&quot;change&quot;` event was fired. previous: function(attr) &#123; if (attr == null || !this._previousAttributes) return null; return this._previousAttributes[attr]; &#125;, // Get all of the attributes of the model at the time of the previous // `&quot;change&quot;` event. previousAttributes: function() &#123; return _.clone(this._previousAttributes); &#125;, // Fetch the model from the server, merging the response with the model&#x27;s // local attributes. Any changed attributes will trigger a &quot;change&quot; event. fetch: function(options) &#123; options = _.extend(&#123;parse: true&#125;, options); var model = this; var success = options.success; options.success = function(resp) &#123; var serverAttrs = options.parse ? model.parse(resp, options) : resp; if (!model.set(serverAttrs, options)) return false; if (success) success.call(options.context, model, resp, options); model.trigger(&#x27;sync&#x27;, model, resp, options); &#125;; wrapError(this, options); return this.sync(&#x27;read&#x27;, this, options); &#125;, // Set a hash of model attributes, and sync the model to the server. // If the server returns an attributes hash that differs, the model&#x27;s // state will be `set` again. save: function(key, val, options) &#123; // Handle both `&quot;key&quot;, value` and `&#123;key: value&#125;` -style arguments. var attrs; if (key == null || typeof key === &#x27;object&#x27;) &#123; attrs = key; options = val; &#125; else &#123; (attrs = &#123;&#125;)[key] = val; &#125; options = _.extend(&#123;validate: true, parse: true&#125;, options); var wait = options.wait; // If we&#x27;re not waiting and attributes exist, save acts as // `set(attr).save(null, opts)` with validation. Otherwise, check if // the model will be valid when the attributes, if any, are set. if (attrs &amp;&amp; !wait) &#123; if (!this.set(attrs, options)) return false; &#125; else if (!this._validate(attrs, options)) &#123; return false; &#125; // After a successful server-side save, the client is (optionally) // updated with the server-side state. var model = this; var success = options.success; var attributes = this.attributes; options.success = function(resp) &#123; // Ensure attributes are restored during synchronous saves. model.attributes = attributes; var serverAttrs = options.parse ? model.parse(resp, options) : resp; if (wait) serverAttrs = _.extend(&#123;&#125;, attrs, serverAttrs); if (serverAttrs &amp;&amp; !model.set(serverAttrs, options)) return false; if (success) success.call(options.context, model, resp, options); model.trigger(&#x27;sync&#x27;, model, resp, options); &#125;; wrapError(this, options); // Set temporary attributes if `&#123;wait: true&#125;` to properly find new ids. if (attrs &amp;&amp; wait) this.attributes = _.extend(&#123;&#125;, attributes, attrs); var method = this.isNew() ? &#x27;create&#x27; : options.patch ? &#x27;patch&#x27; : &#x27;update&#x27;; if (method === &#x27;patch&#x27; &amp;&amp; !options.attrs) options.attrs = attrs; var xhr = this.sync(method, this, options); // Restore attributes. this.attributes = attributes; return xhr; &#125;, // Destroy this model on the server if it was already persisted. // Optimistically removes the model from its collection, if it has one. // If `wait: true` is passed, waits for the server to respond before removal. destroy: function(options) &#123; options = options ? _.clone(options) : &#123;&#125;; var model = this; var success = options.success; var wait = options.wait; var destroy = function() &#123; model.stopListening(); model.trigger(&#x27;destroy&#x27;, model, model.collection, options); &#125;; options.success = function(resp) &#123; if (wait) destroy(); if (success) success.call(options.context, model, resp, options); if (!model.isNew()) model.trigger(&#x27;sync&#x27;, model, resp, options); &#125;; var xhr = false; if (this.isNew()) &#123; _.defer(options.success); &#125; else &#123; wrapError(this, options); xhr = this.sync(&#x27;delete&#x27;, this, options); &#125; if (!wait) destroy(); return xhr; &#125;, // Default URL for the model&#x27;s representation on the server -- if you&#x27;re // using Backbone&#x27;s restful methods, override this to change the endpoint // that will be called. url: function() &#123; var base = _.result(this, &#x27;urlRoot&#x27;) || _.result(this.collection, &#x27;url&#x27;) || urlError(); if (this.isNew()) return base; var id = this.get(this.idAttribute); return base.replace(/[^\\/]$/, &#x27;$&amp;/&#x27;) + encodeURIComponent(id); &#125;, // **parse** converts a response into the hash of attributes to be `set` on // the model. The default implementation is just to pass the response along. parse: function(resp, options) &#123; return resp; &#125;, // Create a new model with identical attributes to this one. clone: function() &#123; return new this.constructor(this.attributes); &#125;, // A model is new if it has never been saved to the server, and lacks an id. isNew: function() &#123; return !this.has(this.idAttribute); &#125;, // Check if the model is currently in a valid state. isValid: function(options) &#123; return this._validate(&#123;&#125;, _.extend(&#123;&#125;, options, &#123;validate: true&#125;)); &#125;, // Run validation against the next complete set of model attributes, // returning `true` if all is well. Otherwise, fire an `&quot;invalid&quot;` event. _validate: function(attrs, options) &#123; if (!options.validate || !this.validate) return true; attrs = _.extend(&#123;&#125;, this.attributes, attrs); var error = this.validationError = this.validate(attrs, options) || null; if (!error) return true; this.trigger(&#x27;invalid&#x27;, this, error, _.extend(options, &#123;validationError: error&#125;)); return false; &#125; &#125;); // Backbone.Collection // ------------------- // If models tend to represent a single row of data, a Backbone Collection is // more analogous to a table full of data ... or a small slice or page of that // table, or a collection of rows that belong together for a particular reason // -- all of the messages in this particular folder, all of the documents // belonging to this particular author, and so on. Collections maintain // indexes of their models, both in order, and for lookup by `id`. // Create a new **Collection**, perhaps to contain a specific type of `model`. // If a `comparator` is specified, the Collection will maintain // its models in sort order, as they&#x27;re added and removed. var Collection = Backbone.Collection = function(models, options) &#123; options || (options = &#123;&#125;); this.preinitialize.apply(this, arguments); if (options.model) this.model = options.model; if (options.comparator !== void 0) this.comparator = options.comparator; this._reset(); this.initialize.apply(this, arguments); if (models) this.reset(models, _.extend(&#123;silent: true&#125;, options)); &#125;; // Default options for `Collection#set`. var setOptions = &#123;add: true, remove: true, merge: true&#125;; var addOptions = &#123;add: true, remove: false&#125;; // Splices `insert` into `array` at index `at`. var splice = function(array, insert, at) &#123; at = Math.min(Math.max(at, 0), array.length); var tail = Array(array.length - at); var length = insert.length; var i; for (i = 0; i &lt; tail.length; i++) tail[i] = array[i + at]; for (i = 0; i &lt; length; i++) array[i + at] = insert[i]; for (i = 0; i &lt; tail.length; i++) array[i + length + at] = tail[i]; &#125;; // Define the Collection&#x27;s inheritable methods. _.extend(Collection.prototype, Events, &#123; // The default model for a collection is just a **Backbone.Model**. // This should be overridden in most cases. model: Model, // preinitialize is an empty function by default. You can override it with a function // or object. preinitialize will run before any instantiation logic is run in the Collection. preinitialize: function()&#123;&#125;, // Initialize is an empty function by default. Override it with your own // initialization logic. initialize: function()&#123;&#125;, // The JSON representation of a Collection is an array of the // models&#x27; attributes. toJSON: function(options) &#123; return this.map(function(model) &#123; return model.toJSON(options); &#125;); &#125;, // Proxy `Backbone.sync` by default. sync: function() &#123; return Backbone.sync.apply(this, arguments); &#125;, // Add a model, or list of models to the set. `models` may be Backbone // Models or raw JavaScript objects to be converted to Models, or any // combination of the two. add: function(models, options) &#123; return this.set(models, _.extend(&#123;merge: false&#125;, options, addOptions)); &#125;, // Remove a model, or a list of models from the set. remove: function(models, options) &#123; options = _.extend(&#123;&#125;, options); var singular = !_.isArray(models); models = singular ? [models] : models.slice(); var removed = this._removeModels(models, options); if (!options.silent &amp;&amp; removed.length) &#123; options.changes = &#123;added: [], merged: [], removed: removed&#125;; this.trigger(&#x27;update&#x27;, this, options); &#125; return singular ? removed[0] : removed; &#125;, // Update a collection by `set`-ing a new list of models, adding new ones, // removing models that are no longer present, and merging models that // already exist in the collection, as necessary. Similar to **Model#set**, // the core operation for updating the data contained by the collection. set: function(models, options) &#123; if (models == null) return; options = _.extend(&#123;&#125;, setOptions, options); if (options.parse &amp;&amp; !this._isModel(models)) &#123; models = this.parse(models, options) || []; &#125; var singular = !_.isArray(models); models = singular ? [models] : models.slice(); var at = options.at; if (at != null) at = +at; if (at &gt; this.length) at = this.length; if (at &lt; 0) at += this.length + 1; var set = []; var toAdd = []; var toMerge = []; var toRemove = []; var modelMap = &#123;&#125;; var add = options.add; var merge = options.merge; var remove = options.remove; var sort = false; var sortable = this.comparator &amp;&amp; at == null &amp;&amp; options.sort !== false; var sortAttr = _.isString(this.comparator) ? this.comparator : null; // Turn bare objects into model references, and prevent invalid models // from being added. var model, i; for (i = 0; i &lt; models.length; i++) &#123; model = models[i]; // If a duplicate is found, prevent it from being added and // optionally merge it into the existing model. var existing = this.get(model); if (existing) &#123; if (merge &amp;&amp; model !== existing) &#123; var attrs = this._isModel(model) ? model.attributes : model; if (options.parse) attrs = existing.parse(attrs, options); existing.set(attrs, options); toMerge.push(existing); if (sortable &amp;&amp; !sort) sort = existing.hasChanged(sortAttr); &#125; if (!modelMap[existing.cid]) &#123; modelMap[existing.cid] = true; set.push(existing); &#125; models[i] = existing; // If this is a new, valid model, push it to the `toAdd` list. &#125; else if (add) &#123; model = models[i] = this._prepareModel(model, options); if (model) &#123; toAdd.push(model); this._addReference(model, options); modelMap[model.cid] = true; set.push(model); &#125; &#125; &#125; // Remove stale models. if (remove) &#123; for (i = 0; i &lt; this.length; i++) &#123; model = this.models[i]; if (!modelMap[model.cid]) toRemove.push(model); &#125; if (toRemove.length) this._removeModels(toRemove, options); &#125; // See if sorting is needed, update `length` and splice in new models. var orderChanged = false; var replace = !sortable &amp;&amp; add &amp;&amp; remove; if (set.length &amp;&amp; replace) &#123; orderChanged = this.length !== set.length || _.some(this.models, function(m, index) &#123; return m !== set[index]; &#125;); this.models.length = 0; splice(this.models, set, 0); this.length = this.models.length; &#125; else if (toAdd.length) &#123; if (sortable) sort = true; splice(this.models, toAdd, at == null ? this.length : at); this.length = this.models.length; &#125; // Silently sort the collection if appropriate. if (sort) this.sort(&#123;silent: true&#125;); // Unless silenced, it&#x27;s time to fire all appropriate add/sort/update events. if (!options.silent) &#123; for (i = 0; i &lt; toAdd.length; i++) &#123; if (at != null) options.index = at + i; model = toAdd[i]; model.trigger(&#x27;add&#x27;, model, this, options); &#125; if (sort || orderChanged) this.trigger(&#x27;sort&#x27;, this, options); if (toAdd.length || toRemove.length || toMerge.length) &#123; options.changes = &#123; added: toAdd, removed: toRemove, merged: toMerge &#125;; this.trigger(&#x27;update&#x27;, this, options); &#125; &#125; // Return the added (or merged) model (or models). return singular ? models[0] : models; &#125;, // When you have more items than you want to add or remove individually, // you can reset the entire set with a new list of models, without firing // any granular `add` or `remove` events. Fires `reset` when finished. // Useful for bulk operations and optimizations. reset: function(models, options) &#123; options = options ? _.clone(options) : &#123;&#125;; for (var i = 0; i &lt; this.models.length; i++) &#123; this._removeReference(this.models[i], options); &#125; options.previousModels = this.models; this._reset(); models = this.add(models, _.extend(&#123;silent: true&#125;, options)); if (!options.silent) this.trigger(&#x27;reset&#x27;, this, options); return models; &#125;, // Add a model to the end of the collection. push: function(model, options) &#123; return this.add(model, _.extend(&#123;at: this.length&#125;, options)); &#125;, // Remove a model from the end of the collection. pop: function(options) &#123; var model = this.at(this.length - 1); return this.remove(model, options); &#125;, // Add a model to the beginning of the collection. unshift: function(model, options) &#123; return this.add(model, _.extend(&#123;at: 0&#125;, options)); &#125;, // Remove a model from the beginning of the collection. shift: function(options) &#123; var model = this.at(0); return this.remove(model, options); &#125;, // Slice out a sub-array of models from the collection. slice: function() &#123; return slice.apply(this.models, arguments); &#125;, // Get a model from the set by id, cid, model object with id or cid // properties, or an attributes object that is transformed through modelId. get: function(obj) &#123; if (obj == null) return void 0; return this._byId[obj] || this._byId[this.modelId(this._isModel(obj) ? obj.attributes : obj)] || obj.cid &amp;&amp; this._byId[obj.cid]; &#125;, // Returns `true` if the model is in the collection. has: function(obj) &#123; return this.get(obj) != null; &#125;, // Get the model at the given index. at: function(index) &#123; if (index &lt; 0) index += this.length; return this.models[index]; &#125;, // Return models with matching attributes. Useful for simple cases of // `filter`. where: function(attrs, first) &#123; return this[first ? &#x27;find&#x27; : &#x27;filter&#x27;](attrs); &#125;, // Return the first model with matching attributes. Useful for simple cases // of `find`. findWhere: function(attrs) &#123; return this.where(attrs, true); &#125;, // Force the collection to re-sort itself. You don&#x27;t need to call this under // normal circumstances, as the set will maintain sort order as each item // is added. sort: function(options) &#123; var comparator = this.comparator; if (!comparator) throw new Error(&#x27;Cannot sort a set without a comparator&#x27;); options || (options = &#123;&#125;); var length = comparator.length; if (_.isFunction(comparator)) comparator = comparator.bind(this); // Run sort based on type of `comparator`. if (length === 1 || _.isString(comparator)) &#123; this.models = this.sortBy(comparator); &#125; else &#123; this.models.sort(comparator); &#125; if (!options.silent) this.trigger(&#x27;sort&#x27;, this, options); return this; &#125;, // Pluck an attribute from each model in the collection. pluck: function(attr) &#123; return this.map(attr + &#x27;&#x27;); &#125;, // Fetch the default set of models for this collection, resetting the // collection when they arrive. If `reset: true` is passed, the response // data will be passed through the `reset` method instead of `set`. fetch: function(options) &#123; options = _.extend(&#123;parse: true&#125;, options); var success = options.success; var collection = this; options.success = function(resp) &#123; var method = options.reset ? &#x27;reset&#x27; : &#x27;set&#x27;; collection[method](resp, options); if (success) success.call(options.context, collection, resp, options); collection.trigger(&#x27;sync&#x27;, collection, resp, options); &#125;; wrapError(this, options); return this.sync(&#x27;read&#x27;, this, options); &#125;, // Create a new instance of a model in this collection. Add the model to the // collection immediately, unless `wait: true` is passed, in which case we // wait for the server to agree. create: function(model, options) &#123; options = options ? _.clone(options) : &#123;&#125;; var wait = options.wait; model = this._prepareModel(model, options); if (!model) return false; if (!wait) this.add(model, options); var collection = this; var success = options.success; options.success = function(m, resp, callbackOpts) &#123; if (wait) collection.add(m, callbackOpts); if (success) success.call(callbackOpts.context, m, resp, callbackOpts); &#125;; model.save(null, options); return model; &#125;, // **parse** converts a response into a list of models to be added to the // collection. The default implementation is just to pass it through. parse: function(resp, options) &#123; return resp; &#125;, // Create a new collection with an identical list of models as this one. clone: function() &#123; return new this.constructor(this.models, &#123; model: this.model, comparator: this.comparator &#125;); &#125;, // Define how to uniquely identify models in the collection. modelId: function(attrs) &#123; return attrs[this.model.prototype.idAttribute || &#x27;id&#x27;]; &#125;, // Get an iterator of all models in this collection. values: function() &#123; return new CollectionIterator(this, ITERATOR_VALUES); &#125;, // Get an iterator of all model IDs in this collection. keys: function() &#123; return new CollectionIterator(this, ITERATOR_KEYS); &#125;, // Get an iterator of all [ID, model] tuples in this collection. entries: function() &#123; return new CollectionIterator(this, ITERATOR_KEYSVALUES); &#125;, // Private method to reset all internal state. Called when the collection // is first initialized or reset. _reset: function() &#123; this.length = 0; this.models = []; this._byId = &#123;&#125;; &#125;, // Prepare a hash of attributes (or other model) to be added to this // collection. _prepareModel: function(attrs, options) &#123; if (this._isModel(attrs)) &#123; if (!attrs.collection) attrs.collection = this; return attrs; &#125; options = options ? _.clone(options) : &#123;&#125;; options.collection = this; var model = new this.model(attrs, options); if (!model.validationError) return model; this.trigger(&#x27;invalid&#x27;, this, model.validationError, options); return false; &#125;, // Internal method called by both remove and set. _removeModels: function(models, options) &#123; var removed = []; for (var i = 0; i &lt; models.length; i++) &#123; var model = this.get(models[i]); if (!model) continue; var index = this.indexOf(model); this.models.splice(index, 1); this.length--; // Remove references before triggering &#x27;remove&#x27; event to prevent an // infinite loop. #3693 delete this._byId[model.cid]; var id = this.modelId(model.attributes); if (id != null) delete this._byId[id]; if (!options.silent) &#123; options.index = index; model.trigger(&#x27;remove&#x27;, model, this, options); &#125; removed.push(model); this._removeReference(model, options); &#125; return removed; &#125;, // Method for checking whether an object should be considered a model for // the purposes of adding to the collection. _isModel: function(model) &#123; return model instanceof Model; &#125;, // Internal method to create a model&#x27;s ties to a collection. _addReference: function(model, options) &#123; this._byId[model.cid] = model; var id = this.modelId(model.attributes); if (id != null) this._byId[id] = model; model.on(&#x27;all&#x27;, this._onModelEvent, this); &#125;, // Internal method to sever a model&#x27;s ties to a collection. _removeReference: function(model, options) &#123; delete this._byId[model.cid]; var id = this.modelId(model.attributes); if (id != null) delete this._byId[id]; if (this === model.collection) delete model.collection; model.off(&#x27;all&#x27;, this._onModelEvent, this); &#125;, // Internal method called every time a model in the set fires an event. // Sets need to update their indexes when models change ids. All other // events simply proxy through. &quot;add&quot; and &quot;remove&quot; events that originate // in other collections are ignored. _onModelEvent: function(event, model, collection, options) &#123; if (model) &#123; if ((event === &#x27;add&#x27; || event === &#x27;remove&#x27;) &amp;&amp; collection !== this) return; if (event === &#x27;destroy&#x27;) this.remove(model, options); if (event === &#x27;change&#x27;) &#123; var prevId = this.modelId(model.previousAttributes()); var id = this.modelId(model.attributes); if (prevId !== id) &#123; if (prevId != null) delete this._byId[prevId]; if (id != null) this._byId[id] = model; &#125; &#125; &#125; this.trigger.apply(this, arguments); &#125; &#125;); // Defining an @@iterator method implements JavaScript&#x27;s Iterable protocol. // In modern ES2015 browsers, this value is found at Symbol.iterator. /* global Symbol */ var $$iterator = typeof Symbol === &#x27;function&#x27; &amp;&amp; Symbol.iterator; if ($$iterator) &#123; Collection.prototype[$$iterator] = Collection.prototype.values; &#125; // CollectionIterator // ------------------ // A CollectionIterator implements JavaScript&#x27;s Iterator protocol, allowing the // use of `for of` loops in modern browsers and interoperation between // Backbone.Collection and other JavaScript functions and third-party libraries // which can operate on Iterables. var CollectionIterator = function(collection, kind) &#123; this._collection = collection; this._kind = kind; this._index = 0; &#125;; // This &quot;enum&quot; defines the three possible kinds of values which can be emitted // by a CollectionIterator that correspond to the values(), keys() and entries() // methods on Collection, respectively. var ITERATOR_VALUES = 1; var ITERATOR_KEYS = 2; var ITERATOR_KEYSVALUES = 3; // All Iterators should themselves be Iterable. if ($$iterator) &#123; CollectionIterator.prototype[$$iterator] = function() &#123; return this; &#125;; &#125; CollectionIterator.prototype.next = function() &#123; if (this._collection) &#123; // Only continue iterating if the iterated collection is long enough. if (this._index &lt; this._collection.length) &#123; var model = this._collection.at(this._index); this._index++; // Construct a value depending on what kind of values should be iterated. var value; if (this._kind === ITERATOR_VALUES) &#123; value = model; &#125; else &#123; var id = this._collection.modelId(model.attributes); if (this._kind === ITERATOR_KEYS) &#123; value = id; &#125; else &#123; // ITERATOR_KEYSVALUES value = [id, model]; &#125; &#125; return &#123;value: value, done: false&#125;; &#125; // Once exhausted, remove the reference to the collection so future // calls to the next method always return done. this._collection = void 0; &#125; return &#123;value: void 0, done: true&#125;; &#125;; // Backbone.View // ------------- // Backbone Views are almost more convention than they are actual code. A View // is simply a JavaScript object that represents a logical chunk of UI in the // DOM. This might be a single item, an entire list, a sidebar or panel, or // even the surrounding frame which wraps your whole app. Defining a chunk of // UI as a **View** allows you to define your DOM events declaratively, without // having to worry about render order ... and makes it easy for the view to // react to specific changes in the state of your models. // Creating a Backbone.View creates its initial element outside of the DOM, // if an existing element is not provided... var View = Backbone.View = function(options) &#123; this.cid = _.uniqueId(&#x27;view&#x27;); this.preinitialize.apply(this, arguments); _.extend(this, _.pick(options, viewOptions)); this._ensureElement(); this.initialize.apply(this, arguments); &#125;; // Cached regex to split keys for `delegate`. var delegateEventSplitter = /^(\\S+)\\s*(.*)$/; // List of view options to be set as properties. var viewOptions = [&#x27;model&#x27;, &#x27;collection&#x27;, &#x27;el&#x27;, &#x27;id&#x27;, &#x27;attributes&#x27;, &#x27;className&#x27;, &#x27;tagName&#x27;, &#x27;events&#x27;]; // Set up all inheritable **Backbone.View** properties and methods. _.extend(View.prototype, Events, &#123; // The default `tagName` of a View&#x27;s element is `&quot;div&quot;`. tagName: &#x27;div&#x27;, // jQuery delegate for element lookup, scoped to DOM elements within the // current view. This should be preferred to global lookups where possible. $: function(selector) &#123; return this.$el.find(selector); &#125;, // preinitialize is an empty function by default. You can override it with a function // or object. preinitialize will run before any instantiation logic is run in the View preinitialize: function()&#123;&#125;, // Initialize is an empty function by default. Override it with your own // initialization logic. initialize: function()&#123;&#125;, // **render** is the core function that your view should override, in order // to populate its element (`this.el`), with the appropriate HTML. The // convention is for **render** to always return `this`. render: function() &#123; return this; &#125;, // Remove this view by taking the element out of the DOM, and removing any // applicable Backbone.Events listeners. remove: function() &#123; this._removeElement(); this.stopListening(); return this; &#125;, // Remove this view&#x27;s element from the document and all event listeners // attached to it. Exposed for subclasses using an alternative DOM // manipulation API. _removeElement: function() &#123; this.$el.remove(); &#125;, // Change the view&#x27;s element (`this.el` property) and re-delegate the // view&#x27;s events on the new element. setElement: function(element) &#123; this.undelegateEvents(); this._setElement(element); this.delegateEvents(); return this; &#125;, // Creates the `this.el` and `this.$el` references for this view using the // given `el`. `el` can be a CSS selector or an HTML string, a jQuery // context or an element. Subclasses can override this to utilize an // alternative DOM manipulation API and are only required to set the // `this.el` property. _setElement: function(el) &#123; this.$el = el instanceof Backbone.$ ? el : Backbone.$(el); this.el = this.$el[0]; &#125;, // Set callbacks, where `this.events` is a hash of // // *&#123;&quot;event selector&quot;: &quot;callback&quot;&#125;* // // &#123; // &#x27;mousedown .title&#x27;: &#x27;edit&#x27;, // &#x27;click .button&#x27;: &#x27;save&#x27;, // &#x27;click .open&#x27;: function(e) &#123; ... &#125; // &#125; // // pairs. Callbacks will be bound to the view, with `this` set properly. // Uses event delegation for efficiency. // Omitting the selector binds the event to `this.el`. delegateEvents: function(events) &#123; events || (events = _.result(this, &#x27;events&#x27;)); if (!events) return this; this.undelegateEvents(); for (var key in events) &#123; var method = events[key]; if (!_.isFunction(method)) method = this[method]; if (!method) continue; var match = key.match(delegateEventSplitter); this.delegate(match[1], match[2], method.bind(this)); &#125; return this; &#125;, // Add a single event listener to the view&#x27;s element (or a child element // using `selector`). This only works for delegate-able events: not `focus`, // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer. delegate: function(eventName, selector, listener) &#123; this.$el.on(eventName + &#x27;.delegateEvents&#x27; + this.cid, selector, listener); return this; &#125;, // Clears all callbacks previously bound to the view by `delegateEvents`. // You usually don&#x27;t need to use this, but may wish to if you have multiple // Backbone views attached to the same DOM element. undelegateEvents: function() &#123; if (this.$el) this.$el.off(&#x27;.delegateEvents&#x27; + this.cid); return this; &#125;, // A finer-grained `undelegateEvents` for removing a single delegated event. // `selector` and `listener` are both optional. undelegate: function(eventName, selector, listener) &#123; this.$el.off(eventName + &#x27;.delegateEvents&#x27; + this.cid, selector, listener); return this; &#125;, // Produces a DOM element to be assigned to your view. Exposed for // subclasses using an alternative DOM manipulation API. _createElement: function(tagName) &#123; return document.createElement(tagName); &#125;, // Ensure that the View has a DOM element to render into. // If `this.el` is a string, pass it through `$()`, take the first // matching element, and re-assign it to `el`. Otherwise, create // an element from the `id`, `className` and `tagName` properties. _ensureElement: function() &#123; if (!this.el) &#123; var attrs = _.extend(&#123;&#125;, _.result(this, &#x27;attributes&#x27;)); if (this.id) attrs.id = _.result(this, &#x27;id&#x27;); if (this.className) attrs[&#x27;class&#x27;] = _.result(this, &#x27;className&#x27;); this.setElement(this._createElement(_.result(this, &#x27;tagName&#x27;))); this._setAttributes(attrs); &#125; else &#123; this.setElement(_.result(this, &#x27;el&#x27;)); &#125; &#125;, // Set attributes from a hash on this view&#x27;s element. Exposed for // subclasses using an alternative DOM manipulation API. _setAttributes: function(attributes) &#123; this.$el.attr(attributes); &#125; &#125;); // Proxy Backbone class methods to Underscore functions, wrapping the model&#x27;s // `attributes` object or collection&#x27;s `models` array behind the scenes. // // collection.filter(function(model) &#123; return model.get(&#x27;age&#x27;) &gt; 10 &#125;); // collection.each(this.addView); // // `Function#apply` can be slow so we use the method&#x27;s arg count, if we know it. var addMethod = function(base, length, method, attribute) &#123; switch (length) &#123; case 1: return function() &#123; return base[method](this[attribute]); &#125;; case 2: return function(value) &#123; return base[method](this[attribute], value); &#125;; case 3: return function(iteratee, context) &#123; return base[method](this[attribute], cb(iteratee, this), context); &#125;; case 4: return function(iteratee, defaultVal, context) &#123; return base[method](this[attribute], cb(iteratee, this), defaultVal, context); &#125;; default: return function() &#123; var args = slice.call(arguments); args.unshift(this[attribute]); return base[method].apply(base, args); &#125;; &#125; &#125;; var addUnderscoreMethods = function(Class, base, methods, attribute) &#123; _.each(methods, function(length, method) &#123; if (base[method]) Class.prototype[method] = addMethod(base, length, method, attribute); &#125;); &#125;; // Support `collection.sortBy(&#x27;attr&#x27;)` and `collection.findWhere(&#123;id: 1&#125;)`. var cb = function(iteratee, instance) &#123; if (_.isFunction(iteratee)) return iteratee; if (_.isObject(iteratee) &amp;&amp; !instance._isModel(iteratee)) return modelMatcher(iteratee); if (_.isString(iteratee)) return function(model) &#123; return model.get(iteratee); &#125;; return iteratee; &#125;; var modelMatcher = function(attrs) &#123; var matcher = _.matches(attrs); return function(model) &#123; return matcher(model.attributes); &#125;; &#125;; // Underscore methods that we want to implement on the Collection. // 90% of the core usefulness of Backbone Collections is actually implemented // right here: var collectionMethods = &#123;forEach: 3, each: 3, map: 3, collect: 3, reduce: 0, foldl: 0, inject: 0, reduceRight: 0, foldr: 0, find: 3, detect: 3, filter: 3, select: 3, reject: 3, every: 3, all: 3, some: 3, any: 3, include: 3, includes: 3, contains: 3, invoke: 0, max: 3, min: 3, toArray: 1, size: 1, first: 3, head: 3, take: 3, initial: 3, rest: 3, tail: 3, drop: 3, last: 3, without: 0, difference: 0, indexOf: 3, shuffle: 1, lastIndexOf: 3, isEmpty: 1, chain: 1, sample: 3, partition: 3, groupBy: 3, countBy: 3, sortBy: 3, indexBy: 3, findIndex: 3, findLastIndex: 3&#125;; // Underscore methods that we want to implement on the Model, mapped to the // number of arguments they take. var modelMethods = &#123;keys: 1, values: 1, pairs: 1, invert: 1, pick: 0, omit: 0, chain: 1, isEmpty: 1&#125;; // Mix in each Underscore method as a proxy to `Collection#models`. _.each([ [Collection, collectionMethods, &#x27;models&#x27;], [Model, modelMethods, &#x27;attributes&#x27;] ], function(config) &#123; var Base = config[0], methods = config[1], attribute = config[2]; Base.mixin = function(obj) &#123; var mappings = _.reduce(_.functions(obj), function(memo, name) &#123; memo[name] = 0; return memo; &#125;, &#123;&#125;); addUnderscoreMethods(Base, obj, mappings, attribute); &#125;; addUnderscoreMethods(Base, _, methods, attribute); &#125;); // Backbone.sync // ------------- // Override this function to change the manner in which Backbone persists // models to the server. You will be passed the type of request, and the // model in question. By default, makes a RESTful Ajax request // to the model&#x27;s `url()`. Some possible customizations could be: // // * Use `setTimeout` to batch rapid-fire updates into a single request. // * Send up the models as XML instead of JSON. // * Persist models via WebSockets instead of Ajax. // // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests // as `POST`, with a `_method` parameter containing the true HTTP method, // as well as all requests with the body as `application/x-www-form-urlencoded` // instead of `application/json` with the model in a param named `model`. // Useful when interfacing with server-side languages like **PHP** that make // it difficult to read the body of `PUT` requests. Backbone.sync = function(method, model, options) &#123; var type = methodMap[method]; // Default options, unless specified. _.defaults(options || (options = &#123;&#125;), &#123; emulateHTTP: Backbone.emulateHTTP, emulateJSON: Backbone.emulateJSON &#125;); // Default JSON-request options. var params = &#123;type: type, dataType: &#x27;json&#x27;&#125;; // Ensure that we have a URL. if (!options.url) &#123; params.url = _.result(model, &#x27;url&#x27;) || urlError(); &#125; // Ensure that we have the appropriate request data. if (options.data == null &amp;&amp; model &amp;&amp; (method === &#x27;create&#x27; || method === &#x27;update&#x27; || method === &#x27;patch&#x27;)) &#123; params.contentType = &#x27;application/json&#x27;; params.data = JSON.stringify(options.attrs || model.toJSON(options)); &#125; // For older servers, emulate JSON by encoding the request into an HTML-form. if (options.emulateJSON) &#123; params.contentType = &#x27;application/x-www-form-urlencoded&#x27;; params.data = params.data ? &#123;model: params.data&#125; : &#123;&#125;; &#125; // For older servers, emulate HTTP by mimicking the HTTP method with `_method` // And an `X-HTTP-Method-Override` header. if (options.emulateHTTP &amp;&amp; (type === &#x27;PUT&#x27; || type === &#x27;DELETE&#x27; || type === &#x27;PATCH&#x27;)) &#123; params.type = &#x27;POST&#x27;; if (options.emulateJSON) params.data._method = type; var beforeSend = options.beforeSend; options.beforeSend = function(xhr) &#123; xhr.setRequestHeader(&#x27;X-HTTP-Method-Override&#x27;, type); if (beforeSend) return beforeSend.apply(this, arguments); &#125;; &#125; // Don&#x27;t process data on a non-GET request. if (params.type !== &#x27;GET&#x27; &amp;&amp; !options.emulateJSON) &#123; params.processData = false; &#125; // Pass along `textStatus` and `errorThrown` from jQuery. var error = options.error; options.error = function(xhr, textStatus, errorThrown) &#123; options.textStatus = textStatus; options.errorThrown = errorThrown; if (error) error.call(options.context, xhr, textStatus, errorThrown); &#125;; // Make the request, allowing the user to override any Ajax options. var xhr = options.xhr = Backbone.ajax(_.extend(params, options)); model.trigger(&#x27;request&#x27;, model, xhr, options); return xhr; &#125;; // Map from CRUD to HTTP for our default `Backbone.sync` implementation. var methodMap = &#123; create: &#x27;POST&#x27;, update: &#x27;PUT&#x27;, patch: &#x27;PATCH&#x27;, delete: &#x27;DELETE&#x27;, read: &#x27;GET&#x27; &#125;; // Set the default implementation of `Backbone.ajax` to proxy through to `$`. // Override this if you&#x27;d like to use a different library. Backbone.ajax = function() &#123; return Backbone.$.ajax.apply(Backbone.$, arguments); &#125;; // Backbone.Router // --------------- // Routers map faux-URLs to actions, and fire events when routes are // matched. Creating a new one sets its `routes` hash, if not set statically. var Router = Backbone.Router = function(options) &#123; options || (options = &#123;&#125;); this.preinitialize.apply(this, arguments); if (options.routes) this.routes = options.routes; this._bindRoutes(); this.initialize.apply(this, arguments); &#125;; // Cached regular expressions for matching named param parts and splatted // parts of route strings. var optionalParam = /\\((.*?)\\)/g; var namedParam = /(\\(\\?)?:\\w+/g; var splatParam = /\\*\\w+/g; var escapeRegExp = /[\\-&#123;&#125;\\[\\]+?.,\\\\\\^$|#\\s]/g; // Set up all inheritable **Backbone.Router** properties and methods. _.extend(Router.prototype, Events, &#123; // preinitialize is an empty function by default. You can override it with a function // or object. preinitialize will run before any instantiation logic is run in the Router. preinitialize: function()&#123;&#125;, // Initialize is an empty function by default. Override it with your own // initialization logic. initialize: function()&#123;&#125;, // Manually bind a single named route to a callback. For example: // // this.route(&#x27;search/:query/p:num&#x27;, &#x27;search&#x27;, function(query, num) &#123; // ... // &#125;); // route: function(route, name, callback) &#123; if (!_.isRegExp(route)) route = this._routeToRegExp(route); if (_.isFunction(name)) &#123; callback = name; name = &#x27;&#x27;; &#125; if (!callback) callback = this[name]; var router = this; Backbone.history.route(route, function(fragment) &#123; var args = router._extractParameters(route, fragment); if (router.execute(callback, args, name) !== false) &#123; router.trigger.apply(router, [&#x27;route:&#x27; + name].concat(args)); router.trigger(&#x27;route&#x27;, name, args); Backbone.history.trigger(&#x27;route&#x27;, router, name, args); &#125; &#125;); return this; &#125;, // Execute a route handler with the provided parameters. This is an // excellent place to do pre-route setup or post-route cleanup. execute: function(callback, args, name) &#123; if (callback) callback.apply(this, args); &#125;, // Simple proxy to `Backbone.history` to save a fragment into the history. navigate: function(fragment, options) &#123; Backbone.history.navigate(fragment, options); return this; &#125;, // Bind all defined routes to `Backbone.history`. We have to reverse the // order of the routes here to support behavior where the most general // routes can be defined at the bottom of the route map. _bindRoutes: function() &#123; if (!this.routes) return; this.routes = _.result(this, &#x27;routes&#x27;); var route, routes = _.keys(this.routes); while ((route = routes.pop()) != null) &#123; this.route(route, this.routes[route]); &#125; &#125;, // Convert a route string into a regular expression, suitable for matching // against the current location hash. _routeToRegExp: function(route) &#123; route = route.replace(escapeRegExp, &#x27;\\\\$&amp;&#x27;) .replace(optionalParam, &#x27;(?:$1)?&#x27;) .replace(namedParam, function(match, optional) &#123; return optional ? match : &#x27;([^/?]+)&#x27;; &#125;) .replace(splatParam, &#x27;([^?]*?)&#x27;); return new RegExp(&#x27;^&#x27; + route + &#x27;(?:\\\\?([\\\\s\\\\S]*))?$&#x27;); &#125;, // Given a route, and a URL fragment that it matches, return the array of // extracted decoded parameters. Empty or unmatched parameters will be // treated as `null` to normalize cross-browser behavior. _extractParameters: function(route, fragment) &#123; var params = route.exec(fragment).slice(1); return _.map(params, function(param, i) &#123; // Don&#x27;t decode the search params. if (i === params.length - 1) return param || null; return param ? decodeURIComponent(param) : null; &#125;); &#125; &#125;); // Backbone.History // ---------------- // Handles cross-browser history management, based on either // [pushState](http://diveintohtml5.info/history.html) and real URLs, or // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange) // and URL fragments. If the browser supports neither (old IE, natch), // falls back to polling. var History = Backbone.History = function() &#123; this.handlers = []; this.checkUrl = this.checkUrl.bind(this); // Ensure that `History` can be used outside of the browser. if (typeof window !== &#x27;undefined&#x27;) &#123; this.location = window.location; this.history = window.history; &#125; &#125;; // Cached regex for stripping a leading hash/slash and trailing space. var routeStripper = /^[#\\/]|\\s+$/g; // Cached regex for stripping leading and trailing slashes. var rootStripper = /^\\/+|\\/+$/g; // Cached regex for stripping urls of hash. var pathStripper = /#.*$/; // Has the history handling already been started? History.started = false; // Set up all inheritable **Backbone.History** properties and methods. _.extend(History.prototype, Events, &#123; // The default interval to poll for hash changes, if necessary, is // twenty times a second. interval: 50, // Are we at the app root? atRoot: function() &#123; var path = this.location.pathname.replace(/[^\\/]$/, &#x27;$&amp;/&#x27;); return path === this.root &amp;&amp; !this.getSearch(); &#125;, // Does the pathname match the root? matchRoot: function() &#123; var path = this.decodeFragment(this.location.pathname); var rootPath = path.slice(0, this.root.length - 1) + &#x27;/&#x27;; return rootPath === this.root; &#125;, // Unicode characters in `location.pathname` are percent encoded so they&#x27;re // decoded for comparison. `%25` should not be decoded since it may be part // of an encoded parameter. decodeFragment: function(fragment) &#123; return decodeURI(fragment.replace(/%25/g, &#x27;%2525&#x27;)); &#125;, // In IE6, the hash fragment and search params are incorrect if the // fragment contains `?`. getSearch: function() &#123; var match = this.location.href.replace(/#.*/, &#x27;&#x27;).match(/\\?.+/); return match ? match[0] : &#x27;&#x27;; &#125;, // Gets the true hash value. Cannot use location.hash directly due to bug // in Firefox where location.hash will always be decoded. getHash: function(window) &#123; var match = (window || this).location.href.match(/#(.*)$/); return match ? match[1] : &#x27;&#x27;; &#125;, // Get the pathname and search params, without the root. getPath: function() &#123; var path = this.decodeFragment( this.location.pathname + this.getSearch() ).slice(this.root.length - 1); return path.charAt(0) === &#x27;/&#x27; ? path.slice(1) : path; &#125;, // Get the cross-browser normalized URL fragment from the path or hash. getFragment: function(fragment) &#123; if (fragment == null) &#123; if (this._usePushState || !this._wantsHashChange) &#123; fragment = this.getPath(); &#125; else &#123; fragment = this.getHash(); &#125; &#125; return fragment.replace(routeStripper, &#x27;&#x27;); &#125;, // Start the hash change handling, returning `true` if the current URL matches // an existing route, and `false` otherwise. start: function(options) &#123; if (History.started) throw new Error(&#x27;Backbone.history has already been started&#x27;); History.started = true; // Figure out the initial configuration. Do we need an iframe? // Is pushState desired ... is it available? this.options = _.extend(&#123;root: &#x27;/&#x27;&#125;, this.options, options); this.root = this.options.root; this._wantsHashChange = this.options.hashChange !== false; this._hasHashChange = &#x27;onhashchange&#x27; in window &amp;&amp; (document.documentMode === void 0 || document.documentMode &gt; 7); this._useHashChange = this._wantsHashChange &amp;&amp; this._hasHashChange; this._wantsPushState = !!this.options.pushState; this._hasPushState = !!(this.history &amp;&amp; this.history.pushState); this._usePushState = this._wantsPushState &amp;&amp; this._hasPushState; this.fragment = this.getFragment(); // Normalize root to always include a leading and trailing slash. this.root = (&#x27;/&#x27; + this.root + &#x27;/&#x27;).replace(rootStripper, &#x27;/&#x27;); // Transition from hashChange to pushState or vice versa if both are // requested. if (this._wantsHashChange &amp;&amp; this._wantsPushState) &#123; // If we&#x27;ve started off with a route from a `pushState`-enabled // browser, but we&#x27;re currently in a browser that doesn&#x27;t support it... if (!this._hasPushState &amp;&amp; !this.atRoot()) &#123; var rootPath = this.root.slice(0, -1) || &#x27;/&#x27;; this.location.replace(rootPath + &#x27;#&#x27; + this.getPath()); // Return immediately as browser will do redirect to new url return true; // Or if we&#x27;ve started out with a hash-based route, but we&#x27;re currently // in a browser where it could be `pushState`-based instead... &#125; else if (this._hasPushState &amp;&amp; this.atRoot()) &#123; this.navigate(this.getHash(), &#123;replace: true&#125;); &#125; &#125; // Proxy an iframe to handle location events if the browser doesn&#x27;t // support the `hashchange` event, HTML5 history, or the user wants // `hashChange` but not `pushState`. if (!this._hasHashChange &amp;&amp; this._wantsHashChange &amp;&amp; !this._usePushState) &#123; this.iframe = document.createElement(&#x27;iframe&#x27;); this.iframe.src = &#x27;javascript:0&#x27;; this.iframe.style.display = &#x27;none&#x27;; this.iframe.tabIndex = -1; var body = document.body; // Using `appendChild` will throw on IE &lt; 9 if the document is not ready. var iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow; iWindow.document.open(); iWindow.document.close(); iWindow.location.hash = &#x27;#&#x27; + this.fragment; &#125; // Add a cross-platform `addEventListener` shim for older browsers. var addEventListener = window.addEventListener || function(eventName, listener) &#123; return attachEvent(&#x27;on&#x27; + eventName, listener); &#125;; // Depending on whether we&#x27;re using pushState or hashes, and whether // &#x27;onhashchange&#x27; is supported, determine how we check the URL state. if (this._usePushState) &#123; addEventListener(&#x27;popstate&#x27;, this.checkUrl, false); &#125; else if (this._useHashChange &amp;&amp; !this.iframe) &#123; addEventListener(&#x27;hashchange&#x27;, this.checkUrl, false); &#125; else if (this._wantsHashChange) &#123; this._checkUrlInterval = setInterval(this.checkUrl, this.interval); &#125; if (!this.options.silent) return this.loadUrl(); &#125;, // Disable Backbone.history, perhaps temporarily. Not useful in a real app, // but possibly useful for unit testing Routers. stop: function() &#123; // Add a cross-platform `removeEventListener` shim for older browsers. var removeEventListener = window.removeEventListener || function(eventName, listener) &#123; return detachEvent(&#x27;on&#x27; + eventName, listener); &#125;; // Remove window listeners. if (this._usePushState) &#123; removeEventListener(&#x27;popstate&#x27;, this.checkUrl, false); &#125; else if (this._useHashChange &amp;&amp; !this.iframe) &#123; removeEventListener(&#x27;hashchange&#x27;, this.checkUrl, false); &#125; // Clean up the iframe if necessary. if (this.iframe) &#123; document.body.removeChild(this.iframe); this.iframe = null; &#125; // Some environments will throw when clearing an undefined interval. if (this._checkUrlInterval) clearInterval(this._checkUrlInterval); History.started = false; &#125;, // Add a route to be tested when the fragment changes. Routes added later // may override previous routes. route: function(route, callback) &#123; this.handlers.unshift(&#123;route: route, callback: callback&#125;); &#125;, // Checks the current URL to see if it has changed, and if it has, // calls `loadUrl`, normalizing across the hidden iframe. checkUrl: function(e) &#123; var current = this.getFragment(); // If the user pressed the back button, the iframe&#x27;s hash will have // changed and we should use that for comparison. if (current === this.fragment &amp;&amp; this.iframe) &#123; current = this.getHash(this.iframe.contentWindow); &#125; if (current === this.fragment) return false; if (this.iframe) this.navigate(current); this.loadUrl(); &#125;, // Attempt to load the current URL fragment. If a route succeeds with a // match, returns `true`. If no defined routes matches the fragment, // returns `false`. loadUrl: function(fragment) &#123; // If the root doesn&#x27;t match, no routes can match either. if (!this.matchRoot()) return false; fragment = this.fragment = this.getFragment(fragment); return _.some(this.handlers, function(handler) &#123; if (handler.route.test(fragment)) &#123; handler.callback(fragment); return true; &#125; &#125;); &#125;, // Save a fragment into the hash history, or replace the URL state if the // &#x27;replace&#x27; option is passed. You are responsible for properly URL-encoding // the fragment in advance. // // The options object can contain `trigger: true` if you wish to have the // route callback be fired (not usually desirable), or `replace: true`, if // you wish to modify the current URL without adding an entry to the history. navigate: function(fragment, options) &#123; if (!History.started) return false; if (!options || options === true) options = &#123;trigger: !!options&#125;; // Normalize the fragment. fragment = this.getFragment(fragment || &#x27;&#x27;); // Don&#x27;t include a trailing slash on the root. var rootPath = this.root; if (fragment === &#x27;&#x27; || fragment.charAt(0) === &#x27;?&#x27;) &#123; rootPath = rootPath.slice(0, -1) || &#x27;/&#x27;; &#125; var url = rootPath + fragment; // Strip the fragment of the query and hash for matching. fragment = fragment.replace(pathStripper, &#x27;&#x27;); // Decode for matching. var decodedFragment = this.decodeFragment(fragment); if (this.fragment === decodedFragment) return; this.fragment = decodedFragment; // If pushState is available, we use it to set the fragment as a real URL. if (this._usePushState) &#123; this.history[options.replace ? &#x27;replaceState&#x27; : &#x27;pushState&#x27;](&#123;&#125;, document.title, url); // If hash changes haven&#x27;t been explicitly disabled, update the hash // fragment to store history. &#125; else if (this._wantsHashChange) &#123; this._updateHash(this.location, fragment, options.replace); if (this.iframe &amp;&amp; fragment !== this.getHash(this.iframe.contentWindow)) &#123; var iWindow = this.iframe.contentWindow; // Opening and closing the iframe tricks IE7 and earlier to push a // history entry on hash-tag change. When replace is true, we don&#x27;t // want this. if (!options.replace) &#123; iWindow.document.open(); iWindow.document.close(); &#125; this._updateHash(iWindow.location, fragment, options.replace); &#125; // If you&#x27;ve told us that you explicitly don&#x27;t want fallback hashchange- // based history, then `navigate` becomes a page refresh. &#125; else &#123; return this.location.assign(url); &#125; if (options.trigger) return this.loadUrl(fragment); &#125;, // Update the hash location, either replacing the current entry, or adding // a new one to the browser history. _updateHash: function(location, fragment, replace) &#123; if (replace) &#123; var href = location.href.replace(/(javascript:|#).*$/, &#x27;&#x27;); location.replace(href + &#x27;#&#x27; + fragment); &#125; else &#123; // Some browsers require that `hash` contains a leading #. location.hash = &#x27;#&#x27; + fragment; &#125; &#125; &#125;); // Create the default Backbone.history. Backbone.history = new History; // Helpers // ------- // Helper function to correctly set up the prototype chain for subclasses. // Similar to `goog.inherits`, but uses a hash of prototype properties and // class properties to be extended. var extend = function(protoProps, staticProps) &#123; var parent = this; var child; // The constructor function for the new subclass is either defined by you // (the &quot;constructor&quot; property in your `extend` definition), or defaulted // by us to simply call the parent constructor. if (protoProps &amp;&amp; _.has(protoProps, &#x27;constructor&#x27;)) &#123; child = protoProps.constructor; &#125; else &#123; child = function()&#123; return parent.apply(this, arguments); &#125;; &#125; // Add static properties to the constructor function, if supplied. _.extend(child, parent, staticProps); // Set the prototype chain to inherit from `parent`, without calling // `parent`&#x27;s constructor function and add the prototype properties. child.prototype = _.create(parent.prototype, protoProps); child.prototype.constructor = child; // Set a convenience property in case the parent&#x27;s prototype is needed // later. child.__super__ = parent.prototype; return child; &#125;; // Set up inheritance for the model, collection, router, view and history. Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend; // Throw an error when a URL is needed, and none is supplied. var urlError = function() &#123; throw new Error(&#x27;A &quot;url&quot; property or function must be specified&#x27;); &#125;; // Wrap an optional error callback with a fallback error event. var wrapError = function(model, options) &#123; var error = options.error; options.error = function(resp) &#123; if (error) error.call(options.context, model, resp, options); model.trigger(&#x27;error&#x27;, model, resp, options); &#125;; &#125;; return Backbone;&#125;);","categories":[],"tags":[{"name":"源码","slug":"源码","permalink":"https://wisiw.github.io.git/tags/%E6%BA%90%E7%A0%81/"},{"name":"backbone.js","slug":"backbone-js","permalink":"https://wisiw.github.io.git/tags/backbone-js/"}]},{"title":"【JavaScript】forEach、map、reduce、filter的区别","slug":"【JavaScript】forEach、map、reduce、filter的区别","date":"2021-08-30T03:43:43.000Z","updated":"2021-09-23T06:20:04.416Z","comments":true,"path":"2021/08/30/【JavaScript】forEach、map、reduce、filter的区别/","link":"","permalink":"https://wisiw.github.io.git/2021/08/30/%E3%80%90JavaScript%E3%80%91forEach%E3%80%81map%E3%80%81reduce%E3%80%81filter%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"forEach 循环数组 return只能打断当前循环中的执行的代码，不能打断循环本身；不支持continue 与 break map 循环数组，返回新数组 return会改变返回数组 reduce 循环数组，依次相加 filter 循环数组，根据条件返回新数组 some every","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wisiw.github.io.git/tags/JavaScript/"}]},{"title":"【架构】前端工程化（二）：添加路由","slug":"【架构】前端工程化（二）：添加路由","date":"2021-08-13T03:41:46.000Z","updated":"2021-08-13T03:51:27.296Z","comments":true,"path":"2021/08/13/【架构】前端工程化（二）：添加路由/","link":"","permalink":"https://wisiw.github.io.git/2021/08/13/%E3%80%90%E6%9E%B6%E6%9E%84%E3%80%91%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%B7%BB%E5%8A%A0%E8%B7%AF%E7%94%B1/","excerpt":"","text":"目录结构 1234567└── src ├── config │ └── router.js ├── router │ └── index.js └── APP.vue └── main.js 1.创建公共路由12345678// src/config/router.jsexport default [ &#123; path: &#x27;/alert&#x27;, name: &#x27;alert&#x27;, component: () =&gt; import(&#x27;module_vue/packages/alert&#x27;) &#125;] 2.引用公共路由123456789101112// src/router/index.jsimport Vue from &#x27;vue&#x27;import VueRouter from &#x27;vue-router&#x27;import commonRouter from &#x27;../config/router&#x27;Vue.use(VueRouter)const router = new VueRouter(&#123; routes: commonRouter, mode: &#x27;hash&#x27;, // default: hash ,history&#125;)export default router 3.项目中引入路由123456789// src/main.jsimport Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router/index&#x27;new Vue(&#123; router, render: h =&gt; h(App),&#125;).$mount(&#x27;#app&#x27;) 12345678910111213141516// src/App.vue&lt;template&gt; &lt;div&gt; &lt;router-view /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;App&#x27;, components: &#123; &#125;, mounted() &#123; &#125;&#125;&lt;/script&gt;","categories":[],"tags":[{"name":"架构","slug":"架构","permalink":"https://wisiw.github.io.git/tags/%E6%9E%B6%E6%9E%84/"},{"name":"前端工程化","slug":"前端工程化","permalink":"https://wisiw.github.io.git/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}]},{"title":"【架构】SystemJS VS Webpack","slug":"【架构】SystemJS VS Webpack","date":"2021-08-13T03:07:02.000Z","updated":"2022-11-06T20:34:38.658Z","comments":true,"path":"2021/08/13/【架构】SystemJS VS Webpack/","link":"","permalink":"https://wisiw.github.io.git/2021/08/13/%E3%80%90%E6%9E%B6%E6%9E%84%E3%80%91SystemJS%20VS%20Webpack/","excerpt":"","text":"功能 | SystemJS|Webpack | 说明 –|–|–|–|–|| 自启动HTML页面 | 支持 | 支持 | 需服务器支持（lite-server或webpack-dev-server）| 模块化开发 | 支持 | 支持 | TypeScipt语言支持模块化开发| 严格类型检测 | 支持 | 支持 | 通过TypeScript的tsconfig.json配置获取| 断点调试 | 支持 | 支持 | 需要浏览器调试插件| 解决跨域问题 | 支持 | 支持 | 需服务器支持（lite-server或webpack-dev-server）| 热更新 | 支持（在SystemJS中，修改HTML或CSS源码并保存后，会立即自动重载刷新页面） | 需要css-loader、style-loader、html-webpack-plugin等插件 | 需服务器支持（lite-server或webpack-dev-server）| 自动重新编译（转译）TypeScript | 支持 | 支持 | SystemJS和Webpack内置了该功能，但都需要手动刷新页面运行更新后的代码| 打包压缩源码 | 不支持 | 支持 | SystemJS是加载器，二Webpack是打包器 最大的不同： 在SystemJs中，index.html引入的是 12&lt;script src=&quot;node_modules/systemjs/system.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;node_modules/typescript/lib/typescript.js&quot;&gt;&lt;/script&gt; 在Webpack中，index.html引入的是 1&lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt; 由上可见，SystemJS是在页面载入时进行TypeScript源码的编译（转译），因此它是一个加载器 而Webpack是在后台进行编译（转译）和打包操作的，生成bundle.js。HTML直接执行打包后的JS资源。 因此就运行效率及内存消耗来说，Webpack更具优势","categories":[],"tags":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://wisiw.github.io.git/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"SysemJS","slug":"SysemJS","permalink":"https://wisiw.github.io.git/tags/SysemJS/"}]},{"title":"【架构】前端工程化（一）业务模块拆分,独立成npm包","slug":"【架构】前端工程化（一）：业务模块拆分-独立成npm包","date":"2021-08-13T03:07:02.000Z","updated":"2022-03-23T05:54:26.219Z","comments":true,"path":"2021/08/13/【架构】前端工程化（一）：业务模块拆分-独立成npm包/","link":"","permalink":"https://wisiw.github.io.git/2021/08/13/%E3%80%90%E6%9E%B6%E6%9E%84%E3%80%91%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%B8%9A%E5%8A%A1%E6%A8%A1%E5%9D%97%E6%8B%86%E5%88%86-%E7%8B%AC%E7%AB%8B%E6%88%90npm%E5%8C%85/","excerpt":"","text":"1.构建业务模块npm包123mkdir module_vuecd module_vuenpm init -y 文件目录1234567├── packages│ └── alert│ ├── src│ │ └── main.vue│ └── index.js└── src └── index.js 模块 123456789101112131415161718// packages/alert/src/main.vue&lt;template&gt; &lt;div&gt;alert&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;Alert&quot;, data() &#123; return &#123; &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 导出模块 12345678// packages/alert/index.jsimport Alert from &#x27;./src/main&#x27;;Alert.install = function(Vue) &#123; Vue.component(Alert.name, Alert);&#125;;export default Alert; VUE中注册模块组件 123456789101112131415161718192021222324// src/index.jsimport Alert from &#x27;../packages/alert/index.js&#x27;;const components = [ Alert];const install = function(Vue) &#123; components.forEach(component =&gt; &#123; Vue.component(component.name, component); &#125;);&#125;;/* istanbul ignore if */if (typeof window !== &#x27;undefined&#x27; &amp;&amp; window.Vue) &#123; install(window.Vue);&#125;export default &#123; version: &#x27;0.1.0&#x27;, install, Alert&#125;; 2.项目引用本地模块npm包2.1 webpack 4.X 开始，需要安装 webpack-cli 依赖1npm install webpack webpack-cli -g 2.2 如果未安装vue-cli，全局安装1npm install --global vue-cli 2.3 创建项目12vue create projectcd project 2.4 安装本地npm包1npm install &lt;package path&gt;/module_vue 2.5 建立npm本地映射，此操作是为了方便开发1npm link module_vue 此操作可以将node_modules中的module_vue链接到本地module_vue，实时更新","categories":[],"tags":[{"name":"架构","slug":"架构","permalink":"https://wisiw.github.io.git/tags/%E6%9E%B6%E6%9E%84/"},{"name":"前端工程化","slug":"前端工程化","permalink":"https://wisiw.github.io.git/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}]},{"title":"【原理】响应式原理","slug":"【原理】响应式原理","date":"2021-08-11T06:12:09.000Z","updated":"2021-11-18T05:38:53.630Z","comments":true,"path":"2021/08/11/【原理】响应式原理/","link":"","permalink":"https://wisiw.github.io.git/2021/08/11/%E3%80%90%E5%8E%9F%E7%90%86%E3%80%91%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const data = &#123; price: 10, quantity: 2&#125;// 创建一个收集依赖项（依赖）并重新运行所有依赖项（通知）的Dep 类class Dep &#123; constructor () &#123; this.subscribers = [] &#125; depend () &#123; if (target &amp;&amp; !this.subscribers.includes(target)) &#123; this.subscribers.push(target) &#125; &#125; notify () &#123; this.subscribers.forEach(sub =&gt; sub()) &#125;&#125;// 使用Object.defineProperty()创建 getter 和 setterObject.keys(data).forEach( key =&gt; &#123; let internalValue = data[key] const dep = new Dep() Object.defineProperty( data, key, &#123; get () &#123; dep.depend() return internalValue &#125;, set (newV) &#123; internalValue = newV dep.notify() &#125; &#125;)&#125;)// 创建一个观察者来管理我们正在运行的代码，这可能需要作为依赖项添加（目标）function watcher(myFunc) &#123; target = myFunc target() target = null&#125;watcher(() =&gt; &#123; data.total = data.price * data.quantity&#125;)data.price = 20console.log(data.total)","categories":[],"tags":[{"name":"响应式","slug":"响应式","permalink":"https://wisiw.github.io.git/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"},{"name":"原理","slug":"原理","permalink":"https://wisiw.github.io.git/tags/%E5%8E%9F%E7%90%86/"}]},{"title":"【面试题】基础、业务、笔试","slug":"【面试题】基础、业务、笔试","date":"2021-08-09T08:02:48.000Z","updated":"2021-08-09T08:03:19.090Z","comments":true,"path":"2021/08/09/【面试题】基础、业务、笔试/","link":"","permalink":"https://wisiw.github.io.git/2021/08/09/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%91%E5%9F%BA%E7%A1%80%E3%80%81%E4%B8%9A%E5%8A%A1%E3%80%81%E7%AC%94%E8%AF%95/","excerpt":"","text":"面试题。 基础知识基础知识主要包含以下几个方面： 基础：计算机原理、编译原理、数据结构、算法、设计模式、编程范式等基本知识了解 语法：JavaScript、ECMAScript、CSS、TypeScript、HTML、Node.js 等语法的了解和使用 框架：React、Vue、Egg、Koa、Express、Webpack 等原理的了解和使用 工程：编译工具、格式工具、Git、NPM、单元测试、Nginx、PM2、CI / CD 了解和使用 网络：HTTP、TCP、UDP、WebSocket、Cookie、Session、跨域、缓存、协议的了解 性能：编译性能、监控、白屏检测、SEO、Service Worker 等了解 插件：Chrome 、Vue CLI 、Webpack 等插件设计思路的理解 系统：Mac、Windows、Linux 系统配置的实践 后端：Redis 缓存、数据库、Graphql、SSR、模板引擎等了解和使用 基础 列举你所了解的计算机存储设备类型？ 一般代码存储在计算机的哪个设备中？代码在 CPU 中是如何运行的？ 什么是指令和指令集？ 复杂指令集和精简指令集有什么区别？ JavaScript 是如何运行的？解释型语言和编译型语言的差异是什么？ 简单描述一下 Babel 的编译过程？ JavaScript 中的数组和函数在内存中是如何存储的？ 浏览器和 Node.js 中的事件循环机制有什么区别？ ES6 Modules 相对于 CommonJS 的优势是什么？ 高级程序设计语言是如何编译成机器语言的？ 编译器一般由哪几个阶段组成？数据类型检查一般在什么阶段进行？ 编译过程中虚拟机的作用是什么？ 什么是中间代码（IR），它的作用是什么？ 什么是交叉编译？ 发布 / 订阅模式和观察者模式的区别是什么？ 装饰器模式一般会在什么场合使用？ 谈谈你对大型项目的代码解耦设计理解？什么是 Ioc？一般 DI 采用什么设计模式实现？ 列举你所了解的编程范式？ 什么是面向切面（AOP）的编程？ 什么是函数式编程？什么是响应式编程？什么是函数响应式编程？ 响应式编程或者函数响应式编程的使用场景有哪些？ 语法 如何实现一个上中下三行布局，顶部和底部最小高度是 100px，中间自适应? 如何判断一个元素 CSS 样式溢出，从而可以选择性的加 title 或者 Tooltip? 如何让 CSS 元素左侧自动溢出（… 溢出在左侧）？ 什么是沙箱？浏览器的沙箱有什么作用？ 如何处理浏览器中表单项的密码自动填充问题？ Hash 和 History 路由的区别和优缺点？ JavaScript 中的 const 数组可以进行 push 操作吗？为什么？ JavaScript 中对象的属性描述符有哪些？分别有什么作用？ JavaScript 中 console 有哪些 api ? 简单对比一下 Callback、Promise、Generator、Async 几个异步 API 的优劣？ Object.defineProperty 有哪几个参数？各自都有什么作用？ Object.defineProperty 和 ES6 的 Proxy 有什么区别？ ES6 中 Symbol、Map、Decorator 的使用场景有哪些？或者你在哪些库的源码里见过这些 API 的使用？ 为什么要使用 TypeScript ? TypeScript 相对于 JavaScript 的优势是什么？ TypeScript 中 const 和 readonly 的区别？枚举和常量枚举的区别？接口和类型别名的区别？ TypeScript 中 any 类型的作用是什么？ TypeScript 中 any、never、unknown 和 void 有什么区别？ TypeScript 中 interface 可以给 Function / Array / Class（Indexable）做声明吗？ TypeScript 中可以使用 String、Number、Boolean、Symbol、Object 等给类型做声明吗？ TypeScript 中的 this 和 JavaScript 中的 this 有什么差异？ TypeScript 中使用 Unions 时有哪些注意事项？ TypeScript 如何设计 Class 的声明？ TypeScript 中如何联合枚举类型的 Key? TypeScript 中 ?.、??、!.、_、** 等符号的含义？ TypeScript 中预定义的有条件类型有哪些？ 简单介绍一下 TypeScript 模块的加载机制？ 简单聊聊你对 TypeScript 类型兼容性的理解？抗变、双变、协变和逆变的简单理解？ TypeScript 中对象展开会有什么副作用吗？ TypeScript 中 interface、type、enum 声明有作用域的功能吗？ TypeScript 中同名的 interface 或者同名的 interface 和 class 可以合并吗？ 如何使 TypeScript 项目引入并识别编译为 JavaScript 的 npm 库包？ TypeScript 的 tsconfig.json 中有哪些配置项信息？ TypeScript 中如何设置模块导入的路径别名？ 框架 React Class 组件有哪些周期函数？分别有什么作用？ React Class 组件中请求可以在 componentWillMount 中发起吗？为什么？ React Class 组件和 React Hook 的区别有哪些？ React 中高阶函数和自定义 Hook 的优缺点？ 简要说明 React Hook 中 useState 和 useEffect 的运行原理？ React 如何发现重渲染、什么原因容易造成重渲染、如何避免重渲染？ React Hook 中 useEffect 有哪些参数，如何检测数组依赖项的变化？ React 的 useEffect 是如何监听数组依赖项的变化的？ React Hook 和闭包有什么关联关系？ React 中 useState 是如何做数据初始化的？ 列举你常用的 React 性能优化技巧？ Vue 2.x 模板中的指令是如何解析实现的？ 简要说明 Vue 2.x 的全链路运作机制？ 简单介绍一下 Element UI 的框架设计？ 如何理解 Vue 是一个渐进式框架？ Vue 里实现跨组件通信的方式有哪些？ Vue 中响应式数据是如何做到对某个对象的深层次属性的监听的？ MVVM、MVC 和 MVP 的区别是什么？各自有什么应用场景？、 什么是 MVVM 框架？ 工程 Vue CLI 3.x 有哪些功能？Vue CLI 3.x 的插件系统了解？ Vue CLI 3.x 中的 Webpack 是如何组装处理的？ Vue 2.x 如何支持 TypeScript 语法？ 如何配置环境使得 JavaScript 项目可以支持 TypeScript 语法？ 如何对 TypeScript 进行 Lint 校验？ESLint 和 TSLint 有什么区别？ Node.js 如何支持 TypeScript 语法？ TypeScript 如何自动生成库包的声明文件？ Babel 对于 TypeScript 的支持有哪些限制？ Webpack 中 Loader 和 Plugin 的区别是什么？ 在 Webpack 中是如何做到支持类似于 JSX 语法的 Sourcemap 定位？ 发布 Npm 包如何指定引入地址？ 如何发布开发项目的特定文件夹为 Npm 包的根目录？ 如何发布一个支持 Tree Shaking 机制的 Npm 包？ Npm 包中 peerDependencies 的作用是什么？ 如何优雅的调试需要发布的 Npm 包？ 在设计一些库包时如何生成版本日志？ 了解 Git （Submodule）子模块吗？简单介绍一下 Git 子模块的作用？ Git 如何修改已经提交的 Commit 信息？ Git 如何撤销 Commit 并保存之前的修改？ Git 如何 ignore 被 commit 过的文件？ 在使用 Git 的时候如何规范 Git 的提交说明（Commit 信息）？ 简述符合 Angular 规范的提交说明的结构组成？ Commit 信息如何和 Github Issues 关联？ Git Hook 在项目中哪些作用？ Git Hook 中客户端和服务端钩子各自用于什么作用？ Git Hook 中常用的钩子有哪些？ pre-commit 和 commit-msg 钩子的区别是什么？各自可用于做什么？ husky 以及 ghook 等工具制作 Git Hook 的原理是什么？ 如何设计一个通用的 Git Hook ？ Git Hook 可以采用 Node 脚本进行设计吗？如何做到？ 如何确保别人上传的代码没有 Lint 错误？如何确保代码构建没有 Lint 错误？ 如何在 Vs Code 中进行 Lint 校验提示？如何在 Vs Code 中进行 Lint 保存格式化？ ESLint 和 Prettier 的区别是什么？两者在一起工作时会产生问题吗？ 如何有效的识别 ESLint 和 Prettier 可能产生冲突的格式规则？如何解决此类规则冲突问题？ 在通常的脚手架项目中进行热更新（hot module replacement）时如何做到 ESLint 实时打印校验错误信息？ 谈谈你对 SourceMap 的了解？ 如何调试 Node.js 代码？如何调试 Node.js TypeScript 代码？在浏览器中如何调试 Node.js 代码？ 列举你知道的所有构建工具并说说这些工具的优缺点？这些构建工具在不同的场景下应该如何选型？ VS Code 配置中的用户和工作区有什么区别？ VS Code 的插件可以只对当前项目生效吗？ 你所知道的测试有哪些测试类型？ 你所知道的测试框架有哪些？ 什么是 e2e 测试？有哪些 e2e 的测试框架？ 假设现在有一个插入排序算法，如何对该算法进行单元测试？ 网络 CDN 服务如何实现网络加速？ WebSocket 使用的是 TCP 还是 UDP 协议？ 什么是单工、半双工和全双工通信？ 简单描述 HTTP 协议发送一个带域名的 URL 请求的协议传输过程？（DNS、TCP、IP、链路） 什么是正向代理？什么是反向代理？ Cookie 可以在服务端生成吗？Cookie 在服务端生成后的工作流程是什么样的？ Session、Cookie 的区别和关联？如何进行临时性和永久性的 Session 存储？ 设置 Cookie 时候如何防止 XSS 攻击？ 简单描述一下用户免登陆的实现过程？可能会出现哪些安全性问题？一般如何对用户登录的密码进行加密？ HTTP 中提升传输速率的方式有哪些？常用的内容编码方式有哪些？ 传输图片的过程中如果突然中断，如何在恢复后从之前的中断中恢复传输？ 什么是代理？什么是网关？代理和网关的作用是什么？ HTTPS 相比 HTTP 为什么更加安全可靠？ 什么是对称密钥（共享密钥）加密？什么是非对称密钥（公开密钥）加密？哪个更加安全？ 你觉得 HTTP 协议目前存在哪些缺点？ 性能 在 React 中如何识别一个表单项里的表单做到了最小粒度 / 代价的渲染？ 在 React 的开发的过程中你能想到哪些控制渲染成本的方法？ 插件 Vue CLI 3.x 的插件系统是如何设计的？ Webpack 中的插件机制是如何设计的？ 系统 \\r\\n（CRLF） 和 \\n （LF）的区别是什么？(Vs Code 的右下角可以切换) /dev/null 的作用是啥？ 如何在 Mac 的终端中设置一个命令的别名？ 如何在 Windows 中设置环境变量？ Mac 的文件操作系统默认区分文件路径的大小写吗？ 编写 Shell 脚本时如何设置文件的绝对路径？ 后端 Session、Cookie 的区别和关联？如何进行临时性和永久性的 Session 存储？ 如何部署 Node.js 应用？如何处理负载均衡中 Session 的一致性问题？ 如何提升 Node.js 代码的运行稳定性？ GraphQL 与 Restful 的区别，它有什么优点？ Vue SSR 的工作原理？Vuex 的数据如何同构渲染？ SSR 技术和 SPA 技术的各自的优缺点是什么？ 如何处理 Node.js 渲染 HTML 压力过大问题？ 业务思考业务思考更多的是结合基础知识的广度和深度进行的具体业务实践，主要包含以下几个方面： 工程化：代码部署、CI / CD 流程设计、Jenkins、Gitlab、Docker 等 通用性：脚手架、SDK、组件库等框架设计 应用框架：Hybrid 混合、微前端、BFF、Monorepo 可视化： 低代码：通用表单设计、通用布局设计、通用页面设计、JSON Schema 协议设计等 测试：E2E 测试、单元测试、测试覆盖率、测试报告等 业务：数据、体验、复杂度、监控 工程化 你所知道的 CI / CD 工具有哪些？在项目中有接触过类似的流程吗？ 如果让你实现一个 Web 前端的 CI / CD 工程研发平台，你会如何设计？ 如果我们需要将已有项目中的线上产物资源（例如图片）转换成本地私有化资源，你有什么解决方案？ 如何使用 Vue CLI 3.x 定制一个脚手架？比如内部自动集成了 i18n、 axios、Element UI、路由守卫等？ Jenkins 如何配合 Node.js 脚本进行 CI / CD 设计？ 通用性 如果让你设计一个通用的项目脚手架，你会如何设计？一个通用的脚手架一般需要具备哪些能力？ 如果让你设计一个通用的工具库，你会如何设计？一个通用的工具库一般需要具备哪些能力？ 假设你自己实现的 React 或 Vue 的组件库要设计演示文档，你会如何设计？设计的文档需要实现哪些功能？ 在设计工具库包的时候你是如何设计 API 文档的？ 应用框架 谈谈 Electron、Nw.js、CEF、Flutter 和原生开发的理解？ 谈谈桌面端应用中 HotFix 的理解？ 你觉得什么样的场景需要使用微前端框架？ 业务 什么是单点登录？如何做单点登录？ 如何做一个项目的国际化方案？ 如何做一个项目的监控和埋点方案？ 如何建设项目的稳定性（监控、灰度、错误降级、回滚…）？ 一般管理后台型的应用需要考虑哪些性能方面的优化？ 简述一些提升项目体验的案例和技术方案（骨架屏、Loading 处理、缓存、错误降级、请求重试…）？ 假设需要对页面设计一个水印方案，你会如何设计？ 低代码 如何设计一个通用的 JSON Schema 协议使其可以动态渲染一个通用的联动表单？ 一般的低代码平台需要具备哪些能力？ 笔试实践笔试更多的是考验应聘者的逻辑思维能力和代码书写风格，主要包含以下几个方面： 正则表达式 算法 数据结构 设计模式 框架的部分原理实现 TypeScript 语法 模板解析 数据结构 使用 TypeScript 语法将没有层级的扁平数据转换成树形结构的数据 12345678910111213141516171819202122232425262728// 扁平数据[&#123; name: &#x27;文本1&#x27;, parent: null, id: 1,&#125;, &#123; name: &#x27;文本2&#x27;, id: 2, parent: 1&#125;, &#123; name: &#x27;文本3&#x27;, parent: 2, id: 3,&#125;]// 树状数据[&#123; name: &#x27;文本1&#x27;, id: 1, children: [&#123; name: &#x27;文本2&#x27;, id: 2, children: [&#123; name: &#x27;文本3&#x27;, id: 3 &#125;] &#125;]&#125;] 模板解析 实现一个简易的模板引擎 1234567891011121314const template = &#x27;嗨，&#123;&#123; info.name.value &#125;&#125;您好，今天是星期 &#123;&#123; day.value &#125;&#125;&#x27;;const data = &#123; info: &#123; name: &#123; value: &#x27;张三&#x27; &#125; &#125;, day: &#123; value: &#x27;三&#x27; &#125;&#125;;render(template, data); // 嗨，张三您好，今天是星期三 设计模式 简单实现一个发布 / 订阅模式 正则表达式 匹配出字符串中 const a = require(‘xxx’) 中的 xxx","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://wisiw.github.io.git/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"【Vue】全局引入组件，挂载在原型链上","slug":"【Vue】全局引入组件，挂载在原型链上","date":"2021-08-04T15:44:01.000Z","updated":"2021-11-03T06:02:14.435Z","comments":true,"path":"2021/08/04/【Vue】全局引入组件，挂载在原型链上/","link":"","permalink":"https://wisiw.github.io.git/2021/08/04/%E3%80%90Vue%E3%80%91%E5%85%A8%E5%B1%80%E5%BC%95%E5%85%A5%E7%BB%84%E4%BB%B6%EF%BC%8C%E6%8C%82%E8%BD%BD%E5%9C%A8%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8A/","excerpt":"","text":"原理使用vue.extend()和$mount() 弹窗组件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;template&gt; &lt;!-- 遮罩层 也是整个组件的容器--&gt; &lt;div class=&quot;pop-container&quot; v-if=&quot;isShow&quot;&gt; &lt;div class=&quot;message-container&quot;&gt; &lt;!-- 两个icon放在一个容器中，但是只显示一个 --&gt; &lt;div class=&quot;icon-container&quot;&gt; &lt;div class=&quot;icon-container-success&quot; v-if=&quot;type === &#x27;success&#x27;&quot;&gt; &lt;!-- 引用了iview的Icon组件 --&gt; &lt;Icon class=&quot;icon-checkmark&quot; type=&quot;md-checkmark&quot; size=&quot;30&quot; color=&quot;#D8DCE9&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;icon-container-error&quot; v-if=&quot;type === &#x27;error&#x27;&quot;&gt; &lt;Icon class=&quot;icon-close&quot; type=&quot;md-close&quot; size=&quot;30&quot; color=&quot;#D8DCE9&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;span class=&quot;message-text&quot;&gt;&#123;&#123; text &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;message&#x27;, props: &#123; type: &#123; // type控制是成功还是失败 type: String, default: &#x27;success&#x27;, &#125;, text: &#123; // 弹窗的文字信息 type: String, default: &#x27;&#x27;, &#125;, isShow: &#123; // 整个遮罩和弹窗是否显示 type: Boolean, default: true, &#125;, &#125;,&#125;;&lt;/script&gt;&lt;style scoped lang=&quot;less&quot;&gt;.pop-container &#123; display: flex; justify-content: center; align-items: center; z-index: 99999; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(24, 30, 53, 0.7); backdrop-filter: blur(10px);&#125;.message-container &#123; display: flex; justify-content: center; align-items: center; min-width: 384px; padding: 0 30px; height: 170px; background: #303e62; box-shadow: 0px 0px 30px rgba(0, 0, 0, 0.1); border-radius: 12px;&#125;.icon-container &#123; position: relative; height: 40px; width: 40px; border-radius: 50%; &amp;-error &#123; background-color: #fe1b1b; height: 40px; width: 40px; border-radius: 50%; .icon-close &#123; position: absolute; right: 5px; bottom: 5px; font-weight: 900; &#125; &#125; &amp;-success &#123; background-color: #4ad991; height: 40px; width: 40px; border-radius: 50%; .icon-checkmark &#123; position: absolute; right: 4px; bottom: 5px; font-weight: 900; &#125; &#125;&#125;.message-text &#123; margin-left: 12px; font-weight: 500; font-size: 18px; line-height: 27px;&#125;&lt;/style&gt; 挂载在原型上1234567891011121314151617181920212223242526272829303132333435363738394041424344import vue from &#x27;vue&#x27;;// 引入上面写好的组件import Message from &#x27;./message&#x27;;// 全局警告弹窗 第一个参数为提示的文本信息，第二个参数可选，为弹窗持续时间// 可以提前看一下知识点，Vue.extend + vm.$mount，可以让我们在vue中用js一样的方法去直接调用一个组件// https://www.cnblogs.com/hentai-miao/p/10271652.html// 将vue组件利用Vue.extend方法变成一个组件构造器，相当于一个类const MsgClass = vue.extend(Message);const MsgMain = &#123; show(text, type, duration) &#123; // 实例化这个组件 const instance = new MsgClass(); // 将组件实例挂在到一个元素上面，如果不传参数就是挂载到body，或者也可以传入其他已经存在的元素的选择器 instance.$mount(document.createElement(&#x27;div&#x27;)); // 通过组件实例的$el属性，可以访问到这个组件元素，然后把它拼接到body上。 document.body.appendChild(instance.$el); // 给这个实例传入参数 instance.type = type; instance.text = text; instance.isShow = true; // 设置一个延迟，过了时间弹窗消失 setTimeout(() =&gt; &#123; instance.isShow = false; &#125;, duration); &#125;, // 成功时调用这个方法 success(text, duration = 2000) &#123; this.show(text, &#x27;success&#x27;, duration); &#125;, // 失败时调用这个方法 error(text, duration = 2000) &#123; this.show(text, &#x27;error&#x27;, duration); &#125;,&#125;;// 全局注册function Msg() &#123; vue.prototype.$msg = MsgMain; // 最终调用就是this.$msg.success() 或者this.$msg.error()&#125;export default Msg; 全局注册123// main.jsimport Msg from &#x27;../src/components/message&#x27;;Vue.use(Msg); 使用123this.$msg.success(&#x27;设置成功！&#x27;); // 第二个参数可以传入弹窗持续时间，默认是2000this.$msg.success(&#x27;设置成功！&#x27;，3000);this.$msg.error(&#x27;设置失败！&#x27;)","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://wisiw.github.io.git/tags/Vue/"},{"name":"全局弹窗","slug":"全局弹窗","permalink":"https://wisiw.github.io.git/tags/%E5%85%A8%E5%B1%80%E5%BC%B9%E7%AA%97/"}]},{"title":"【Node】npm库","slug":"【Node】npm库","date":"2021-08-04T03:32:47.000Z","updated":"2021-09-23T06:17:23.808Z","comments":true,"path":"2021/08/04/【Node】npm库/","link":"","permalink":"https://wisiw.github.io.git/2021/08/04/%E3%80%90Node%E3%80%91npm%E5%BA%93/","excerpt":"","text":"oraElegant terminal spinner 1github.com/sindresorhus/ora chalkTerminal string styling done right 1https://github.com/chalk/chalk octokitThe all-batteries-included GitHub SDK for Browsers, Node.js, and Deno. 1https://github.com/octokit/octokit.js @octokit/coreExtendable client for GitHub’s REST &amp; GraphQL APIs 1https://github.com/octokit/core.js options name type description options.authStrategy Function Defaults to @octokit/auth-token. See Authentication below for examples. options.auth String or Object See Authentication below for examples. options.baseUrl String When using with GitHub Enterprise Server, set options.baseUrl to the root URL of the API. For example, if your GitHub Enterprise Server’s hostname is github.acme-inc.com, then set options.baseUrl to https://github.acme-inc.com/api/v3. Exampleconst octokit = new Octokit(&#123; baseUrl: &quot;https://github.acme-inc.com/api/v3&quot;, &#125;); options.previews Array of Strings Some REST API endpoints require preview headers to be set, or enable additional features. Preview headers can be set on a per-request basis, e.g.octokit.request(&quot;POST /repos/&#123;owner&#125;/&#123;repo&#125;/pulls&quot;, &#123; mediaType: &#123; previews: [&quot;shadow-cat&quot;], &#125;, owner, repo, title: &quot;My pull request&quot;, base: &quot;master&quot;, head: &quot;my-feature&quot;, draft: true, &#125;);You can also set previews globally, by setting the options.previews option on the constructor. Example:const octokit = new Octokit(&#123; previews: [&quot;shadow-cat&quot;], &#125;); options.request Object Set a default request timeout (options.request.timeout) or an http(s).Agent e.g. for proxy usage (Node only, options.request.agent).There are more options.request.* options, see @octokit/request options. options.request can also be set on a per-request basis. options.timeZone String Sets the Time-Zone header which defines a timezone according to the list of names from the Olson database.const octokit = new Octokit(&#123; timeZone: &quot;America/Los_Angeles&quot;, &#125;);The time zone header will determine the timezone used for generating the timestamp when creating commits. See GitHub’s Timezones documentation. options.userAgent String A custom user agent string for your app or library. Exampleconst octokit = new Octokit(&#123; userAgent: &quot;my-app/v1.2.3&quot;, &#125;); octokat1https://github.com/philschatz/octokat.js","categories":[],"tags":[{"name":"Node","slug":"Node","permalink":"https://wisiw.github.io.git/tags/Node/"},{"name":"npm","slug":"npm","permalink":"https://wisiw.github.io.git/tags/npm/"}]},{"title":"【读书笔记】数据结构与抽象 java语言描述-第二章使用链式数据实现包","slug":"【读书笔记】数据结构与抽象-java语言描述-第三章使用链式数据实现包","date":"2021-07-06T05:58:35.000Z","updated":"2021-07-06T05:59:01.073Z","comments":true,"path":"2021/07/06/【读书笔记】数据结构与抽象-java语言描述-第三章使用链式数据实现包/","link":"","permalink":"https://wisiw.github.io.git/2021/07/06/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E6%8A%BD%E8%B1%A1-java%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0%E4%BD%BF%E7%94%A8%E9%93%BE%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%AE%9E%E7%8E%B0%E5%8C%85/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"【读书笔记】数据结构与抽象 java语言描述-第二章使用数组实现包","slug":"【读书笔记】数据结构与抽象-java语言描述-第二章使用数组实现包","date":"2021-07-06T05:53:21.000Z","updated":"2021-07-06T05:59:44.479Z","comments":true,"path":"2021/07/06/【读书笔记】数据结构与抽象-java语言描述-第二章使用数组实现包/","link":"","permalink":"https://wisiw.github.io.git/2021/07/06/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E6%8A%BD%E8%B1%A1-java%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%8C%85/","excerpt":"","text":"使用固定大小的数组实现ADT包类比一组核心方法实现核心方法让实现安全测试核心方法实现更多的方法删除项的方法使用可变大小的数组实现ADT包可变大小数组包的新实现使用数组实现ADT包的优缺点","categories":[],"tags":[{"name":"数据、算法","slug":"数据、算法","permalink":"https://wisiw.github.io.git/tags/%E6%95%B0%E6%8D%AE%E3%80%81%E7%AE%97%E6%B3%95/"},{"name":"数组实现包","slug":"数组实现包","permalink":"https://wisiw.github.io.git/tags/%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%8C%85/"}]},{"title":"【读书笔记】数据结构与抽象 java语言描述","slug":"【读书笔记】数据结构与抽象-java语言描述","date":"2021-07-05T06:00:12.000Z","updated":"2021-07-06T05:43:17.933Z","comments":true,"path":"2021/07/05/【读书笔记】数据结构与抽象-java语言描述/","link":"","permalink":"https://wisiw.github.io.git/2021/07/05/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E6%8A%BD%E8%B1%A1-java%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0/","excerpt":"","text":"封装 封装：常常被称为信息隐藏。将数据和方法放在一个类中，隐藏了使用类时不需要的实现细节 抽象：是一个要求你关注什么而不是如何的过程。当设计类的时候，执行数据抽象 正确的封装将类定义为两部分：客户接口和实现 ​ 客户接口描述程序员使用这个类时必须了解的一切事情。包括类的公有方法的方法头、注释（告诉程序员如何使用这些公有方法）、以及类中公有定义的任何常量 ​ 实现部分有所有的数据域及所有方法的定义组成，包括公有、私有及保护的方法 说明方法 注释： 前置条件和后置条件 ​ 前置条件：是一条条件语句，在方法执行前必须为真。除非前置条件满足，否则不应该使用方法，也不能期待方法能正确执行 ​ 后置条件：是一条语句，当前置条件满足且完全执行方法后，它为真。一般来说，后置条件描述方法调用产生的所有影响 ​ 对于一个值方法，后置条件将描述方法返回的值 ​ 对于一个void方法，后置条件描述所做的动作及调用对象的任何修改 ​ 职责 说明一个包，使用UML进行表示 123456789+getCurrentSize(): integer+isEmpty(): boolean+add(newEntry: T): boolean+clear(): void+remove(): T+remove(anEntry T): T+getFrequencyOf(anEntry: T): integer+contains(anEntry: T): boolean+toArray(): T[] 包类的java接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * An interface that describes the operations of a bag of objects */public interface BagInterface&lt;T&gt; &#123; /** * Gets the current number of entries in this bag. * @return The integer number of entries currently in the bag. */ public int getCurrentSize(); /** * Sees whether this bag is empty. * @return true if the bag is empty, or false if not. */ public boolean isEmpty(); /** * Adds a new entry to this bag. * @param newEntry The objects to be added as a new entry * @return True if the addition is successful, or false if not. */ public boolean add(T newEntry); /** * Removes all entries from this bag. */ public void clear(); /** * Removes one unspecified entry from this bag, if possible. * @return Either the removed entry, if the removal was successful, or null. */ public T remove(); /** * Remove one occurrence of a given entry from this bag, if possible. * @param anEntry The entry to be removed. * @return True if the removal was successful, or false if not. */ public T remove(T anEntry); /** * Counts the number of times a given entry appears in this bag. * @param anEntry The entry to be counted. * @return The number of times anEntry appears in the bag. */ public int getFrequencyOf(T anEntry); /** * Tests whether this bag contains a given entry * @param anEntry The entry to locate. * @return True if the bag contains an Entry, or false if not. */ public boolean contains(T anEntry); /** * Retrieves all entries that are in this bag * @return A newly allocated array of all the entries in the bag. Note: If the bag is empty, the returned array is empty. */ public T[] toArray();&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://wisiw.github.io.git/tags/Java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://wisiw.github.io.git/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"数据结构","slug":"数据结构","permalink":"https://wisiw.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"【JavaScript】技巧","slug":"【JavaScript】技巧","date":"2021-07-05T02:01:45.000Z","updated":"2022-11-01T06:07:24.893Z","comments":true,"path":"2021/07/05/【JavaScript】技巧/","link":"","permalink":"https://wisiw.github.io.git/2021/07/05/%E3%80%90JavaScript%E3%80%91%E6%8A%80%E5%B7%A7/","excerpt":"","text":"引入JavaScript脚本12345678&lt;script&gt; export default &#123; name: &#x27;hello-world&#x27;, mounted() &#123; alert(&#x27;hello-world&#x27;) &#125; &#125;&lt;/script&gt; 以上的script组件内部是一个模块，因此可以导出。其中包含组件的名称name和声明周期mounted 在import时，因为是在HTML文件中，因此无法import**import语句获取的是模块标识符。大部分情况下，它是包含代码的文件的URL，在内部模块的情况下，是没有这样的标识符的。 但是可以使用数据URI（将JavaScript文件内容转换为URL，然后使用Base64对所有内容进行编码） 例如： 1export default true 转换为如下的数据URI 1data:application/javascript;base64,ZXhwb3J0IGRlZmF1bHQgdHJ1ZTs= 此时可以像引用普通文件一样引用 123import test from &#x27;data:application/javascript;base64,ZXhwb3J0IGRlZmF1bHQgdHJ1ZTs=&#x27;console.log(test) // true 此方法最大的缺点是，数据URI会随着文件的增大而增长，以合理的方式将二进制数据放入数据URI中也非常困难 这时就需要使用对象URI， 1.多个条件判断的if语句，使用includes在数组中存储需要判断的值，使用数组的includes方法 123456if( x === &#x27;abc&#x27; || x === &#x27;def&#x27; || x === &#x27;ghi&#x27;) &#123; &#125;if([&#x27;abc&#x27;, &#x27;def&#x27;, &#x27;ghi&#x27;].includes(x)) &#123; &#125; 2.if…else使用三元表达式if…else的逻辑判断较为简单的时候，使用三元判断","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wisiw.github.io.git/tags/JavaScript/"},{"name":"技巧","slug":"技巧","permalink":"https://wisiw.github.io.git/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"【代码片段】日常积累","slug":"【代码片段】日常积累","date":"2021-06-25T05:42:05.000Z","updated":"2022-11-06T21:11:54.223Z","comments":true,"path":"2021/06/25/【代码片段】日常积累/","link":"","permalink":"https://wisiw.github.io.git/2021/06/25/%E3%80%90%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E3%80%91%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/","excerpt":"","text":"平时写的方法或样式，待分类整理 1.微信分享功能1-1.uni中使用manifest.json中勾选 123456789101112uni.share(&#123; provider: &#x27;&#x27;, // 分享服务供应商（weixin|qq|sinaweibo） scene: scene, // 分享形式 type: type, href: &#x27;&#x27;, title: title, imageUrl: this.shareObj.imageUrl, summary: this.shareObj.summary, success(res) &#123;&#125;, fail(&#123;errMsg&#125;) &#123;&#125;, complete(res) &#123;&#125;&#125;) 1-2.summary分行功能：1234// 使用\\r\\n换行&#123; summary: `第一行\\r\\n第二行`&#125; 1-3.iOS分享图片过大，将图片压缩123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869toShare(&#123; provider, scene, type &#125;) &#123; let href = &#x27;&#x27; let that = this; const &#123; href, title, imageUrl, summary &#125; = this.shareObj //获取图片后压缩 uni.downloadFile(&#123; url: imageUrl, success: function(images) &#123; that.compress(images.tempFilePath, (img) =&gt; &#123; that.share(provider, scene, type, href, title, img, summary) &#125;) &#125;, fail(error) &#123; uni.hideLoading(); &#125; &#125;)&#125;,compress(img, cb) &#123; plus.io.resolveLocalFileSystemURL(img, (entry) =&gt; &#123; entry.file((file) =&gt; &#123; console.log(&#x27;压缩前图片信息:&#x27; + JSON.stringify(file)); //压缩前图片信息 // 如果大于20Kb进行压缩 if(file.size &gt; 20000) &#123; plus.zip.compressImage(&#123; src: img, dst: img.replace(&#x27;.png&#x27;, &#x27;_s.png&#x27;).replace(&#x27;.PNG&#x27;, &#x27;_s.PNG&#x27;).replace(&#x27;.jpg&#x27;,&#x27;_s.jpg&#x27;).replace(&#x27;.JPG&#x27;,&#x27;_s.JPG&#x27;), width: &#x27;40%&#x27;, height: &#x27;40%&#x27;, quality: 10, overwrite: true, format: &#x27;jpg&#x27; &#125;, (event) =&gt; &#123; console.log(&#x27;压缩后图片信息:&#x27; + JSON.stringify(event)); cb &amp;&amp; cb(event.target); &#125;, function(err) &#123; console.log(&#x27;Resolve file URL failed: &#x27; + err.message); &#125;); &#125;else&#123; //else小于20kb跳过压缩，直接返回现有的src cb &amp;&amp; cb(img); &#125; &#125;); &#125;, (e) =&gt; &#123; // 返回错误信息 console.log(&#x27;Resolve file URL failed: &#x27; + e.message); &#125;);&#125;,share(provider, scene, type, href, title, img, summary) &#123; uni.share(&#123; provider: provider, scene: scene, type: type, href: href, title: title, imageUrl: img, summary: summary, success(res) &#123; console.log(res) &#125;, fail(&#123;errMsg&#125;) &#123; this.$refs.uToast.show(&#123; title: &#x27;请安装微信客户端&#x27;, type: &#x27;warning&#x27; &#125;) &#125;, complete(res) &#123; console.log(res) &#125; &#125;)&#125; 2.apple支付123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;script&gt; let iapChannel = null, productId = &#x27;HelloUniappPayment1&#x27;, productIds = [&#x27;HelloUniappPayment1&#x27;, &#x27;HelloUniappPayment6&#x27;]; export default &#123; data() &#123; return &#123; title: &#x27;request-payment&#x27;, loading: false, disabled: true, priceList: [&#123; value: &#x27;HelloUniappPayment1&#x27;, text: &#x27;支付1元&#x27;, checked: true &#125;, &#123; value: &#x27;HelloUniappPayment6&#x27;, text: &#x27;支付6元&#x27;, checked: false &#125;] &#125; &#125;, onLoad: function() &#123; plus.payment.getChannels((channels) =&gt; &#123; console.log(&quot;获取到channel&quot; + JSON.stringify(channels)) for (var i in channels) &#123; var channel = channels[i]; if (channel.id === &#x27;appleiap&#x27;) &#123; iapChannel = channel; this.requestOrder(); &#125; &#125; if(!iapChannel)&#123; this.errorMsg() &#125; &#125;, (error) =&gt; &#123; this.errorMsg() &#125;); &#125;, methods: &#123; requestOrder() &#123; uni.showLoading(&#123; title:&#x27;检测支付环境...&#x27; &#125;) iapChannel.requestOrder(productIds, (orderList) =&gt; &#123; //必须调用此方法才能进行 iap 支付 this.disabled = false; console.log(&#x27;requestOrder success666: &#x27; + JSON.stringify(orderList)); uni.hideLoading(); &#125;, (e) =&gt; &#123; console.log(&#x27;requestOrder failed: &#x27; + JSON.stringify(e)); uni.hideLoading(); this.errorMsg() &#125;); &#125;, requestPayment(e) &#123; this.loading = true; uni.requestPayment(&#123; provider: &#x27;appleiap&#x27;, orderInfo: &#123; productid: productId &#125;, success: (e) =&gt; &#123; uni.showModal(&#123; content: &quot;感谢您的赞助&quot;, showCancel: false &#125;) &#125;, fail: (e) =&gt; &#123; uni.showModal(&#123; content: &quot;支付失败,原因为: &quot; + e.errMsg, showCancel: false &#125;) &#125;, complete: () =&gt; &#123; console.log(&quot;payment结束&quot;) this.loading = false; &#125; &#125;) &#125;, applePriceChange(e) &#123; productId = e.detail.value; &#125;, errorMsg()&#123; uni.showModal(&#123; content: &quot;暂不支持苹果 iap 支付&quot;, showCancel: false &#125;) &#125; &#125; &#125;&lt;/script&gt; productId需要去https://appstoreconnect.apple.com/配置内购id 2.webpack2.1为什么开发时webpack生成很慢因为loader中使用this.callback与webpack通信 12345678910this.callback( // 当无法转换原 内容时，为 Webpa ck 返回一个 Error err: Error I null, // 原内容转换后的内容 content: string I Buffer, // 用于通过转换后的 内容得出原内容的 Source Map ，以方便调试 sourceMap?: SourceMap, // 如果本次转换为原 内容生成了 AST 语法树，则可以将这个 AST 返回，以方便之后需要 AST Loader 复用该 AST ，避免重复生成 AST ，提升性能 abstractSyntaxTree?: AST); Source Map的生成很耗时，通常只有在开发环境下才会生成Source Map，在其他环境下不生成，以加速构建。因此webpack为loader提供了this.sourceMap以用来判断当前构建环境下的用户是否需要生成Source Map。 2.文件下载时或responseType:Blob时，如果返回json中携带错误信息，如何在error中获取？2.1Why接口返回了正常的错误对象，包含错误码和错误信息，但是因为是blob数据类型，无法获取 1234Blob &#123; size: 17, type: &quot;application/json&quot;&#125; 需要转化为json格式 1234567891011let &#123; data &#125; = errorconst reader = new FileReader()reader.onload = funtion() &#123; try &#123; let result = JSON.parse(this.result) &#125;catch (error) &#123; // 解析不成功，说明是正常的文件，下载 ... &#125;&#125;reader.readAsText(data) // 解析返回结果 监听DOM内容变化使用MutationObserver 1234567const observer = new MutationObserver(this.update);// 监听此组件的变化observer.observe([el], &#123; childList: true, subtree: true&#125;) vue限定prop类型123456789101112export default &#123; name: &#x27;Image&#x27;, props: &#123; src: &#123; type: String, &#125;, style: &#123; type: String, validator: s =&gt; [&#x27;square&#x27;, &#x27;rounded&#x27;].includes(s) &#125; &#125;&#125;; 栈溢出的原因1.失控递归（忽略基准型）2.递归处理的数据过大，超出栈空间12345678public static &lt;AnyType&gt; void printList(Iterator&lt;AnyType&gt; itr) &#123; if ( !itr.hasNext() ) &#123; return; &#125; System.out.println( itr.next() ); printList(itr);&#125; 递归的不恰当应用，打印链表 上述程序使用尾递归，","categories":[],"tags":[{"name":"代码片段","slug":"代码片段","permalink":"https://wisiw.github.io.git/tags/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"}]},{"title":"【Java】MyBatis-Plus实现curd操作","slug":"【Java】MyBatis-Plus实现curd操作","date":"2021-04-11T10:47:23.000Z","updated":"2021-09-23T06:17:06.575Z","comments":true,"path":"2021/04/11/【Java】MyBatis-Plus实现curd操作/","link":"","permalink":"https://wisiw.github.io.git/2021/04/11/%E3%80%90Java%E3%80%91MyBatis-Plus%E5%AE%9E%E7%8E%B0curd%E6%93%8D%E4%BD%9C/","excerpt":"","text":"1.MyBatis-Plus是什么是MyBatis的增强工具，在MyBatis的基础上只做增强，不做改变，为简化开发、提高效率而生 2.实现增删改查3.自动填充乐观锁4.逻辑删除#5.分页查询 ​","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://wisiw.github.io.git/tags/Java/"},{"name":"数据库","slug":"数据库","permalink":"https://wisiw.github.io.git/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MyBatis-Plus","slug":"MyBatis-Plus","permalink":"https://wisiw.github.io.git/tags/MyBatis-Plus/"}]},{"title":"操作系统","slug":"操作系统","date":"2021-03-21T12:52:58.000Z","updated":"2021-06-21T08:13:20.417Z","comments":true,"path":"2021/03/21/操作系统/","link":"","permalink":"https://wisiw.github.io.git/2021/03/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"操作系统的类型和结构类型 类型 分类 描述 特征 批处理操作系统 联级批处理、脱机批处理 把用户提交的作业分类，把一批中的作业编成一个作业执行序列 用户脱机使用计算机、成批处理、多道程序运行 分时操作系统 采用分时技术，使多个用户同时以会话方式控制自己程序的运行，每个用户都感到似乎有一台独立的、支持自己请求服务的系统。 交互性、多用户同时性、独立性 分时技术把处理机的运行时间分成很短的时间片，按时间片轮流把处理机分配给各联机作业使用。若某个作业在分配给他的时间片内不能完成其计算，则该作业暂时中断，把处理器让给另一作业使用，等下一轮时再继续运行 实时操作系统 实时过程控制、实时信息处理 往往是专用的，系统与应用很难分离，常常紧密结合在一起。实时系统并不强调资源利用率，而更关心及时性（时间紧迫性）、可靠性和完整性 提供即时响应、高可靠性 网络操作系统 分布式操作系统 要求有一个统一的操作系统，实现系统操作的统一性，负责全系统的资源分配和调度，为用户提供统一的界面 结构处理器管理进程的状态信号量与PV操作死锁问题管程与进程文件管理文件的逻辑组织文件的物理组织树形目录结构##存储空间的管理 存储管理地址变换存储组织##存储管理 作业管理作业状态##作业调度 设备管理数据传输控制方式磁盘调度算法##虚设备与SPOOLing技术 网络操作系统网络操作系统概述##网络操作系统的组成 #例题","categories":[],"tags":[{"name":"系统架构设计师考试","slug":"系统架构设计师考试","permalink":"https://wisiw.github.io.git/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%80%83%E8%AF%95/"},{"name":"第一章","slug":"第一章","permalink":"https://wisiw.github.io.git/tags/%E7%AC%AC%E4%B8%80%E7%AB%A0/"}]},{"title":"【面试题】CSS","slug":"【面试题】CSS","date":"2021-02-23T02:28:03.000Z","updated":"2021-12-01T02:37:29.287Z","comments":true,"path":"2021/02/23/【面试题】CSS/","link":"","permalink":"https://wisiw.github.io.git/2021/02/23/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%91CSS/","excerpt":"","text":"","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://wisiw.github.io.git/tags/CSS/"},{"name":"面试题","slug":"面试题","permalink":"https://wisiw.github.io.git/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"【面试题】vuex","slug":"【面试题】vuex","date":"2021-02-21T14:04:33.000Z","updated":"2021-12-01T02:38:29.599Z","comments":true,"path":"2021/02/21/【面试题】vuex/","link":"","permalink":"https://wisiw.github.io.git/2021/02/21/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%91vuex/","excerpt":"","text":"vuex是什么？怎么使用？哪种功能场景使用它？是专门为vue开发的状态管理模式 采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一直能够可预测的方式发生变化 解决多个组件共享状态或来自不同组件的行为需要变更同一状态：音乐播放、登录状态、购物车 vuex 的 store 特性是什么 vuex 就是一个仓库，仓库里放了很多对象。其中 state 就是数据源存放地，对应于一般 vue 对象里面的 data state 里面存放的数据是响应式的，vue 组件从 store 读取数据，若是 store 中的数据发生改变，依赖这相数据的组件也会发生更新 它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性 Vuex中状态是对象时，使用时要注意什么？因为对象是引用类型，复制后改变属性还是会影响原始数据，这样会改变state里面的状态，是不允许，所以先用深度克隆复制对象，再修改。 怎么在组件中批量使用Vuex的state状态？使用mapState辅助函数, 利用对象展开运算符将state混入computed对象中 123456import &#123;mapState&#125; from &#x27;vuex&#x27;export default&#123; computed:&#123; ...mapState([&#x27;price&#x27;,&#x27;number&#x27;]) &#125;&#125; Vuex中要从state派生一些状态出来，且多个组件使用它，该怎么做？使用getter属性，相当Vue中的计算属性computed，只有原状态改变派生状态才会改变。 getter接收两个参数，第一个是state，第二个是getters(可以用来访问其他getter)。 123456789101112131415const store = new Vuex.Store(&#123; state: &#123; price: 10, number: 10, discount: 0.7, &#125;, getters: &#123; total: state =&gt; &#123; return state.price * state.number &#125;, discountTotal: (state, getters) =&gt; &#123; return state.discount * getters.total &#125; &#125;,&#125;); 然后在组件中可以用计算属性computed通过this.$store.getters.total这样来访问这些派生转态。 12345678computed: &#123; total() &#123; return this.$store.getters.total &#125;, discountTotal() &#123; return this.$store.getters.discountTotal &#125;&#125; 怎么通过getter来实现在组件内可以通过特定条件来获取state的状态？通过让getter返回一个函数，来实现给getter传参。然后通过参数来进行判断从而获取state中满足要求的状态。 12345678910111213const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: &#x27;...&#x27;, done: true &#125;, &#123; id: 2, text: &#x27;...&#x27;, done: false &#125; ] &#125;, getters: &#123; getTodoById: (state) =&gt; (id) =&gt;&#123; return state.todos.find(todo =&gt; todo.id === id) &#125; &#125;,&#125;); 然后在组件中可以用计算属性computed通过this.$store.getters.getTodoById(2)这样来访问这些派生转态。 12345678computed: &#123; getTodoById() &#123; return this.$store.getters.getTodoById &#125;,&#125;mounted()&#123; console.log(this.getTodoById(2).done)//false&#125; vuex有哪几种属性State , Getter , Mutation , Action , Module (就是mapAction) state：vuex的基本数据，用来存储变量 geeter： ​ (1) getter 可以对 state 进行计算操作，它就是 store 的计算属性 (2) 虽然在组件内也可以做计算属性，但是 getters 可以在多给件之间复用 (3) 如果一个状态只在一个组件内使用，是可以不用 getters mutation：提交更新数据的方法，必须是同步的(如果需要异步使用action)。每个mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数，提交载荷作为第二个参数。 action：和mutation的功能大致相同，不同之处在于 ==》 1. Action 提交的是 mutation，而不是直接变更状态。 2. Action 可以包含任意异步操作。 modules：模块化vuex，可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理。 Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？ 单独组件使用，放在methods中 多组件复用，放在action中，包装成promise返回，在调用处用async await返回 不用 vuex 会带来什么问题 可维护性会下降，你要修改数据，你得维护3个地方 可读性下降，因为一个组件里的数据，你根本就看不出来是从哪里来的 增加耦合，大量的上传派发，会让耦合性大大的增加，本来Vue用Component就是为了减少耦合，现在这么用，和组件化的初衷相背 vuex一个例子方法vuex中如何异步修改状态123456789this.$store.dispatch(&#x27;mutations方法名&#x27;,值)const actions =&#123; asyncIncre(&#123;commit,dispatch&#125;,payload)&#123; setTimeout(()=&gt;&#123; commit(&#x27;minus&#x27;,payload) &#125;) &#125;&#125; vuex中actions和mutations的区别Mutation 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数 1234567891011const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, mutations: &#123; increment (state) &#123; // 变更状态 state.count++ &#125; &#125;&#125;) Action Action 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 . 123456789101112131415const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; increment (context) &#123; context.commit(&#x27;increment&#x27;) &#125; &#125;&#125;) 怎么在组件中批量使用Vuex的getter属性使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中 123456import &#123;mapGetters&#125; from &#x27;vuex&#x27;export default&#123; computed:&#123; ...mapGetters([&#x27;total&#x27;,&#x27;discountTotal&#x27;]) &#125;&#125; 怎么在组件中批量给Vuex的getter属性取别名并使用使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中 123456789import &#123;mapGetters&#125; from &#x27;vuex&#x27;export default&#123; computed:&#123; ...mapGetters(&#123; myTotal:&#x27;total&#x27;, myDiscountTotal:&#x27;discountTotal&#x27;, &#125;) &#125;&#125; 在Vuex中使用mutation要注意什么。mutation 必须是同步函数 Vuex中action和mutation有什么区别？action 提交的是 mutation，而不是直接变更状态。mutation可以直接变更状态。 action 可以包含任意异步操作。mutation只能是同步操作。 提交方式不同，action 是用this.$store.dispatch(&#39;ACTION_NAME&#39;,data)来提交。mutation是用this.$store.commit(&#39;SET_NUMBER&#39;,10)来提交。 接收参数不同，mutation第一个参数是state，而action第一个参数是context，其包含了 12345678&#123; state, // 等同于 `store.state`，若在模块中则为局部状态 rootState, // 等同于 `store.state`，只存在于模块中 commit, // 等同于 `store.commit` dispatch, // 等同于 `store.dispatch` getters, // 等同于 `store.getters` rootGetters // 等同于 `store.getters`，只存在于模块中&#125; Vuex中action和mutation有什么相同点？第二参数都可以接收外部提交时传来的参数。 this.$store.dispatch(&#39;ACTION_NAME&#39;,data)和this.$store.commit(&#39;SET_NUMBER&#39;,10) 在组件中多次提交同一个action，怎么写使用更方便。使用mapActions辅助函数,在组件中这么使用 12345methods:&#123; ...mapActions(&#123; setNumber:&#x27;SET_NUMBER&#x27;, &#125;)&#125; 然后调用this.setNumber(10)相当调用this.$store.dispatch(&#39;SET_NUMBER&#39;,10) Vuex中action通常是异步的，那么如何知道action什么时候结束呢？在action函数中返回Promise，然后再提交时候用then处理 12345678910111213actions:&#123; SET_NUMBER_A(&#123;commit&#125;,data)&#123; return new Promise((resolve,reject) =&gt;&#123; setTimeout(() =&gt;&#123; commit(&#x27;SET_NUMBER&#x27;,10); resolve(); &#125;,2000) &#125;) &#125;&#125;this.$store.dispatch(&#x27;SET_NUMBER_A&#x27;).then(() =&gt; &#123; // ...&#125;) Vuex中有两个action，分别是actionA和actionB，其内都是异步操作，在actionB要提交actionA，需在actionA处理结束再处理其它操作，怎么实现？利用ES6的async和await来实现。 123456789actions:&#123; async actionA(&#123;commit&#125;)&#123; //... &#125;, async actionB(&#123;dispatch&#125;)&#123; await dispatch (&#x27;actionA&#x27;)//等待actionA完成 // ... &#125;&#125; 有用过Vuex模块吗，为什么要使用，怎么使用。有，因为使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。所以将 store 分割成模块（module）。每个模块拥有自己的 state、mutations、actions、getters，甚至是嵌套子模块，从上至下进行同样方式的分割。 在module文件新建moduleA.js和moduleB.js文件。在文件中写入 123456789101112131415161718const state=&#123; //...&#125;const getters=&#123; //...&#125;const mutations=&#123; //...&#125;const actions=&#123; //...&#125;export default&#123; state, getters, mutations, actions&#125; 然后再index.js引入模块 123456789101112import Vue from &#x27;vue&#x27;;import Vuex from &#x27;vuex&#x27;;Vue.use(Vuex);import moduleA from &#x27;./module/moduleA&#x27;import moduleB from &#x27;./module/moduleB&#x27;const store = new Vuex.Store(&#123; modules:&#123; moduleA, moduleB &#125;&#125;)export default store 在模块中，getter和mutation接收的第一个参数state，是全局的还是模块的？第一个参数state是模块的state，也就是局部的state。 在模块中，getter和mutation和action中怎么访问全局的state和getter？在getter中可以通过第三个参数rootState访问到全局的state,可以通过第四个参数rootGetters访问到全局的getter。 在mutation中不可以访问全局的satat和getter，只能访问到局部的state。 在action中第一个参数context中的context.rootState访问到全局的state，context.rootGetters访问到全局的getter。 在组件中怎么访问Vuex模块中的getter和state,怎么提交mutation和action？直接通过this.$store.getters和this.$store.state来访问模块中的getter和state。 直接通过this.$store.commit(&#39;mutationA&#39;,data)提交模块中的mutation。 直接通过this.$store.dispatch(&#39;actionA,data&#39;)提交模块中的action。 用过Vuex模块的命名空间吗？为什么使用，怎么使用。默认情况下，模块内部的action、mutation和getter是注册在全局命名空间，如果多个模块中action、mutation的命名是一样的，那么提交mutation、action时，将会触发所有模块中命名相同的mutation、action。 这样有太多的耦合，如果要使你的模块具有更高的封装度和复用性，你可以通过添加namespaced: true 的方式使其成为带命名空间的模块。 1234567export default&#123; namespaced: true, state, getters, mutations, actions&#125; 怎么在带命名空间的模块内提交全局的mutation和action？将 { root: true } 作为第三参数传给 dispatch 或 commit 即可。 12this.$store.dispatch(&#x27;actionA&#x27;, null, &#123; root: true &#125;)this.$store.commit(&#x27;mutationA&#x27;, null, &#123; root: true &#125;) #怎么在带命名空间的模块内注册全局的action？ 123456actions: &#123; actionA: &#123; root: true, handler (context, data) &#123; ... &#125; &#125;&#125; 怎么使用mapState，mapGetters，mapActions和mapMutations这些函数来绑定带命名空间的模块？首先使用createNamespacedHelpers创建基于某个命名空间辅助函数 123456789101112131415161718import &#123; createNamespacedHelpers &#125; from &#x27;vuex&#x27;;const &#123; mapState, mapActions &#125; = createNamespacedHelpers(&#x27;moduleA&#x27;);export default &#123; computed: &#123; // 在 `module/moduleA` 中查找 ...mapState(&#123; a: state =&gt; state.a, b: state =&gt; state.b &#125;) &#125;, methods: &#123; // 在 `module/moduleA` 中查找 ...mapActions([ &#x27;actionA&#x27;, &#x27;actionB&#x27; ]) &#125;&#125; Vuex插件有用过吗？怎么用简单介绍一下？Vuex插件就是一个函数，它接收 store 作为唯一参数。在Vuex.Store构造器选项plugins引入。 在store/plugin.js文件中写入 12345export default function createPlugin(param)&#123; return store =&gt;&#123; //... &#125;&#125; 然后在store/index.js文件中写入 123456import createPlugin from &#x27;./plugin.js&#x27;const myPlugin = createPlugin()const store = new Vuex.Store(&#123; // ... plugins: [myPlugin]&#125;) 在Vuex插件中怎么监听组件中提交mutation和action？ 用Vuex.Store的实例方法subscribe监听组件中提交mutation 用Vuex.Store的实例方法subscribeAction监听组件中提交action 在store/plugin.js文件中写入 123456789101112131415161718192021export default function createPlugin(param) &#123; return store =&gt; &#123; store.subscribe((mutation, state) =&gt; &#123; console.log(mutation.type)//是那个mutation console.log(mutation.payload) console.log(state) &#125;) // store.subscribeAction((action, state) =&gt; &#123; // console.log(action.type)//是那个action // console.log(action.payload)//提交action的参数 // &#125;) store.subscribeAction(&#123; before: (action, state) =&gt; &#123;//提交action之前 console.log(`before action $&#123;action.type&#125;`) &#125;, after: (action, state) =&gt; &#123;//提交action之后 console.log(`after action $&#123;action.type&#125;`) &#125; &#125;) &#125;&#125; 然后在store/index.js文件中写入 123456import createPlugin from &#x27;./plugin.js&#x27;const myPlugin = createPlugin()const store = new Vuex.Store(&#123; // ... plugins: [myPlugin]&#125;) 在v-model上怎么用Vuex中state的值？需要通过computed计算属性来转换。 123456789101112&lt;input v-model=&quot;message&quot;&gt;// ...computed: &#123; message: &#123; get () &#123; return this.$store.state.message &#125;, set (value) &#123; this.$store.commit(&#x27;updateMessage&#x27;, value) &#125; &#125;&#125; Vuex的严格模式是什么,有什么作用,怎么开启？在严格模式下，无论何时发生了状态变更且不是由 mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。 在Vuex.Store 构造器选项中开启,如下 123const store = new Vuex.Store(&#123; strict:true,&#125;) 如何解决vuex持久化问题","categories":[],"tags":[{"name":"vuex","slug":"vuex","permalink":"https://wisiw.github.io.git/tags/vuex/"}]},{"title":"【面试题】VueRouter","slug":"【面试题】VueRouter","date":"2021-02-20T02:37:28.000Z","updated":"2021-12-01T02:38:21.283Z","comments":true,"path":"2021/02/20/【面试题】VueRouter/","link":"","permalink":"https://wisiw.github.io.git/2021/02/20/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%91VueRouter/","excerpt":"","text":"Vue-Router基本应用怎么重定向页面第一种方法： 12345const router = new VueRouter(&#123; routes: [ &#123; path: &#x27;/a&#x27;, redirect: &#x27;/b&#x27; &#125; ]&#125;) 第二种方法: 12345const router = new VueRouter(&#123; routes: [ &#123; path: &#x27;/a&#x27;, redirect: &#123; name: &#x27;foo&#x27; &#125;&#125; ]&#125;) 第三种方法： 12345678910111213141516const router = new VueRouter(&#123; routes: [ &#123; path: &#x27;/a&#x27;, redirect: to =&gt;&#123; const &#123; hash, params, query &#125; = to if (query.to === &#x27;foo&#x27;) &#123; return &#123; path: &#x27;/foo&#x27;, query: null &#125; &#125;else&#123; return &#x27;/b&#x27; &#125; &#125; &#125; ]&#125;) 怎么配置404页面？1234567const router = new VueRouter(&#123; routes: [ &#123; path: &#x27;*&#x27;, redirect: &#123;path: &#x27;/&#x27;&#125; &#125; ]&#125;) 切换路由时，需要保存草稿的功能，怎么实现呢？123&lt;keep-alive :include=&quot;include&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; 路由有几种模式？说说它们的区别？ hash: 兼容所有浏览器，包括不支持 HTML5 History Api 的浏览器，例http://www.abc.com/#/index，hash值为#/index， hash的改变会触发hashchange事件，通过监听hashchange事件来完成操作实现前端路由。hash值变化不会让浏览器向服务器请求。 history: 兼容能支持 HTML5 History Api 的浏览器，依赖HTML5 History API来实现前端路由。没有#，路由地址跟正常的url一样，但是初次访问或者刷新都会向服务器请求，如果没有请求到对应的资源就会返回404，所以路由地址匹配不到任何静态资源，则应该返回同一个index.html 页面，需要在nginx中配置。 abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式。 讲一下完整的导航守卫流程？导航被触发。 在失活的组件里调用离开守卫beforeRouteLeave(to,from,next)。 调用全局的beforeEach( (to,from,next) =&gt;&#123;&#125; )守卫。 在重用的组件里调用 beforeRouteUpdate(to,from,next) 守卫。 在路由配置里调用beforeEnter(to,from,next)路由独享的守卫。 解析异步路由组件。 在被激活的组件里调用beforeRouteEnter(to,from,next)。 在所有组件内守卫和异步路由组件被解析之后调用全局的beforeResolve( (to,from,next) =&gt;&#123;&#125; )解析守卫。 导航被确认。 调用全局的afterEach( (to,from) =&gt;&#123;&#125; )钩子。 触发 DOM 更新。 用创建好的实例调用beforeRouteEnter守卫中传给 next 的回调函数 12345beforeRouteEnter(to, from, next) &#123; next(vm =&gt; &#123; //通过vm访问组件实例 &#125;)&#125;, 导航守卫的三个参数的含义？to：即将要进入的目标 路由对象。 from：当前导航正要离开的路由对象。 next：函数，必须调用，不然路由跳转不过去。 next()：进入下一个路由。 next(false)：中断当前的导航。 next(&#39;/&#39;)或next(&#123; path: &#39;/&#39; &#125;) : 跳转到其他路由，当前导航被中断，进行新的一个导航。 全局导航守卫有哪些？怎么使用？ router.beforeEach：全局前置守卫。 router.beforeResolve：全局解析守卫。 router.afterEach：全局后置钩子。 在afterEach钩子中可以使用next()吗？不可以，不接受next的参数。 什么是路由独享的守卫，怎么使用？是beforeEnter守卫 1234567891011const router = new VueRouter(&#123; routes: [ &#123; path: &#x27;/foo&#x27;, component: Foo, beforeEnter: (to, from, next) =&gt; &#123; // ... &#125; &#125; ]&#125;) 说说你对router-link的了解&lt;router-link&gt;是Vue-Router的内置组件，在具有路由功能的应用中作为声明式的导航使用。 &lt;router-link&gt;有8个props，其作用是： to ：必填，表示目标路由的链接。当被点击后，内部会立刻把to的值传到 router.push()，所以这个值可以是一个字符串或者是描述目标位置的对象。 12345&lt;router-link to=&quot;home&quot;&gt;Home&lt;/router-link&gt;&lt;router-link :to=&quot;&#x27;home&#x27;&quot;&gt;Home&lt;/router-link&gt;&lt;router-link :to=&quot;&#123; path: &#x27;home&#x27; &#125;&quot;&gt;Home&lt;/router-link&gt;&lt;router-link :to=&quot;&#123; name: &#x27;user&#x27;, params: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;/router-link&gt;&lt;router-link :to=&quot;&#123; path: &#x27;user&#x27;, query: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;/router-link&gt; 注意path存在时params不起作用，只能用query replace：默认值为false，若设置的话，当点击时，会调用router.replace()而不是router.push()，于是导航后不会留下 history 记录。 append：设置 append 属性后，则在当前 (相对) 路径前添加基路径。 tag：让&lt;router-link&gt;渲染成tag设置的标签，如tag:&#39;li,渲染结果为&lt;li&gt;foo&lt;/li&gt;。 active-class：默认值为router-link-active,设置链接激活时使用的 CSS 类名。默认值可以通过路由的构造选项 linkActiveClass 来全局配置。 exact-active-class：默认值为router-link-exact-active,设置链接被精确匹配的时候应该激活的 class。默认值可以通过路由构造函数选项 linkExactActiveClass 进行全局配置的。 exact：是否精确匹配，默认为false。 12&lt;!-- 这个链接只会在地址为 / 的时候被激活 --&gt;&lt;router-link to=&quot;/&quot; exact&gt;&lt;/router-link&gt; event：声明可以用来触发导航的事件。可以是一个字符串或是一个包含字符串的数组，默认是click。 怎么在组件中监听路由参数的变化？有两种方法可以监听路由参数的变化，但是只能用在包含&lt;router-view /&gt;的组件内。 第一种 12345watch: &#123; &#x27;$route&#x27;(to, from) &#123; //这里监听 &#125;,&#125;, 第二种 123beforeRouteUpdate (to, from, next) &#123; //这里监听&#125;, 切换路由后，新页面要滚动到顶部或保持原先的滚动位置怎么做呢？滚动顶部 123456789101112const router = new Router(&#123; mode: &#x27;history&#x27;, base: process.env.BASE_URL, routes, scrollBehavior(to, from, savedPosition) &#123; if (savedPosition) &#123; return savedPosition; &#125; else &#123; return &#123; x: 0, y: 0 &#125;; &#125; &#125;&#125;); 路由组件和路由为什么解耦，怎么解耦？因为在组件中使用 $route 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性，所有要解耦。 耦合如以下代码所示。Home组件只有在 1http://localhost:8036/home/123 URL上才能使用。 12345678const Home = &#123; template: &#x27;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&#x27;&#125;const router = new VueRouter(&#123; routes: [ &#123; path: &#x27;/home/:id&#x27;, component: Home &#125; ]&#125;) 使用 props 来解耦 props为true，route.params将会被设置为组件属性。 props为对象，则按原样设置为组件属性。 props为函数，http://localhost:8036/home?id=123,会把123传给组件Home的props的id。 1234567891011121314151617const Home = &#123; props: [&#x27;id&#x27;], template: &#x27;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;&#x27;&#125;const router = new VueRouter(&#123; routes: [ &#123; path: &#x27;/home/:id&#x27;, component: Home, props: true&#125;, // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项： &#123; path: &#x27;/home/:id&#x27;, components: &#123; default: Home, sidebar: Sidebar &#125;, props: &#123; default: true, sidebar: false &#125; &#125; &#123; path: &#x27;/home&#x27;, component: Home, props: &#123;id:123&#125; &#125;, &#123; path: &#x27;/home&#x27;, component: Home, props: (route) =&gt; (&#123; id: route.query.id &#125;) &#125;, ]&#125;) route和router有什么区别 route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。 router是“路由实例对象”，包括了路由的跳转方法，钩子函数等。 路由之间是怎么跳转的？有哪些方式？ 声明式 通过使用内置组件&lt;router-link :to=&quot;/home&quot;&gt;来跳转 编程式 通过调用router实例的push方法router.push(&#123; path: &#39;/home&#39; &#125;)或replace方法router.replace(&#123; path: &#39;/home&#39; &#125;) 怎么实现路由懒加载呢123456789101112131415function load(component) &#123; //return resolve =&gt; require([`views/$&#123;component&#125;`], resolve); return () =&gt; import(`views/$&#123;component&#125;`);&#125;const routes = [ &#123; path: &#x27;/home&#x27;, name: &#x27;home&#x27;, component: load(&#x27;home&#x27;), meta: &#123; title: &#x27;首页&#x27; &#125;, &#125;,] 怎样动态加载路由使用Router的实例方法addRoutes来实现动态加载路由，一般用来实现菜单权限。 使用时要注意，静态路由文件中不能有404路由，而要通过addRoutes一起动态添加进去。 1234567891011121314151617181920const routes = [ &#123; path: &#x27;/overview&#x27;, name: &#x27;overview&#x27;, component: () =&gt; import(&#x27;@/views/account/overview/index&#x27;), meta: &#123; title: &#x27;账户概览&#x27;, pid: 869, nid: 877 &#125;, &#125;, &#123; path: &#x27;*&#x27;, redirect: &#123; path: &#x27;/&#x27; &#125; &#125;]vm.$router.options.routes.push(...routes);vm.$router.addRoutes(routes); active-class是哪个组件的属性&lt;router-link/&gt;组件的属性，设置链接激活时使用的 CSS 类名。默认值可以通过路由的构造选项 linkActiveClass 来全局配置 Vue路由怎么跳转打开新窗口12345678const obj = &#123; path: xxx,//路由地址 query: &#123; mid: data.id//可以带参数 &#125;&#125;;const &#123;href&#125; = this.$router.resolve(obj);window.open(href, &#x27;_blank&#x27;);","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://wisiw.github.io.git/tags/Vue/"},{"name":"VueRouter","slug":"VueRouter","permalink":"https://wisiw.github.io.git/tags/VueRouter/"}]},{"title":"【代码片段】获取一个页面中使用最多的标签","slug":"【代码片段】获取一个页面中使用最多的标签","date":"2021-02-20T01:45:57.000Z","updated":"2021-09-23T06:13:08.631Z","comments":true,"path":"2021/02/20/【代码片段】获取一个页面中使用最多的标签/","link":"","permalink":"https://wisiw.github.io.git/2021/02/20/%E3%80%90%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E3%80%91%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%9C%80%E5%A4%9A%E7%9A%84%E6%A0%87%E7%AD%BE/","excerpt":"","text":"12345678910111213141516171819202122232425function getTagRank(ranks)&#123; if(typeof ranks !== &#x27;number&#x27;)&#123; throw new Error(&#x27;typeerror:获取标签的数量必须是number类型&#x27;); return; &#125; // 获取当前页面所有标签 let tags = [...document.querySelectorAll(&#x27;*&#x27;)].map(node=&gt;node.nodeName); let obj = &#123;&#125;; // 获取所有标签的数量 tags.forEach(item =&gt;&#123; if(!obj[item])&#123; obj[item] = 1; &#125;else&#123; obj[item] += 1; &#125; &#125;); // 根据数量从大到小排序 let tagRank = Object.keys(obj).sort((a,b)=&gt;&#123; return obj[b] - obj[a]; &#125;); // 根据ranks截取长度 tagRank.length = ranks; return tagRank; &#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://wisiw.github.io.git/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wisiw.github.io.git/tags/JavaScript/"},{"name":"代码片段","slug":"代码片段","permalink":"https://wisiw.github.io.git/tags/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"}]},{"title":"【面试题】JavaScript编程题","slug":"【面试题】JavaScript编程题","date":"2021-02-18T04:09:21.000Z","updated":"2021-12-01T02:38:02.216Z","comments":true,"path":"2021/02/18/【面试题】JavaScript编程题/","link":"","permalink":"https://wisiw.github.io.git/2021/02/18/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%91JavaScript%E7%BC%96%E7%A8%8B%E9%A2%98/","excerpt":"","text":"柯里化实现 add(1)(2)(3)123456789101112131415161718192021function add () &#123; const numberList = Array.from(arguments); // 进一步收集剩余参数 const calculate = function() &#123; numberList.push(...arguments); return calculate; &#125; // 利用 toString 隐式转换，最后执行时进行转换 calculate.toString = function() &#123; return numberList.reduce((a, b) =&gt; a + b, 0); &#125; return calculate;&#125;// 实现一个 add 方法，使计算结果能够满足以下预期console.log(add(1)(2)(3)); // 6console.log(add(1, 2, 3)(4)); // 10;console.log(add(1)(2)(3)(4)(5)); // 15; 实现 compose(foo, bar, baz)(‘start’)12345678910111213141516171819202122232425262728293031323334353637383940414243function foo(...args) &#123; console.log(args[0]); return &#x27;foo&#x27;;&#125;function bar(...args) &#123; console.log(args[0]); return &#x27;bar&#x27;;&#125;function baz(...args) &#123; console.log(args[0]); return &#x27;baz&#x27;;&#125;function compose() &#123; // 闭包元素 - 函数列表 const list = Array.from(arguments); // 闭包元素 - 函数列表执行位置 let index = -1; // 闭包元素 - 上一个函数的返回 let prev = &#x27;&#x27;; // 返回闭包函数 const doNext = function() &#123; index++; // 索引值累加 // 一开始没有上一个元素时，获取第二个括号的值 if (!prev) &#123; prev = arguments[0]; &#125; // 设置前一个结果为当前函数返回 prev = list[index](prev); // 递归调用 if (index &lt; list.length - 1) &#123; doNext(index + 1); &#125; &#125;; // 第一次返回闭包函数 return doNext;&#125;compose(foo, bar, baz)(&#x27;start&#x27;); 选择题12345678910111213141516171819202122function test() &#123; var n = 4399; function add() &#123; n++; console.log(n); &#125; return &#123; n, add &#125;;&#125;;var result = test();var result2 = test();result.add(); // 输出啥result.add(); // 输出啥console.log(result.n); // 输出啥result2.add(); // 输出啥// 4400 4401 4399 4400 1234567891011121314function Foo() &#123; var i = 0; return function() &#123; console.log(i++); &#125;&#125;var f1 = Foo();var f2 = Foo();f1();f1();f2();// 0 1 0","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://wisiw.github.io.git/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"编程题","slug":"编程题","permalink":"https://wisiw.github.io.git/tags/%E7%BC%96%E7%A8%8B%E9%A2%98/"}]},{"title":"【browser】从输入 URL 到页面呈现","slug":"【browser】从输入-URL-到页面呈现","date":"2021-02-17T14:21:23.000Z","updated":"2021-11-18T05:33:10.927Z","comments":true,"path":"2021/02/17/【browser】从输入-URL-到页面呈现/","link":"","permalink":"https://wisiw.github.io.git/2021/02/17/%E3%80%90browser%E3%80%91%E4%BB%8E%E8%BE%93%E5%85%A5-URL-%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0/","excerpt":"","text":"1.DNS解析根据域名解析出IP地址 DNS 解析过程： 查询 www.baidu.com 访问客户端 DNS 缓存： 浏览器缓存 -&gt; 系统缓存（host） -&gt; 路由器缓存 访问 ISP DNS 服务器（ISP，互联网服务提供商，有联通电信移动等。如果你是电信网络，则进入电信的 DNS 缓存服务器，以下简称本地），如果本地服务器有，则直接返回；如果没有，让本地 DNS 服务器去咨询查找。 本地去咨询 DNS 根服务器，DNS 根服务器发现是 .com 区域 管理的，告诉本地去咨询它。 本地去咨询 .com 顶级域名服务器，.com 顶级域名服务器不太清楚，告诉本地去咨询 baidu.com 主区域 的服务器。 本地去咨询 baidu.com 主域名服务器，baidu.com 域服务器查找到对应的 IP 地址，返回给本地。 本地服务器通知用户， baidu.com 对应的 IP 地址，同时缓存这个 IP 地址，下次就直接访问了。 2.TCP连接 建立连接阶段：3 次握手。建立客户端和服务器之间的连接。 传输数据阶段 断开连接阶段：4 次挥手。断开客户端和服务器之间的连接。 3.发送HTTP请求构建 HTTP 请求报文，并通过 TCP 协议发送到服务器指定端口（HTTP 协议默认端口 80/8080，HTTPS 协议默认端口 443） HTTP 请求报文由 3 部分组成：请求行、请求报文 和 请求正文。 请求行：常用方法有：GET、POST、PUT、DELETE、OPTIONS、HEAD。 请求报头：允许客户端向服务器传递请求的附加信息和客户端自身的信息。 请求正文：通过 POST、PUT 等方法时，通常需要客户端向服务器传递数据，这些数据就储存在请求正文中。 4.服务器响应服务器处理请求完毕后，会返回 HTTP 报文。 HTTP 响应报文也是由 3 部分组成：状态码、响应报头 和 响应报文 状态码： 1xx 指示信息-表示请求已接收； 2xx 请求成功-表示请求成功接收并解析； 3xx 重定向-表示要完成请求需要更进一步操作； 4xx 客户端错误-请求有语法错误或者请求无法实现； 5xx：服务端错误-服务端未能实现合法的请求。 常见状态码：200（成功）、304（请求内容有缓存，不需要更新）、404（网页或者文件找不到）、500（服务器-后端处理错误）。 响应报头：常见的响应报头字段 Server、 Connection 等。 响应报文：服务器返回给浏览器的文本信息，通常 HTML、CSS、JS、图片等文件就放在这一部分 5.浏览器渲染 解析 HTML，生成 DOM 树 解析 CSS，生成 CSS 规则树（CSS Rule Tree） 将 DOM Tree 和 CSS Rule Tree 相结合，生成 渲染树（ Render Tree） 从根节点开始，计算每一个元素的大小、位置，给出每个节点所应该出现的屏幕精确坐标，从而得到基于渲染树的 布局渲染树（ Layout of the render tree）。 遍历渲染树，将每个节点用 UI 渲染引擎来绘制，从而将整棵树绘制到页面上，这个步骤叫 绘制渲染树（ Painting the render tree） 在解析渲染过程中，可能会产生 回流 和 重绘： 重绘(repaint)**：当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要 UI 层面的重新像素绘制，因此 **损耗较少。 **回流(reflow)**：又叫重排（ layout）。当元素的尺寸、结构或者触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。 在构建 DOM 的时候，HTML 解析器如果碰到 JavaScript，那么就会停止构建 DOM，将控制权交给 JavaScript 引擎，等 JavaScript 运行完毕，浏览器再从中断的地方恢复 DOM 构建 也就是说：首屏渲染越快，就越不应该在首屏的时候加载 JS 文件，这也就是建议将 script 标签放到 body 标签底部，或者给 script 标签添加 defer/async 属性的原因","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://wisiw.github.io.git/tags/%E5%89%8D%E7%AB%AF/"},{"name":"面试题","slug":"面试题","permalink":"https://wisiw.github.io.git/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"browser","slug":"browser","permalink":"https://wisiw.github.io.git/tags/browser/"}]},{"title":"【JavaScript】数据结构与算法","slug":"【JavaScript】数据结构与算法","date":"2021-02-16T14:12:25.000Z","updated":"2021-09-23T06:20:22.898Z","comments":true,"path":"2021/02/16/【JavaScript】数据结构与算法/","link":"","permalink":"https://wisiw.github.io.git/2021/02/16/%E3%80%90JavaScript%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","excerpt":"","text":"","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wisiw.github.io.git/tags/JavaScript/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://wisiw.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"Flux架构","slug":"Flux架构","date":"2021-02-10T19:57:04.000Z","updated":"2021-06-21T08:12:55.908Z","comments":true,"path":"2021/02/11/Flux架构/","link":"","permalink":"https://wisiw.github.io.git/2021/02/11/Flux%E6%9E%B6%E6%9E%84/","excerpt":"","text":"","categories":[],"tags":[{"name":"架构","slug":"架构","permalink":"https://wisiw.github.io.git/tags/%E6%9E%B6%E6%9E%84/"},{"name":"Flux","slug":"Flux","permalink":"https://wisiw.github.io.git/tags/Flux/"}]},{"title":"【Java】MyBatis生成工具","slug":"【Java】MyBatis生成工具","date":"2021-02-05T08:11:54.000Z","updated":"2021-09-23T05:58:41.007Z","comments":true,"path":"2021/02/05/【Java】MyBatis生成工具/","link":"","permalink":"https://wisiw.github.io.git/2021/02/05/%E3%80%90Java%E3%80%91MyBatis%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7/","excerpt":"","text":"1.MyBatis Genneratorpom123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;util&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.3.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.shenjia&lt;/groupId&gt; &lt;artifactId&gt;MyBatisX&lt;/artifactId&gt; &lt;version&gt;0.0.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;version&gt;2.3.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.9&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.15&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;configuration&gt; &lt;configurationFile&gt;src/main/resources/generatorConfig.xml&lt;/configurationFile&gt; &lt;overwrite&gt;false&lt;/overwrite&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; source/application.yml123456spring: datasource: driverClassName: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/XXXX?useUnicode=true&amp;serverTimezone=Asia/Shanghai&amp;autoReconnect=true&amp;characterEncoding=utf-8 username: root password: 106613 source/generatorConfig.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;!--mysql 连接数据库jar 这里选择自己本地位置--&gt; &lt;classPathEntry location=&quot;C:/Users/wsw/.m2/repository/mysql/mysql-connector-java/8.0.13/mysql-connector-java-8.0.13.jar&quot; /&gt; &lt;context id=&quot;MysqlTables&quot; targetRuntime=&quot;MyBatis3Simple&quot; defaultModelType=&quot;flat&quot;&gt; &lt;property name=&quot;autoDelimitKeywords&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;javaFileEncoding&quot; value=&quot;utf-8&quot;/&gt; &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt; &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt; &lt;/commentGenerator&gt; &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/XXXX?serverTimezone=Asia/Shanghai&amp;amp;nullCatalogMeansCurrent=true&quot; userId=&quot;XXXX&quot; password=&quot;XXXX&quot;&gt; &lt;/jdbcConnection&gt; &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 NUMERIC 类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt; &lt;/javaTypeResolver&gt; &lt;!-- targetProject:生成PO类的位置 --&gt; &lt;javaModelGenerator targetPackage=&quot;model&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!-- targetProject:mapper映射文件生成的位置 如果maven工程只是单独的一个工程，targetProject=&quot;src/main/java&quot; 若果maven工程是分模块的工程，targetProject=&quot;所属模块的名称&quot;，例如： targetProject=&quot;ecps-manager-mapper&quot;，下同--&gt; &lt;sqlMapGenerator targetPackage=&quot;sqlmap&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- targetPackage：mapper接口生成的位置 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;dao&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定数据库表 --&gt; &lt;table schema=&quot;general&quot; tableName=&quot;%&quot; enableInsert=&quot;true&quot; enableDeleteByPrimaryKey=&quot;true&quot; enableSelectByPrimaryKey=&quot;true&quot; enableUpdateByPrimaryKey=&quot;true&quot; selectByPrimaryKeyQueryId=&quot;true&quot; enableCountByExample= &quot;false&quot; enableUpdateByExample= &quot;false&quot; enableDeleteByExample= &quot;false&quot; enableSelectByExample= &quot;false&quot; selectByExampleQueryId= &quot;false&quot;&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 2.Mybatis Plus待续","categories":[],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://wisiw.github.io.git/tags/mybatis/"},{"name":"工具","slug":"工具","permalink":"https://wisiw.github.io.git/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"【Java】微服务架构搭建","slug":"【Java】微服务架构搭建","date":"2021-02-05T07:55:11.000Z","updated":"2021-09-23T06:02:07.916Z","comments":true,"path":"2021/02/05/【Java】微服务架构搭建/","link":"","permalink":"https://wisiw.github.io.git/2021/02/05/%E3%80%90Java%E3%80%91%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%90%AD%E5%BB%BA/","excerpt":"","text":"主要搭建两个框架，使用IntelliJ IDEA Spring Boot和Spring Cloude 1）Spring Boot 2）Spring Cloude","categories":[{"name":"微服务","slug":"微服务","permalink":"https://wisiw.github.io.git/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://wisiw.github.io.git/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"教程","slug":"教程","permalink":"https://wisiw.github.io.git/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"【面试题】JavaScript","slug":"【面试题】JavaScript","date":"2021-02-04T09:20:55.000Z","updated":"2021-11-18T06:00:33.221Z","comments":true,"path":"2021/02/04/【面试题】JavaScript/","link":"","permalink":"https://wisiw.github.io.git/2021/02/04/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%91JavaScript/","excerpt":"","text":"一、数据类型1.JavaScript有哪些数据类型，它们的区别？Null、Undefined、Boolean、String、Number、Object 基本数据类型：Boolean、String、Number，因为简单、数据量小、大小固定、频繁调用，所以保存在栈中 引用数据类型：Object、Array、Function，因为结构复杂、占据空间大、大小不固定，所以保存在堆中，栈中之保存了指针，指向数据在栈中的地址 2.数据类型检测的方式有哪些 typeOf，只能检查基本数据类型和函数，null返回Object，因为null的类型标签为0，而Object的类型标签为000 instanceOf，只能检查引用类型，用来检测当前对象在其原型链中是否存在一个构造函数prototype属性 constructor，能判断全部类型，因为是通过对象的原型判断，所以当原型被修改，就不能判断了 Object.prototype.toString.call()，能判断全部类型 为什么不适用被检测对象的toString（）?因为Array、Function等作为Objec的实例，都重写了toString()方法 3.判断数组的方式有哪些 Object.prototype.toString.call() obj.__proto__ === Array.prototype Array.isArray obj instanceof Array 4.null和undefined区别null表示空对象 undefined表示未定义 5.typeof null 的结果是什么，为什么？6.intanceof 操作符的实现原理及实现使用Object.getPrototypeOf()与while(true)去判断构造函数的prototype是否在被检测对象的原型链上 7.为什么0.1+0.2 ! == 0.3，如何让其相等8.如何获取安全的 undefined 值？9.typeof NaN 的结果是什么？10.isNaN 和 Number.isNaN 函数的区别？11.== 操作符的强制类型转换规则？12.其他值到字符串的转换规则？13.其他值到数字值的转换规则？14.其他值到布尔类型的值的转换规则？15.|| 和 &amp;&amp; 操作符的返回值？16.Object.is() 与比较操作符 === ==的区别？Object.is()一般情况下与===相同，但它处理了一些特殊情况，比如Object.is(-0,+0) // false和Object.is(NaN,NaN) // true 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980```===```会先比较类型## 17.什么是 JavaScript 中的包装类型？## 18.JavaScript 中如何进行隐式类型转换？## 19.+操作符什么时候用于字符串的拼接？## 20.为什么会有BigInt的提案？## 21.object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别# 二、ES6## 1.let、const、var的区别块级作用域：解决了内层变量可能覆盖外层变量、用来计数的循环变量泄露为全局变量变量提升：const、let只能在声明后使用全局属性：const、let不会挂载在全局变量上，浏览器的全局变量是window，node的全局变量是global重复声明：let、const不能重复声明暂时性死区：let、const在声明之前，不可用初始值设置：const使用必须设置初始值指针指向：let可以更改指针指向，const不可以# JavaScript为什么要进行变量提升，它导致了什么问题？变量提升：无论在函数中处于何处声明的变量，都被提升到了函数的前端，可以在变量声明前访问而不会报错本质原因：js引擎在代码执行前有一个解析的过程，创建饿了执行上下文，初始化了一些代码执行时需要用到的对象。当访问一个变量时，会到当前执行上下文的作用域链中去查找，而作用域链首端指向的当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，包含了函数的形参、所有函数和变量声明，这个对象是在代码解析的时候创建的JS引擎在拿到变量或者一个函数时，会有两步操作，即解析和执行解析：检查语法，并对函数进行预编译，解析时会创建一个**全局执行上下文环境**，先把代码中即将执行的变量和函数声明拿出来，变量先赋值为undefined，函数先声明好可使用，在一个函数执行之前，也会创建一个**函数执行上下文环境**，比全局执行上下文多出this为什么？**提高性能，让函数可以在执行时预先为变量分配栈空间**：在代码执行前，只对代码执行一次语法检查和预编译，统计声明了哪些变量、创建了哪些函数，并对代码进行压缩，去除注释和不必要的空白，这样每次执行函数时都可以为该函数分配栈空间（不需要再去解析一遍获取代码中声明了哪些变量，创建了哪些函数）**容错性更好**## 2.const对象的属性可以修改吗## 3.如果new一个箭头函数的会怎么样## 4.箭头函数与普通函数的区别简洁没有自己的this，只会在自己的作用域上一层继承this，因此箭头函数的this指向在定义时就已经确定了，之后不会改变this指向不能被修改不能作为构造函数使用，因为没有自己的this没有自己的arguments没有原型链prototype不能作为构造函数，也不能使用yeild关键字## 5.箭头函数的this指向哪⾥？是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变```javascript// ES6 const obj = &#123; getArrow() &#123; return () =&gt; &#123; console.log(this === obj); &#125;; &#125; &#125; 123456789// ES5，由 Babel 转译var obj = &#123; getArrow: function getArrow() &#123; var _this = this; return function () &#123; console.log(_this === obj); &#125;; &#125; &#125;; 6.扩展运算符的作用及使用场景7.Proxy 可以实现什么功能？8.对对象与数组的解构的理解9.如何提取高度嵌套的对象里的指定属性？10.对 rest 参数的理解11.ES6中模板语法与字符串处理三、JavaScript基础1.new操作符的实现原理创建一个对象 设置当前对象的原型，将对象的原型设置为函数的prototype对象 修改函数的this指向当前对象 判断函数的返回值类型，如果是值，返回创建的对象。如果是引用类型，返回引用类型的对象 12345678910111213function myNew() &#123; let obj = null; let constructor = Array.prototype.shift.call(arguments); let res = null; if (typeOf constructor !== &quot;function&quot;) &#123; console.error(&quot;type errror&quot;); return; &#125; obj = Object.create(constructor.prototype); res = constructor.apply(obj, arguments); let flag = res &amp;&amp; ( typeOf res === &quot;object&quot; || typeOf res === &quot;function&quot;); return flag ? res : obj&#125; 2.map和Object的区别 Map Object 键的命名 默认情况不包含任何键，只包含显式插入的键 有一个原型，原型链上的键名可能会与在对象设置的键名冲突 键的类型 任意值，包括函数、对象或任意基本类型 必须是String或Symbol 键的顺序 有序，当迭代时，以插入的顺序返回键值 无序 size 通过size属性获取 只能手动计算 迭代 可以直接被迭代 需要先获取键然后才能迭代 性能 适用于频繁增删键值对的情况 3.map和weakMap的区别4.JavaScript有哪些内置对象全局的对象（global objects） 值属性： 函数属性 基本对象 数字和日期 字符串 可索引的集合对象 使用键的集合对象 矢量集合 结构化数据 控制抽象对象 反射 国际化 WebAssembly 其他 5.常用的正则表达式有哪些？6.对JSON的理解7.JavaScript脚本延迟加载的方式有哪些？ defer，让脚本的加载和文档的解析同步解析，然后在文档解析完成后再执行这个脚本，保证页面渲染不被阻塞，执行顺序可测，但在一些浏览器中不会 async，使脚本异步加载，不会阻塞页面的渲染进程，但是当脚本加载完成后会立即执行，这个时候如果文档没有解析完成会阻塞，渲染顺序不可测 动态创建DOM setTimeout 脚本最后加载 8.JavaScript 类数组对象的定义？9.数组有哪些原生方法？10.Unicode、UTF-8、UTF-16、UTF-32的区别？11.常见的位运算符有哪些？其计算规则是什么？12.为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?13.什么是 DOM 和 BOM？14.对类数组对象的理解，如何转化为数组15.escape、encodeURI、encodeURIComponent 的区别16.对AJAX的理解，实现一个AJAX请求123456789101112131415161718let xhr = new XMLHttpRequest();xhr.open(&quot;GET&quot;, url, true);xhr.onreadystatechange = function() &#123; if (this.readyState !== 4) return; if (this.status === 200) &#123; handle(this.response); &#125; else &#123; console.error(this.statusText); &#125;&#125;xhr.onerror = function() &#123; console.log(this.statusText);&#125;// 设置相应数据类型xhr.responseType = &quot;json&quot;// 设置请求头信息xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);xhr.send(null) 17.18.什么是尾调用，使用尾调用有什么好处？19.ES6模块与CommonJS模块有什么异同？20.常见的DOM操作有哪些21.use strict是什么意思 ? 使用它区别是什么？22.如何判断一个对象是否属于某个类？23.强类型语言和弱类型语言的区别24.解释性语言和编译型语言的区别（1）解释型语言 使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。是代码在执行时才被解释器一行行动态翻译和执行，而不是在执行之前就完成翻译。解释型语言不需要事先编译，其直接将源代码解释成机器码并立即执行，所以只要某一平台提供了相应的解释器即可运行该程序。其特点总结如下 解释型语言每次运行都需要将源代码解释称机器码并执行，效率较低； 只要平台提供相应的解释器，就可以运行源代码，所以可以方便源程序移植； JavaScript、Python等属于解释型语言。 （2）编译型语言 使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式。在编译型语言写的程序执行之前，需要一个专门的编译过程，把源代码编译成机器语言的文件，如exe格式的文件，以后要再运行时，直接使用编译结果即可，如直接运行exe文件。因为只需编译一次，以后运行时不需要编译，所以编译型语言执行效率高。其特点总结如下： 一次性的编译成平台相关的机器语言文件，运行时脱离开发环境，运行效率高； 与特定平台相关，一般无法移植到其他平台； C、C++等属于编译型语言。 两者主要区别在于： 前者源程序编译后即可在该平台运行，后者是在运行期间才编译。所以前者运行速度快，后者跨平台性好。 25.for…in和for…of的区别for…in遍历的是对象的键名，for…of遍历的是对象的键值 123456789var list = [1,2,3]for(var i in list) &#123; console.log(i)&#125;// 0，1，2for(var i in list) &#123; console.log(i)&#125;// 1，2，3 for…in会遍历对象的整个原型链 对于数组for…in会返回数组中所有可枚举的属性（包括原型链上可枚举的属性），for…in只会返回数组的下标对应的属性值 for...in主要用于遍历对象，不适用于数组，for...of可以用来遍历所有包含迭代器接口的数据结构，返回各项的值 26.如何使用for…of遍历对象类数组对象 123456789var obj = &#123; 0:&#x27;one&#x27;, 1:&#x27;two&#x27;, length: 2&#125;;obj = Array.from(obj);for(var k of obj)&#123; console.log(k)&#125; 非类数组对象 123456789101112131415161718192021222324252627282930313233343536373839404142//方法一：var obj = &#123; a:1, b:2, c:3&#125;;obj[Symbol.iterator] = function()&#123; var keys = Object.keys(this); var count = 0; return &#123; next()&#123; if(count&lt;keys.length)&#123; return &#123;value: obj[keys[count++]],done:false&#125;; &#125;else&#123; return &#123;value:undefined,done:true&#125;; &#125; &#125; &#125;&#125;;for(var k of obj)&#123; console.log(k);&#125;// 方法二var obj = &#123; a:1, b:2, c:3&#125;;obj[Symbol.iterator] = function*()&#123; var keys = Object.keys(obj); for(var k of keys)&#123; yield [k,obj[k]] &#125;&#125;;for(var [k,v] of obj)&#123; console.log(k,v);&#125; 27.ajax、axios、fetch的区别AJAX：是一种创建交互式网页应用的网页开发技术，是在一种无需重新加载整个页面的情况下，能够更新部分网页的技术，通过后台与服务器进行少量数据交换，可以是网页实现一步更新 缺点：1）本身针对MVC编程，不符合MVVM规范；2）基于远程XHR开发，XHR本身架构不够清晰；3）不符合关注分离的原则；4）配置和调用方式非常混乱，而且基于时间的一步模型不友好 Fetch：基于ES6的promise对象设计，是原生js 优点：1）语法简洁，更加语义化；2）基于标准Promise实现，支持async/await；3）更加底层，提供丰富的API；4）脱离了XHR，是基于ES6的新规范实现的 缺点：1）只对网络请求报错，第400、500都当做成功的请求，不会reject，只有网络请求错误导致请求不能完成是，才会reject；2）默认不带cookie，需要添加配置项；3）不支持abort，不支持超时控制，setTimeout和Promise.reject的实现的超时控制并不能阻止请求过程在后台的运行；4）没办法原生监测请求的进度，XHR可以 Axios：是基于Promise封装的http请求客户端 1）不同端发起不同请求（浏览器端发起XMLHttpRequest请求，Node端发起http请求；2）支持Promise的API；3）监听请求和返回；4）对请求和返回进行转化；5）取消请求；6）自动转换json数据；7）客户端支持抵御XSRF攻击 28.数组的遍历方法有哪些29.forEach和map方法有什么区别四、原型与原型链1.对原型、原型链的理解js中是使用构造函数来新建一个对象，在每个构造函数内部都有一个prototype属性，它的属性值是一个对象，包含了可以由该创造函数的所有实例共享的属性和方法。当使用构造函数创建一个新的对象后，在这个对象内部将包含一个指针，指向构造函数的prototype属性对应的值，这个指针被称为原型，可以使用Object.getPrototype()来获取 当访问一个对象的属性时，如果当前对象内部不存在这个属性，那么就会去它的原型对象中去寻找这个属性，而这个原型对象又会有自己的原型，一直找下去的链路成为 原型链。原型链的尽头一般都是Object.prototype.__proto__为null js对象是通过引用来传递的，创建的每个对象实体中并没有一份属于自己的原型副本，因此当修改原型时，与之相关的对象也会继承这一改变 2.原型修改、重写3.原型链指向4.原型链的终点是什么？如何打印出原型链的终点？Object.prototype.__proto__ 5.如何获得对象非原型链上的属性？``hasOwnProperty``` 五、执行上下文/作用域链/闭包1.对闭包的理解有权访问另一函数作用域中变量的函数 用途： 在函数外部能够访问函数内部的变量，创建私有变量，vue的判断是否是html标签 将已经结束的函数上下文中的变量对象继续保存在内存中 2.对作用域、作用域链的理解全局作用域 最外层函数和最外层函数外面定义的变量拥有全局作用域 所有未定义直接赋值的变量自动声明为全局作用域 所有window对象的属性拥有全局作用域 全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。 函数作用域 函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到 作用域是分层的，内层作用域可以访问外层作用域，反之不行 块级作用域 使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由&#123; &#125;包裹的代码片段） let和const声明的变量不会有变量提升，也不可以重复声明 在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。 作用域链： 在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。 作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。 作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。 3.对执行上下文的理解执行上下文分为 全局执行上下文和 函数执行上下文， 全局执行上下文：js执行时，会创建一个全局的window对象，并且设置this的值等于这个全局对象，任何不在函数内部的都是全局执行上下文，一个程序中只会存在一个全局执行上下文 函数执行上下文：函数执行时，会创建一个新的执行上下文 执行上下栈：js引擎使用执行上下栈来管理执行上下文 当执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并且压入栈顶，引擎会执行位于上下文栈顶的函数，当函数执行完毕后，执行上下文从栈中弹出，继续执行下一个上下文，当所有代码都执行完毕后，从栈中弹出全局执行上下文 创建执行上下文： 创建执行上下文有两个阶段：创建阶段和执行阶段 1）创建阶段 （1）this绑定 在全局执行上下文中，this指向全局对象（window对象） 在函数执行上下文中，this指向取决于函数如何调用。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined （2）创建词法环境组件 词法环境是一种有标识符——变量映射的数据结构，标识符是指变量/函数名，变量是对实际对象或原始数据的引用。 词法环境的内部有两个组件：加粗样式：环境记录器:用来储存变量个函数声明的实际位置外部环境的引用：可以访问父级作用域 （3）创建变量环境组件 变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。 2）执行阶段 此阶段会完成对变量的分配，最后执行完代码。 简单来说执行上下文就是指： 在执行一点JS代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。 在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。 全局上下文：变量定义，函数声明 函数上下文：变量定义，函数声明，this，arguments 六、this/call/apply/bind1.对this对象的理解this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。 函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。 方法调用模式，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。 构造器调用模式，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。 2.call() 和 apply() 的区别？123456789101112131415161718```call()```接受的参数不固定，但第一个参数代表函数体内this对象的指向，之后的参数作为被调用函数的参数## 3.实现call、apply 及 bind 函数```javascriptfunction call(context) &#123; if (typeOf this !== &#x27;function&#x27;) &#123; console.error(&quot;this is not a function&quot;) return &#125; context = context || window const args = [...arguments]slice[1] context.fn = this const res = context.fn(args) delete context.fn() return res&#125; 七、异步编程1.异步编程的实现方式？2.setTimeout、Promise、Async/Await 的区别3.对Promise的理解Promise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理 4.Promise的基本用法5.Promise解决了什么问题6.Promise.all和Promise.race的区别的使用场景7.对async/await 的理解8.await 到底在等啥？9.async/await的优势10.async/await对比Promise的优势代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担 Promise传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅 错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获⾮常冗余 调试友好，Promise的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步。 11.async/await 如何捕获异常12.并发与并行的区别？ 并发是宏观概念，我分别有任务 A 和任务 B，在一段时间内通过任务间的切换完成了这两个任务，这种情况就可以称之为并发。 并行是微观概念，假设 CPU 中存在两个核心，那么我就可以同时完成任务 A、B。同时完成多个任务的情况就可以称之为并行。 13.什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？14.setTimeout、setInterval、requestAnimationFrame 各有什么特点？八、面向对象1.对象创建的方式有哪些？ 工厂模式 构造函数模式 原型模式 组合使用构造函数和原型模式 动态原型模式 寄生构造函数模式 2.对象继承的方式有哪些？ 原型链继承，但因为原型被所有实例对象共享，在修改引用类型的数据时，会造成污染 构造函数继承，通过在子类型的函数中调用超类型的构造函数来实现 组合继承，将原型继承和构造函数继承组合起来 原型式继承 寄生式继承 寄生式组合继承 九、垃圾回收与内存泄漏1.浏览器的垃圾回收机制2.哪些情况会导致内存泄漏基础1.null 和 undefined 的区别 null 表示 无 的对象，也就是此处不应该有值；而 undefined 表示未定义。 在转换数字的时候， Number(null) 为 0，而 Number(undefined) 为 NaN null： 作为函数的参数，表示该函数的参数不是对象。 作为对象原型链的终点。 Object.prototype.__proto__ === null undefined： 变量被声明但是没有赋值，等于 undefined。 调用函数时，对应的参数没有提供，也是 undefined。 对象没有赋值，这个属性的值为 undefined。 函数没有返回值，默认返回 undefined。 new关键字新建一个对象obj把obj的和构造函数通过原型链连接起来将构造函数的this指向obj如果该函数没有返回对象，则返回this 2.事件流3.typeof 和 instanceof 的区别 typeof：对某个变量类型的检测，基本类型除了 null 之外，都能正常地显示为对应的类型，引用类型除了函数会显示为 function，其他都显示为 object。 instanceof 主要用于检测某个构造函数的原型对象在不在某个对象的原型链上。 为什么&quot;object&quot;?因为 JavaScript 早起版本是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，所以它错误判断为 object 4.一句话描述this对于函数而言，指向最后调用函数的那个对象，是函数运行时内部自动生成的一个内部对象，只能在函数内部使用；对于全局而言，this 指向 window 普通函数中 this 的指向，是 this 执行时的上下文 箭头函数中 this 的指向，是 this 定义时的上下文 改变this的指向？1）保存指针let that = this 2）使用箭头函数：因为箭头函数不会创建其自身的执行上下文，函数中的this取决于外部函数，即谁调用它this就继承谁 3）call/apply/bind 5.执行上下文闭包是什么？在JavaScript中，根据作用域规则，内部函数总是可以访问外部函数声明的变量。 当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数应用外部函数的变量依旧保存在内存中，这些变量的集合称为闭包 函数B在函数A中调用了A中的变量，B就称之为A的闭包 优缺点 优点 1）缓存持久化 2）实现柯里化 缺点 1）内存消耗：闭包产生的变量无法被销毁 2）性能问题：闭包内部变量优先级高于外部变量，所以需要作用域链要多查找一级，影响查找速度 柯里化是什么？通过将接收多个参数换成一个参数，每次调用返回新函数的技术 通过闭包管理 支持链式调用 每次运行返回一个 function 为什么？ 参数复用 1234567891011121314151617181920// 校验数字let numberReg = /[0-9]+/g;// 校验小写字母let stringReg = /[a-z]+/g;// currying 后function curryingCheck(reg) &#123; return function(txt) &#123; return reg.test(txt); &#125;&#125;// 校验数字let checkNumber = curryingCheck(numberReg);let checkString = curryingCheck(stringReg);// 使用console.log(checkNumber(&#x27;13888888888&#x27;)); // trueconsole.log(checkString(&#x27;jsliang&#x27;)); // true 提前确认 延迟运行 作用域与作用域链 作用域： 作用域链：本质上是一个指向变量对象的指针列表 变量提升与函数提升函数提升是为了解决相互递归的问题，大体上可以解决自上而下的顺序问题 原型与原型链是什么？ 原型：在JavaScript中，每当定义一个对象时，对象中都会包含一些预定义的属性。 其中每个函数对象都有一个prototype属性，这个属性的指向被称为这个函数对象的原型对象（简称原型） 原型链：查找原型上存在的某个属性的的链式路径 如果某个实例对象不存在的某个属性，那么JavaScript会去改构造函数的原型上去找；如果原型上没有找到，那么会继续往Object的原型上，如果Object的原型上还是没有，会返回undefined 为什么？为了节约内存空间 __proto__与prototype的关系每个 JavaScript 对象（普通对象和函数对象）都具有一个属性 __proto__，这个属性会指向该对象的原型。 堆与栈Event Loop（事件循环）为什么？因为JavaScript是单线程语言，一次只能执行一件程序。单线程在程序执行的时候，所走的程序路径按照连续顺序排下来，依次执行，只有前面的程序执行结束才会执行接下来的程序。 如果遇到一些需要等待的程序，比如说setTimeOut就会造成延迟 因此，JavaScript为了协调时间、用户交互、脚本、渲染、网络等，就使用事件循环（Event Loop） 是什么？从script开始读取，不断循环，从“任务队列”中读取执行事件的过程。 执行过程 一开始整个脚本script作为一个宏任务执行 执行过程中，同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列 当前宏任务执行出对，检查微任务列表是否存在，有则一次执行，直至全部执行完毕 执行浏览器的UI线程的渲染工作 检查是否有web worker任务，有则执行 执行完本轮的宏任务，回到步骤2，依次循环，知道宏任务和微任务为空 宏任务、微任务是什么？事件循环的异步队列，是为了解决单线程阻塞的问题 宏任务队列可以有多个，但是微任务队列只有一个 宏任务：script、setTimeout、setInterval、setImmediate、I/O、UI rendering 微任务：MutationObserver、Promise.then()/catch()、fetch/axios（以Promise为基础开发）、V8垃圾回收过程、process.nextTick（Node独有） babel 编译原理 babylon 将 ES6/ES7 代码解析成 AST babel-traverse 对 AST 进行遍历转译，得到新的 AST 新 AST 通过 babel-generator 转换成 ES5 浏览器渲染过程 1）创建DOM树HTML解析器解析HTML元素，创建DOM树 2）创建CSS规则树CSS解析器解析CSS文件和内联与行内样式，生成页面的样式表 3）创建Render树将DOM树与CSS规则树关联起来，创建Render树 4）布局Layout根据Render树，浏览器开始布局，为每个Render树上的节点确定一个在显示器出现的精确坐标 5）绘制Painting在Render树和节点显示坐标的基础上，调用每个节点的paint方法，绘制出来 重绘：当元素样式的改变不影响布局时，只会对元素进行更新，此时只需要UI层面的额像素绘制，损耗较少 触发条件：background、color、visibility 回流：当元素尺寸、结构或者触发某些属性时，浏览器会重新渲染页面 触发条件：1）添加删除DOM元素；2）修改边框、边距、宽高等影响元素定位 的属性；3）浏览器窗口resize 回流必定会发生重绘，重绘不一定会引发回流。 1234567891011121314151617181920function a() &#123; console.log(1) return &quot;2&quot;&#125;function b() &#123; try&#123; console.log(3) return a() &#125;catch (e) &#123; console.log(5) return &quot;6&quot; &#125;finally &#123; console.log(7) return &quot;8&quot; &#125; return &quot;9&quot;&#125;console.log(b()) // 3 1 7 8// finally有return 那么return的就是finally的","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wisiw.github.io.git/tags/JavaScript/"},{"name":"面试题","slug":"面试题","permalink":"https://wisiw.github.io.git/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"【JavaScript】手写函数","slug":"【JavaScript】手写函数","date":"2021-02-02T07:32:39.000Z","updated":"2021-09-23T06:20:16.186Z","comments":true,"path":"2021/02/02/【JavaScript】手写函数/","link":"","permalink":"https://wisiw.github.io.git/2021/02/02/%E3%80%90JavaScript%E3%80%91%E6%89%8B%E5%86%99%E5%87%BD%E6%95%B0/","excerpt":"","text":"call()&amp;&amp;apply()&amp;&amp;bind()1.call()12345678910111213function call(Fn, obj, ...arg) &#123; if (obj === undefined || obj === null) &#123; obj = window; &#125; // 为obj添加临时方法,this自动指向obj obj.temp = Fn; // 调用temp方法 let result = obj.temp(...arg); // 删除临时方法 delete obj.temp; // 返回执行结果 return result;&#125; 2.apply()12345678910111213function call(Fn, obj, arg) &#123; if (obj === undefined || obj === null) &#123; obj = window; &#125; // 为obj添加临时方法,this自动指向obj obj.temp = Fn; // 调用temp方法 let result = obj.temp(...arg); // 删除临时方法 delete obj.temp; // 返回执行结果 return result;&#125; 3.bind()1234567function bind(Fn, obj, ...arg) &#123; // 返回一个新函数 return function (...arg2) &#123; // 通过call调用原函数, 并指定this为obj, 实参为args与args2 return call(Fn, obj, ...arg, ...arg2) &#125;&#125; 函数节流与防抖1.函数节流throttle()12345678910function throttle(callback, wait) &#123; let start = 0; return function (e) &#123; let now = Date.now(); if (now - start &gt; wait) &#123; callback.call(this, e) start = now; &#125; &#125;&#125; 2.函数防抖debounce()123456789101112function debounce(callback,time) &#123; let timeId = null; return function(e) &#123; if(timeId !== null)&#123; clearTimeout(timeId); &#125; timeId = setTimeout(function () &#123; callback.call(this,e); timeId = null; &#125;,time) &#125;&#125; 数组相关1.map()返回一个由回调函数的返回值组成的新数组 123456789function map(arr,callback) &#123; // 声明空数组 let result = []; for (let i = 0;i&lt;arr.length;i++)&#123; // 将callback的执行结果添加到数组中 result.push(callback(arr[i],i)) &#125; return result;&#125; 2.reduce()从左到右为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值 123456789function reduce(arr, callback, initValue) &#123; let result = initValue; // 执行callback for (let i = 0; i &lt; arr.length; i++) &#123; // 将回调函数的执行结果赋值给result result = callback(result, arr[i]); &#125; return result;&#125; 3.filter()将所有在过滤函数中返回 true 的数组元素放进一个新数组中并返回 1234567891011function filter(arr, callback) &#123; // 声明空数组 let result = []; for (let i = 0; i &lt; arr.length; i++) &#123; // 判断回调函数的返回值 if (callback(arr[i], i)) &#123; result.push(arr[i]) &#125; &#125; return result;&#125; 4.find()找到第一个满足测试函数的元素并返回那个元素的值，如果找不到，则返回 undefined 123456789101112function find(arr, callback) &#123; // 遍历数组 for (let i = 0; i &lt; arr.length; i++) &#123; // 判断执行结果 if (callback(arr[i], i)) &#123; // 返回当前正在遍历的元素 return arr[i]; &#125; &#125; // 没有遇到满足条件的元素，返回undefined return undefined;&#125; 5.findIndex()找到第一个满足测试函数的元素并返回那个元素的索引，如果找不到，则返回 -1 1234567891011function findIndex(arr, callback) &#123; // 遍历数组 for (let i = 0; i &lt; arr.length; i++) &#123; // 判断回调函数返回值 if (callback(arr[i], i)) &#123; return i &#125; &#125; // 找不到返回-1 return -1&#125; 6.every()如果数组中的每个元素都满足测试函数，则返回 true，否则返回 false 123456789function every(arr, callback) &#123; for (let i = 0; i &lt; arr.length; i++) &#123; // 只有一个结果为false, 直接返回false if (!callback(arr[i], i)) &#123; return false &#125; &#125; return true&#125; 7.some()如果数组中至少有一个元素满足测试函数，则返回 true，否则返回 false 123456789function some(arr, callback) &#123; for (let i = 0; i &lt; arr.length; i++) &#123; // 只有一个结果为true, 直接返回true if (callback(arr[i], i)) &#123; return true &#125; &#125; return false&#125; 8.数组去重8.1.利用forEach()和indexOf()本质是双重遍历, 效率差些 123456789function unique1 (arr) &#123; const result = [] arr.forEach(item =&gt; &#123; if (result.indexOf(item)===-1) &#123; result.push(item) &#125; &#125;) return result&#125; 8.2.利用forEach() + 对象容器只需一重遍历, 效率高些 1234567891011function unique2 (arr) &#123; const result = [] const obj = &#123;&#125; arr.forEach(item =&gt; &#123; if (!obj.hasOwnProperty(item)) &#123; obj[item] = true result.push(item) &#125; &#125;) return result&#125; 8.3.利用ES6语法: from + Set 或者 … + Set123function unique3 (arr) &#123; return [...new Set(arr)]&#125; 8.4.不使用多余空间1234567891011function unique4(arr) &#123; for (let i = 0; i &lt; arr.length; i++) &#123; for (let j = i + 1; j &lt; arr.length; j++) &#123; if (arr[i] === arr[j]) &#123; arr.splice(j, 1); j--; &#125; &#125; &#125; return arr;&#125; 9.数组合并1234567891011function concat(arr,...value) &#123; const array = [...arr] value.forEach(item =&gt; &#123; if(Array.isArray(item))&#123; array.push(...item) &#125;else&#123; array.push(item) &#125; &#125;) return array;&#125; 10.数组切片1234567891011121314151617181920212223242526function slice(arr, start, end) &#123; // 如果当前数组为[]，返回[] if (arr.length === 0) &#123; return [] &#125; // 如果开始位置大雨数组长度，返回[] start = start || 0 if (start &gt;= arr.length) &#123; return [] &#125; // 如果结束位置大于数组长度，end更新为数组长度 end = end || arr.length if (end &gt; arr.length) &#123; end = arr.length; &#125; // 如果结束位置小于等于开始位置，返回[] if (end &lt;= start) &#123; return [] &#125; let result = []; // 取出下标在[start,end)之间的元素，放入result中 for (let i = start; i &lt; end; i++) &#123; result.push(arr[i]) &#125; return result;&#125; 11.数组扁平化##11.1.递归 + concat() 12345678910111213function flatten1(arr) &#123; let result = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (Array.isArray(arr[i])) &#123; // 如果是数组，遍历 result = result.concat(flatten1(arr[i])) &#125; else &#123; // 不是数组，合并入result中 result = result.concat(arr[i]) &#125; &#125; return result;&#125; 11.2. … + some() + concat()1234567function flatten2(arr) &#123; let result = [].concat(...arr) // 如果数组中存在第二级，展开合并 while (result.some(item =&gt; Array.isArray(item))) &#123; result = [].concat(...result) &#125;&#125; 12.数组分块123456789101112131415161718function chunk(arr, size = 1) &#123; let result = []; let temp = []; // 遍历数组 arr.forEach(item =&gt; &#123; if (temp.length === 0) &#123; // 如果临时数组为空，压入结果数组中 result.push(temp) &#125; // 将元素压入临时数组中 temp.push(item) if (temp.length === size) &#123; // 长度满足后，清空temp temp = [] &#125; &#125;) return result;&#125; 13.数组求差集1234567891011function difference(arr1,arr2=[]) &#123; // 如果arr1为[]，返回[] if(arr1.length === 0)&#123; return []; &#125; // 如果arr2为[]，通过slice深拷贝arr1返回 if(arr2.length === 0)&#123; return arr1.slice(); &#125; return arr1.filter(item =&gt; !arr2.includes(item))&#125; 14.删除数组中部分元素14.1.pull([1,3,5,3,7], 2, 7, 3, 7) ===&gt; 原数组变为[1, 5], 返回值为[3,3,7]1234567891011121314function pull(arr, ...values) &#123; if (arr.length === 0 || values.length === 0) &#123; return []; &#125; let result = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (values.indexOf(arr[i]) !== -1) &#123; arr.splice(i,1); result.push(arr[i]); i--; &#125; &#125; return result;&#125; 14.2.pullAll([1,3,5,3,7], [2, 7, 3, 7]) ===&gt; 数组1变为[1, 5], 返回值为[3,3,7]123456function pullAll(arr, values) &#123; if (!values || !Array.isArray(values)) &#123; return []; &#125; return pull(arr, ...values)&#125; 16.获取数组部分元素16.1.drop(array, count)drop([1,3,5,7], 2) ===&gt; [5, 7] 123456function drop(arr, count = 1) &#123; if (arr.length === 0 || count &gt;= arr.length) &#123; return []; &#125; return arr.filter((item, i) =&gt; i &gt;= count)&#125; 16.2.dropRight(array, count)dropRight([1,3,5,7], 2) ===&gt; [1, 3] 123456function dropRight(arr, count = 1) &#123; if (arr.length === 0 || count &gt;= arr.length) &#123; return []; &#125; return arr.filter((item, i) =&gt; i &lt; arr.length - count)&#125; 对象相关new根据构造函数实例化对象 123456789function New(Fn, ...args) &#123; // 1.创建一个新对象 const obj = &#123;&#125;; // 2.修改函数内部的this指向新对象，并执行 const result = Fn.call(obj, ...args) obj.__proto__ = Fn.prototype; // 3.返回新对象 return result instanceof Object ? result : obj;&#125; instanceOf1234567891011121314function InstanceOf(obj,type) &#123; // 获取obj的隐式原型对象 let protoObj = obj.__proto__; // 遍历原型链 while (protoObj)&#123; // 检测obj的原型对象和type的原型对象是否相等 if (protoObj === type.__proto__)&#123; return true; &#125; // 不相等，向上查找原型对象 protoObj = protoObj.__proto__; &#125; return false;&#125; 对象合并1234567891011121314151617function mergeObj(...objs) &#123; let result = &#123;&#125;; // 遍历对象 objs.forEach(obj =&gt; &#123; // 获取对象的所有key并遍历 Object.keys(obj).forEach(key =&gt; &#123; if (result.hasOwnProperty(key)) &#123; // 存在，则合并属性 result[key] = [].concat(result[key], obj[key]) &#125; else &#123; // 如果结果对象中不存在，则添加属性 result[key] = obj[key]; &#125; &#125;) &#125;) return result;&#125; 对象/数组拷贝浅拷贝1）…123456789101112function clone1(target) &#123; // 判断是否为对象 if (target !== null &amp;&amp; typeof target === &#x27;Object&#x27;) &#123; if (Array.isArray(target)) &#123; return [...target] &#125; else &#123; return &#123;...target&#125; &#125; &#125; else &#123; return target; &#125;&#125; 2）for…in1234567891011121314151617function clone2(target) &#123; // 判断是否为对象 if (target !== null &amp;&amp; typeof target === &#x27;Object&#x27;) &#123; const result = Array.isArray(target) ? [] : &#123;&#125;; // 遍历target数据 for (let key in target) &#123; // 判断target中是否包含该属性 if (target.hasOwnProperty(key)) &#123; // 将该属性写入result中 result[key] = target[key] &#125; &#125; return result; &#125; else &#123; return target; &#125;&#125; 深拷贝例子1234567let obj = &#123; a: 1, b: [&#x27;e&#x27;, &#x27;f&#x27;], c: &#123;d: 20&#125;, g: function () &#123; &#125;&#125;obj.b.push(obj.c)obj.c.d = obj.bdeepClone3(obj) 1）’JSON.parse(JSON.stringify())’缺点：1.无法克隆函数属性；2.无法解决循环引用 123function deepClone1(target) &#123; return JSON.parse(JSON.stringify(target));&#125; 2）递归拷贝，解决无法克隆函数属性12345678910111213function deepClone2(target) &#123; if (target !== null &amp;&amp; typeof target === &#x27;object&#x27;) &#123; const result = Array.isArray(target) ? [] : &#123;&#125;; for (let key in target) &#123; if (target.hasOwnProperty(key)) &#123; result[key] = deepClone2(target[key]) &#125; &#125; return result; &#125; else &#123; return target; &#125;&#125; 3）使用缓存容器，解决无法循环应用问题12345678910111213141516171819function deepClone3(target, map = new Map()) &#123; if (target !== null &amp;&amp; typeof target === &#x27;object&#x27;) &#123; // 判断传入的map中存不存在对象的克隆 let result = map.get(target) if (result) &#123; return target; &#125; result = Array.isArray(target) ? [] : &#123;&#125;; map.set(target, result) for (let key in target) &#123; if (target.hasOwnProperty(key)) &#123; result[key] = deepClone3(target[key], map) &#125; &#125; return result; &#125; else &#123; return target; &#125;&#125; 4）性能优化**数组: while | for | forEach() 优于 for-in | keys()&amp;forEach() ** 对象: for-in 与 keys()&amp;forEach() 差不多 123456789101112131415161718192021222324function deepClone4(target, map = new Map()) &#123; if (target !== null &amp;&amp; target === &quot;object&quot;) &#123; let result = map.get(target); if (result) &#123; return result; &#125; if (Array.isArray(target)) &#123; result = []; map.set(target, result); target.forEach((item, i) =&gt; &#123; result[i] = deepClone4(item[i], map) &#125;) &#125; else &#123; result = &#123;&#125;; map.set(target, result); Object.keys(target).forEach(key =&gt; &#123; result[key] = deepClone4(target[key], map) &#125;) &#125; return result; &#125;else&#123; return target; &#125;&#125; 字符串相关倒序12345function reverseString(str) &#123; // return str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) // return [...str].reverse().join(&#x27;&#x27;) return Array.from(str).reverse().join(&#x27;&#x27;)&#125; 检测是否回文123function palindrome(str) &#123; return str === reverseString(str)&#125; 截取字符串，以…隐藏多余字符串123function truncate(str, size) &#123; return str.length &gt; size ? str.slice(0, size) + &#x27;...&#x27; : str&#125; 手写DOM事件监听事件捕获与事件冒泡 事件委托函数将多个子元素的同类事件监听委托给(绑定在)共同的一个父组件上 好处： 减少内存占用(事件监听回调从n变为 动态添加的内部元素也能响应 1234567891011121314151617181920function addEventListener(el, type, Fn, selector) &#123; if (typeof el === &#x27;string&#x27;) &#123; el = document.querySelector(el); &#125; if (!selector) &#123; // 如果没有selector，普通事件绑定 el.addEventListener(type, Fn); &#125; else &#123; // 否则是代委托的事件绑定 el.addEventListener(type, function (e) &#123; // 获取真正发生事件的目标元素 const target = e.target; // 判断目标元素是否与selector相同 if (target.matches(selector)) &#123; // 调用处理事件的回调函数Fn，绑定当前this，参数为e Fn.call(target, e) &#125; &#125;) &#125;&#125; 事件总线123456789101112131415161718192021222324252627282930const eventBus = &#123;callbacks: &#123;&#125;&#125;// 注册事件监听eventBus.on = function (type, callback) &#123; const callbacks = this.callbacks[type]; if (!callbacks) &#123; this.callbacks[type] = [callback]; &#125; else &#123; callbacks.push(callback); &#125;&#125;// 触发事件监听eventBus.emit = function (type, data) &#123; const callbacks = this.callbacks[type]; if (callbacks &amp;&amp; callbacks.length &gt; 0) &#123; this.callbacks[type].forEach(cb =&gt; &#123; cb(data) &#125;) &#125;&#125;// 移除事件监听eventBus.off = function (type) &#123; if (!type) &#123; this.callbacks = &#123;&#125;; &#125; else &#123; delete this.callbacks[type] &#125;&#125; 消息订阅与发布123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const sub = &#123; callbacks: &#123;&#125;, id: 0&#125;// 订阅sub.subscribe = function (type, callback) &#123; const token = &quot;token_&quot; + this.id; const callbacks = this.callbacks[type]; if (callbacks) &#123; callbacks[token] = callback &#125; else &#123; this.callbacks[type] = &#123; [token]: callback &#125; console.log(this.callbacks) &#125; this.id++; return token;&#125;// 发布sub.publish = function (type, data) &#123; const callbacks = this.callbacks[type]; if (callbacks) &#123; Object.values(this.callbacks).forEach(cb =&gt; &#123; cb(data) &#125;) &#125;&#125;// 取消sub.unsubscribe = function (flag) &#123; if (flag === undefined) &#123; this.callbacks = &#123;&#125;; &#125; else if (typeof flag === &quot;string&quot;) &#123; if (flag.indexOf(&quot;token_&quot;) === 0) &#123; const callbacks = Object.values(this.callbacks).find(callback =&gt; callback.hasOwnProperty(flag)); if (callbacks) &#123; delete callbacks[flag] &#125; &#125; else &#123; delete this.callbacks[flag] &#125; &#125; else &#123; throw new Error(&quot;传入参数错误&quot;) &#125;&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wisiw.github.io.git/tags/JavaScript/"},{"name":"手写","slug":"手写","permalink":"https://wisiw.github.io.git/tags/%E6%89%8B%E5%86%99/"}]},{"title":"【源码解析】Vue：AST抽象语法树","slug":"【源码解析】Vue：AST抽象语法树","date":"2021-02-01T15:29:56.000Z","updated":"2021-09-23T06:18:57.568Z","comments":true,"path":"2021/02/01/【源码解析】Vue：AST抽象语法树/","link":"","permalink":"https://wisiw.github.io.git/2021/02/01/%E3%80%90%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91Vue%EF%BC%9AAST%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91/","excerpt":"","text":"基础版12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var templateStr = &quot;&lt;div&gt;&lt;p&gt;aaa&lt;/p&gt;&lt;ul&gt;&lt;li&gt;a&lt;/li&gt;&lt;li&gt;b&lt;/li&gt;&lt;li&gt;c&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&quot;;parseHtml(templateStr)function parseHtml(templateStr) &#123; // 指针 var index = 0; var stackTag = []; var stackContent = [&#123;&#x27;children&#x27;: []&#125;]; var rest = templateStr; var startRegExp = /^\\&lt;([a-z]+[1-6]?)\\&gt;/; var endRegExp = /^\\&lt;\\/([a-z]+[1-6]?)\\&gt;/; var wordRegExp = /^([^\\&lt;]+)\\&lt;\\/[a-z]+[1-6]?\\&gt;/; while (index &lt; templateStr.length - 1) &#123; rest = templateStr.substring(index) // 识别开始字符是不是开始标签 if (startRegExp.test(rest)) &#123; // 获取开始标记 let tag = rest.match(startRegExp)[1]; // 将开始标记推入栈中 stackTag.push(tag); // 将空数组推入栈中 stackContent.push(&#123;&#x27;tag&#x27;: tag, &#x27;children&#x27;: []&#125;); index += tag.length + 2; &#125; else if (endRegExp.test(rest)) &#123; // 获取结束标记 let tag = rest.match(endRegExp)[1]; let pop_tag = stackTag.pop(); // 判断跟栈顶的标记是不是同一个 if (tag == pop_tag) &#123; let pop_arr = stackContent.pop(); if (stackContent.length &gt; 0) &#123; stackContent[stackContent.length - 1].children.push(pop_arr); &#125; &#125; else &#123; throw new Error(stackTag[stackTag.length - 1] + &quot;没有闭合&quot;) &#125; index += tag.length + 3; &#125; else if (wordRegExp.test(rest)) &#123; let word = rest.match(wordRegExp)[1]; if (!/^\\s+$/.test(word)) &#123; stackContent[stackContent.length - 1].children.push(&#123;&#x27;text&#x27;: word, &#x27;type&#x27;: 3&#125;) &#125; index += word.length; &#125; else &#123; index++; &#125; &#125; console.log(stackContent[0].children[0])&#125; 进阶版1）修改检测开始标记的正则12var startRegExp = /^\\&lt;([a-z]+[1-6]?)(\\s[^\\&lt;]+)?\\&gt;/;// 添加检测attr 2）检测到开始标记时，取出识别到的attr内容，指针后移12let attrString = rest.match(startRegExp)[2];index += tag.length + 2 + attrString.length; 3）格式化attrString12345678910111213141516171819202122232425262728function parseAttrString(attrString) &#123; if(attrString == undefined)return []; var isYinhao = false; var point = 0; var result = []; for (var i = 0;i&lt;attrString.length;i++)&#123; let char = attrString[i]; if(char == &#x27;&quot;&#x27;)&#123; isYinhao = !isYinhao; &#125;else if (char == &#x27; &#x27; &amp;&amp; !isYinhao)&#123; if(!/^\\s*$/.test(attrString.substring(point,i))) &#123; result.push(attrString.substring(point,i).trim()); point = i; &#125; &#125; &#125; result.push(attrString.substring(point).trim()) result = result.map(item =&gt; &#123; // 根据=拆分 let o = item.match(/^(.+)=&quot;(.+)&quot;$/); return &#123; name: o[1], value: o[2] &#125; &#125;) return result&#125; 4）添加attrs属性1stackContent.push(&#123;&#x27;tag&#x27;: tag, &#x27;children&#x27;: [],&#x27;attrs&#x27;:parseAttrString(attrString)&#125;); 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980var templateStr = &#x27;&lt;div&gt;&lt;p id=&quot;div&quot; class=&quot;box p&quot;&gt;aaa&lt;/p&gt;&lt;ul&gt;&lt;li&gt;a&lt;/li&gt;&lt;li&gt;b&lt;/li&gt;&lt;li&gt;c&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&#x27;;parseHtml(templateStr)function parseHtml(templateStr) &#123; // 指针 var index = 0; var stackTag = []; var stackContent = [&#123;&#x27;children&#x27;: []&#125;]; var rest = templateStr; var startRegExp = /^\\&lt;([a-z]+[1-6]?)(\\s[^\\&lt;]+)?\\&gt;/; var endRegExp = /^\\&lt;\\/([a-z]+[1-6]?)\\&gt;/; var wordRegExp = /^([^\\&lt;]+)\\&lt;\\/[a-z]+[1-6]?\\&gt;/; while (index &lt; templateStr.length - 1) &#123; rest = templateStr.substring(index) // 识别开始字符是不是开始标签 if (startRegExp.test(rest)) &#123; // 获取开始标记 let tag = rest.match(startRegExp)[1]; let attrString = rest.match(startRegExp)[2]; // 将开始标记推入栈中 stackTag.push(tag); // 将空数组推入栈中 stackContent.push(&#123;&#x27;tag&#x27;: tag, &#x27;children&#x27;: [],&#x27;attrs&#x27;:parseAttrString(attrString)&#125;); index += tag.length + 2 + (attrString != null?attrString.length:0); &#125; else if (endRegExp.test(rest)) &#123; // 获取结束标记 let tag = rest.match(endRegExp)[1]; let pop_tag = stackTag.pop(); // 判断跟栈顶的标记是不是同一个 if (tag == pop_tag) &#123; let pop_arr = stackContent.pop(); if (stackContent.length &gt; 0) &#123; stackContent[stackContent.length - 1].children.push(pop_arr); &#125; &#125; else &#123; throw new Error(stackTag[stackTag.length - 1] + &quot;没有闭合&quot;) &#125; index += tag.length + 3; &#125; else if (wordRegExp.test(rest)) &#123; let word = rest.match(wordRegExp)[1]; // 判断内容是否为空 if (!/^\\s+$/.test(word)) &#123; stackContent[stackContent.length - 1].children.push(&#123;&#x27;text&#x27;: word, &#x27;type&#x27;: 3&#125;) &#125; index += word.length; &#125; else &#123; index++; &#125; &#125; console.log(stackContent[0].children[0])&#125;function parseAttrString(attrString) &#123; if(attrString == undefined)return []; var isYinhao = false; var point = 0; var result = []; for (var i = 0;i&lt;attrString.length;i++)&#123; let char = attrString[i]; if(char == &#x27;&quot;&#x27;)&#123; isYinhao = !isYinhao; &#125;else if (char == &#x27; &#x27; &amp;&amp; !isYinhao)&#123; if(!/^\\s*$/.test(attrString.substring(point,i))) &#123; result.push(attrString.substring(point,i).trim()); point = i; &#125; &#125; &#125; result.push(attrString.substring(point).trim()) result = result.map(item =&gt; &#123; // 根据=拆分 let o = item.match(/^(.+)=&quot;(.+)&quot;$/); return &#123; name: o[1], value: o[2] &#125; &#125;) return result&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://wisiw.github.io.git/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://wisiw.github.io.git/tags/Vue/"},{"name":"源码解析","slug":"源码解析","permalink":"https://wisiw.github.io.git/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"name":"AST语法树","slug":"AST语法树","permalink":"https://wisiw.github.io.git/tags/AST%E8%AF%AD%E6%B3%95%E6%A0%91/"},{"name":"模板解析","slug":"模板解析","permalink":"https://wisiw.github.io.git/tags/%E6%A8%A1%E6%9D%BF%E8%A7%A3%E6%9E%90/"}]},{"title":"【源码解析】Vue：判断是否是html标签","slug":"【源码解析】Vue：判断是否是html标签","date":"2021-02-01T01:18:20.000Z","updated":"2021-09-23T06:18:57.571Z","comments":true,"path":"2021/02/01/【源码解析】Vue：判断是否是html标签/","link":"","permalink":"https://wisiw.github.io.git/2021/02/01/%E3%80%90%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91Vue%EF%BC%9A%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AFhtml%E6%A0%87%E7%AD%BE/","excerpt":"","text":"1234567891011121314151617181920212223242526272829// vue/dist/vue.js// 5589var isHTMLTag = makeMap( &#x27;html,body,base,head,link,meta,style,title,&#x27; + &#x27;address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,&#x27; + &#x27;div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,&#x27; + &#x27;a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,&#x27; + &#x27;s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,&#x27; + &#x27;embed,object,param,source,canvas,script,noscript,del,ins,&#x27; + &#x27;caption,col,colgroup,table,thead,tbody,td,th,tr,&#x27; + &#x27;button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,&#x27; + &#x27;output,progress,select,textarea,&#x27; + &#x27;details,dialog,menu,menuitem,summary,&#x27; + &#x27;content,element,shadow,template,blockquote,iframe,tfoot&#x27; );// 117function makeMap ( str, expectsLowerCase ) &#123; var map = Object.create(null); var list = str.split(&#x27;,&#x27;); for (var i = 0; i &lt; list.length; i++) &#123; map[list[i]] = true; &#125; return expectsLowerCase ? function (val) &#123; return map[val.toLowerCase()]; &#125; : function (val) &#123; return map[val]; &#125; &#125;","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://wisiw.github.io.git/tags/Vue/"},{"name":"源码","slug":"源码","permalink":"https://wisiw.github.io.git/tags/%E6%BA%90%E7%A0%81/"},{"name":"源码解析","slug":"源码解析","permalink":"https://wisiw.github.io.git/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"}]},{"title":"【Node】npm包发布","slug":"【Node】npm包发布","date":"2021-01-31T16:06:32.000Z","updated":"2021-09-23T05:57:56.244Z","comments":true,"path":"2021/02/01/【Node】npm包发布/","link":"","permalink":"https://wisiw.github.io.git/2021/02/01/%E3%80%90Node%E3%80%91npm%E5%8C%85%E5%8F%91%E5%B8%83/","excerpt":"","text":"","categories":[{"name":"前端","slug":"前端","permalink":"https://wisiw.github.io.git/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://wisiw.github.io.git/tags/Node/"},{"name":"npm","slug":"npm","permalink":"https://wisiw.github.io.git/tags/npm/"}]},{"title":"【Node】cli工具编写","slug":"【Node】cli工具编写","date":"2021-01-31T16:06:11.000Z","updated":"2022-06-04T15:33:30.197Z","comments":true,"path":"2021/02/01/【Node】cli工具编写/","link":"","permalink":"https://wisiw.github.io.git/2021/02/01/%E3%80%90Node%E3%80%91cli%E5%B7%A5%E5%85%B7%E7%BC%96%E5%86%99/","excerpt":"","text":"","categories":[{"name":"cli","slug":"cli","permalink":"https://wisiw.github.io.git/categories/cli/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://wisiw.github.io.git/tags/Node/"},{"name":"cli","slug":"cli","permalink":"https://wisiw.github.io.git/tags/cli/"}]},{"title":"【Webpack】工作原理概述","slug":"【Webpack】工作原理概述","date":"2021-01-29T08:44:56.000Z","updated":"2021-11-18T05:30:44.226Z","comments":true,"path":"2021/01/29/【Webpack】工作原理概述/","link":"","permalink":"https://wisiw.github.io.git/2021/01/29/%E3%80%90Webpack%E3%80%91%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/","excerpt":"","text":"webpack的运行流程是一个串行的过程，从启动到结束会依次执行以下流程： 初始化参数：从配置文件和shell语句中读取并合并参数，得出最终的参数 开始编译：将得到的参数初始化Compiler对象，加载所有配置的插件，通过执行对象的run方法开始执行编译 确定入口：根据配置文件中的entey找到所有的入口文件 编译模块：从入口文件出发，调用所有配置的Loader对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖文件都经过处理 完成模块编译：经过编译后，得到每个模块被翻译后的最终内容和它们之间的依赖关系 输出资源：根据入口和模块之间的依赖关系，组成一个个包含多个模块的Chunk，再将每个Chunk转换成一个单独的文件加入输出列表（此时可以最后修改输出内容） 输出完成：在确定输出内容后，根据配置确定输出的路径和文件名，将文件的内容写入文件系统中 在上述过程中，webpack会在特定的时间点广播特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用webpack提供的API改变webpack的运行结果，","categories":[],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"https://wisiw.github.io.git/tags/Webpack/"},{"name":"原理","slug":"原理","permalink":"https://wisiw.github.io.git/tags/%E5%8E%9F%E7%90%86/"}]},{"title":"【读书笔记】解读React源码（《深入React技术栈》————第四章）","slug":"【读书笔记】深入了解React组件（《深入React技术栈》————第四章）","date":"2021-01-27T07:58:03.000Z","updated":"2021-09-14T06:59:31.938Z","comments":true,"path":"2021/01/27/【读书笔记】深入了解React组件（《深入React技术栈》————第四章）/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3React%E7%BB%84%E4%BB%B6%EF%BC%88%E3%80%8A%E6%B7%B1%E5%85%A5React%E6%8A%80%E6%9C%AF%E6%A0%88%E3%80%8B%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%89/","excerpt":"","text":"","categories":[{"name":"react","slug":"react","permalink":"https://wisiw.github.io.git/categories/react/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://wisiw.github.io.git/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"react","slug":"react","permalink":"https://wisiw.github.io.git/tags/react/"},{"name":"《深入React技术栈》","slug":"《深入React技术栈》","permalink":"https://wisiw.github.io.git/tags/%E3%80%8A%E6%B7%B1%E5%85%A5React%E6%8A%80%E6%9C%AF%E6%A0%88%E3%80%8B/"}]},{"title":"【读书笔记】解读React源码（《深入React技术栈》————第三章）","slug":"【读书笔记】解读React源码（《深入React技术栈》————第三章）","date":"2021-01-27T07:58:03.000Z","updated":"2021-09-14T07:00:33.296Z","comments":true,"path":"2021/01/27/【读书笔记】解读React源码（《深入React技术栈》————第三章）/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E8%A7%A3%E8%AF%BBReact%E6%BA%90%E7%A0%81%EF%BC%88%E3%80%8A%E6%B7%B1%E5%85%A5React%E6%8A%80%E6%9C%AF%E6%A0%88%E3%80%8B%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%89/","excerpt":"","text":"","categories":[{"name":"react","slug":"react","permalink":"https://wisiw.github.io.git/categories/react/"}],"tags":[{"name":"读书笔记 - React - 《深入React技术栈》","slug":"读书笔记-React-《深入React技术栈》","permalink":"https://wisiw.github.io.git/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-React-%E3%80%8A%E6%B7%B1%E5%85%A5React%E6%8A%80%E6%9C%AF%E6%A0%88%E3%80%8B/"}]},{"title":"【读书笔记】解读React源码（《深入React技术栈》————第六章）","slug":"【读书笔记】高阶组件（《深入React技术栈》————第六章）","date":"2021-01-27T07:58:03.000Z","updated":"2021-09-14T07:04:21.863Z","comments":true,"path":"2021/01/27/【读书笔记】高阶组件（《深入React技术栈》————第六章）/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%EF%BC%88%E3%80%8A%E6%B7%B1%E5%85%A5React%E6%8A%80%E6%9C%AF%E6%A0%88%E3%80%8B%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%89/","excerpt":"","text":"","categories":[{"name":"React","slug":"React","permalink":"https://wisiw.github.io.git/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://wisiw.github.io.git/tags/React/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://wisiw.github.io.git/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"《深入React技术栈》","slug":"《深入React技术栈》","permalink":"https://wisiw.github.io.git/tags/%E3%80%8A%E6%B7%B1%E5%85%A5React%E6%8A%80%E6%9C%AF%E6%A0%88%E3%80%8B/"}]},{"title":"【读书笔记】架构设计：多页面应用（《前端架构：从入门到微前端》———五第六章）","slug":"【读书笔记】架构设计：多页面应用（《前端架构：从入门到微前端》———五第六章）","date":"2021-01-27T07:56:49.000Z","updated":"2021-06-21T08:13:15.918Z","comments":true,"path":"2021/01/27/【读书笔记】架构设计：多页面应用（《前端架构：从入门到微前端》———五第六章）/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%EF%BC%88%E3%80%8A%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BE%AE%E5%89%8D%E7%AB%AF%E3%80%8B%E2%80%94%E2%80%94%E2%80%94%E4%BA%94%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%89/","excerpt":"","text":"","categories":[{"name":"前端架构","slug":"前端架构","permalink":"https://wisiw.github.io.git/categories/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"微前端","slug":"微前端","permalink":"https://wisiw.github.io.git/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"},{"name":"前端 - 架构","slug":"前端-架构","permalink":"https://wisiw.github.io.git/tags/%E5%89%8D%E7%AB%AF-%E6%9E%B6%E6%9E%84/"}]},{"title":"【Echarts】读取本地Excel生成Echarts","slug":"【Echarts】读取本地Excel生成Echarts","date":"2021-01-27T07:54:50.000Z","updated":"2021-12-21T06:36:40.840Z","comments":true,"path":"2021/01/27/【Echarts】读取本地Excel生成Echarts/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/%E3%80%90Echarts%E3%80%91%E8%AF%BB%E5%8F%96%E6%9C%AC%E5%9C%B0Excel%E7%94%9F%E6%88%90Echarts/","excerpt":"","text":"源码 1.引用插件1&lt;script src=&quot;./xlsx.full.min.js&quot;&gt;&lt;/script&gt; 或 12yarn add xlsximport XLSX from &#x27;xlsx&#x27; 2.上传本地文件插件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127var File = (function () &#123; var that; var obj = function () &#123; that = this; window.addEventListener(&quot;load&quot;,() =&gt; &#123; that._init() &#125;, false); &#125; obj.prototype = &#123; upload: function (options) &#123; that._initByOptions(options); that.fileInput.click(); &#125;, // 初始化上传框 _init: function () &#123; var ipt = document.createElement(&quot;input&quot;); ipt.style.display = &quot;none&quot;; ipt.setAttribute(&quot;type&quot;, &quot;file&quot;); ipt.addEventListener(&quot;change&quot;, that._fileChange, false); document.body.appendChild(ipt); that.fileInput = ipt; &#125;, _initByOptions: function (options) &#123; that.fileInput.value = &quot;&quot;; that.options = &#123; multi: false, url: &quot;&quot;, accept: &quot;&quot;, param: null, uploadType:&#x27;&#x27;, before: function () &#123; &#125;, after: function () &#123; &#125;, progress: function () &#123; &#125; &#125;; if (options) &#123; for (var i in options) &#123; that.options[i] = options[i]; &#125; &#125; // multiple if (that.options.multi) that.fileInput.setAttribute(&quot;multiple&quot;, &quot;multiple&quot;); else that.fileInput.removeAttribute(&quot;multiple&quot;); // accept that.fileInput.setAttribute(&quot;accept&quot;, that.options.accept || &quot;&quot;); &#125;, _fileChange: function () &#123; if (that.options.before) &#123; var result = that.options.before(this.files); if (result == false) return; &#125; for (var i = 0; i &lt; this.files.length; i++) &#123; that._uploadFile(this.files[i]); &#125; &#125;, _uploadFile: function (file) &#123; if(that.options.uploadType == &#x27;local&#x27;)&#123; that.options.after &amp;&amp; that.options.after(file); return; &#125; var xhr = new XMLHttpRequest(); xhr.upload.addEventListener(&quot;progress&quot;, function (evt) &#123; if (evt.lengthComputable) &#123; that.options.progress &amp;&amp; that.options.progress(evt.loaded / evt.total); &#125; else &#123; // No data to calculate on &#125; &#125;, false); xhr.addEventListener(&quot;load&quot;, function () &#123; &#125;, false); xhr.open(&quot;post&quot;, that.options.url); xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304) &#123; that.options.after &amp;&amp; that.options.after(xhr.responseText, file); xhr = null; &#125; &#125; &#125; xhr.onerror = function () &#123; that.options.error &amp;&amp; that.options.error(); &#125; // Send the file (doh) if (&quot;getAsBinary&quot; in file) &#123; //FF 3.5+ xhr.sendAsBinary(file.getAsBinary()); &#125; else &#123; var formData = new FormData(); formData.append(&quot;path&quot;, &quot;default&quot;); formData.append(&quot;upload_file&quot;, file); formData.append(&quot;type&quot;, file.name.substring(file.name.indexOf(&quot;.&quot;))); if (that.options.param) &#123; for (var p in that.options.param) &#123; formData.append(p, that.options.param[p]); &#125; &#125; if (me.global.token) &#123; xhr.setRequestHeader(&#x27;token&#x27;, me.global.token) &#125; xhr.send(formData); &#125; &#125; &#125; return new obj();&#125;)(); 3.读取Excel123456789101112131415161718192021function XLSXRender(data, accept, maxSize, callBack, maxCount) &#123; File.upload(&#123; multi: true, accept: accept, uploadType: &quot;local&quot;, before: function (files) &#123;&#125;, after: function (file) &#123; var reader = new FileReader(); reader.onload = function (e) &#123; var data = e.target.result; var workbook = XLSX.read(data, &#123;type: &#x27;binary&#x27;&#125;); var sheetNames = workbook.SheetNames; // 工作表名称集合 var worksheet = workbook.Sheets[sheetNames[0]]; // 这里我们只读取第一张sheet callBack &amp;&amp; callBack(XLSX.utils.sheet_to_json(worksheet)); &#125;; reader.readAsBinaryString(file); &#125;, error: function () &#123;&#125;, progress: function () &#123;&#125; &#125;);&#125; 4.生成echarts1234567891011121314151617181920212223242526272829303132333435363738XLSXRender(&#123;&#125;, &quot;image/jpg;image/jpeg;image/png;image/gif;image/bmp;&quot;, 500, function (data) &#123; if (!data) return; var source = []; var a = &#123;&#125;; for(let i in data)&#123; for(let key in data[i]) &#123; if(!a[key])a[key] = [key] a[key].push(data[i][key]) &#125; &#125; for(let i in a)&#123; source.push(a[i]) &#125; initData(source)&#125;)function initData(source)&#123; const _data = document.getElementById(&quot;data&quot;); const option = &#123; legend: &#123;&#125;, tooltip: &#123;&#125;, dataset: &#123; source: source &#125;, xAxis: &#123;type: &#x27;category&#x27;&#125;, yAxis: &#123;&#125;, series: [ &#123;type: &#x27;bar&#x27;&#125;, &#123;type: &#x27;bar&#x27;&#125;, &#123;type: &#x27;bar&#x27;&#125; ] &#125; if (!_data) &#123; _data.setOption(option) return; &#125; var _data = this.$echarts.init(_data) _data.setOption(option)&#125; 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;ExcelToCharts&lt;/title&gt; &lt;script src=&quot;./xlsx.full.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./echarts.common.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./File.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=&quot;readExcel&quot;&gt;读取Excel&lt;/button&gt;&lt;div id=&quot;data&quot; style=&quot;width: 300px;height: 300px;&quot;&gt;&lt;/div&gt;&lt;script&gt; document.getElementById(&#x27;readExcel&#x27;).addEventListener(&#x27;click&#x27;, function() &#123; XLSXRender(&#123;&#125;, &quot;*.xlsx;&quot;, 500, function (data) &#123; if (!data) return; const source = []; const a = &#123;&#125;; for(let i in data)&#123; for(let key in data[i]) &#123; if(!a[key])a[key] = [key] a[key].push(data[i][key]) &#125; &#125; for(let i in a)&#123; source.push(a[i]) &#125; initData(source) &#125;) &#125;) function XLSXRender(data, accept, maxSize, callBack, maxCount) &#123; File.upload(&#123; multi: true, accept: accept, uploadType: &quot;local&quot;, before: function (files) &#123;&#125;, after: function (file) &#123; var reader = new FileReader(); reader.onload = function (e) &#123; var data = e.target.result; var workbook = XLSX.read(data, &#123;type: &#x27;binary&#x27;&#125;); var sheetNames = workbook.SheetNames; // 工作表名称集合 var worksheet = workbook.Sheets[sheetNames[0]]; // 这里我们只读取第一张sheet callBack &amp;&amp; callBack(XLSX.utils.sheet_to_json(worksheet)); &#125;; reader.readAsBinaryString(file); &#125;, error: function () &#123;&#125;, progress: function () &#123;&#125; &#125;); &#125; function initData(source)&#123; const option = &#123; legend: &#123;&#125;, tooltip: &#123;&#125;, dataset: &#123; source: source &#125;, xAxis: &#123;type: &#x27;category&#x27;&#125;, yAxis: &#123;&#125;, series: [ &#123;type: &#x27;bar&#x27;&#125;, &#123;type: &#x27;bar&#x27;&#125;, &#123;type: &#x27;bar&#x27;&#125; ] &#125; let _data = document.getElementById(&quot;data&quot;); if (!_data) &#123; _data.setOption(option) return; &#125; _data = echarts.init(_data) _data.setOption(option) &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"Echarts","slug":"Echarts","permalink":"https://wisiw.github.io.git/tags/Echarts/"},{"name":"Excel","slug":"Excel","permalink":"https://wisiw.github.io.git/tags/Excel/"}]},{"title":"【读书笔记】架构设计：单页面应用（《前端架构：从入门到微前端》—第六）—","slug":"【读书笔记】架构设计：单页面应用（《前端架构：从入门到微前端》—第六）—","date":"2021-01-27T07:53:42.000Z","updated":"2021-06-21T08:13:15.277Z","comments":true,"path":"2021/01/27/【读书笔记】架构设计：单页面应用（《前端架构：从入门到微前端》—第六）—/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%EF%BC%88%E3%80%8A%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BE%AE%E5%89%8D%E7%AB%AF%E3%80%8B%E2%80%94%E7%AC%AC%E5%85%AD%EF%BC%89%E2%80%94/","excerpt":"","text":"","categories":[{"name":"前端架构","slug":"前端架构","permalink":"https://wisiw.github.io.git/categories/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"前端架构","slug":"前端架构","permalink":"https://wisiw.github.io.git/tags/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/"},{"name":"微前端","slug":"微前端","permalink":"https://wisiw.github.io.git/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"}]},{"title":"【Docker】使用","slug":"【Docker】使用","date":"2021-01-27T07:49:28.000Z","updated":"2021-09-23T06:00:37.259Z","comments":true,"path":"2021/01/27/【Docker】使用/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/%E3%80%90Docker%E3%80%91%E4%BD%BF%E7%94%A8/","excerpt":"","text":"","categories":[{"name":"后端","slug":"后端","permalink":"https://wisiw.github.io.git/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://wisiw.github.io.git/tags/Docker/"},{"name":"后端","slug":"后端","permalink":"https://wisiw.github.io.git/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"【Angular】使用","slug":"【Angular】使用","date":"2021-01-27T07:48:49.000Z","updated":"2021-09-23T06:01:40.064Z","comments":true,"path":"2021/01/27/【Angular】使用/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/%E3%80%90Angular%E3%80%91%E4%BD%BF%E7%94%A8/","excerpt":"","text":"","categories":[{"name":"Angular","slug":"Angular","permalink":"https://wisiw.github.io.git/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"https://wisiw.github.io.git/tags/Angular/"}]},{"title":"TypeScript使用","slug":"【JavaScript】TypeScript使用","date":"2021-01-27T07:48:29.000Z","updated":"2021-06-21T08:13:05.827Z","comments":true,"path":"2021/01/27/【JavaScript】TypeScript使用/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/%E3%80%90JavaScript%E3%80%91TypeScript%E4%BD%BF%E7%94%A8/","excerpt":"","text":"","categories":[{"name":"前端","slug":"前端","permalink":"https://wisiw.github.io.git/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://wisiw.github.io.git/tags/TypeScript/"},{"name":"使用","slug":"使用","permalink":"https://wisiw.github.io.git/tags/%E4%BD%BF%E7%94%A8/"}]},{"title":"linux集群","slug":"linux集群","date":"2021-01-27T07:47:42.000Z","updated":"2021-06-21T08:13:01.070Z","comments":true,"path":"2021/01/27/linux集群/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/linux%E9%9B%86%E7%BE%A4/","excerpt":"","text":"","categories":[{"name":"后端","slug":"后端","permalink":"https://wisiw.github.io.git/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://wisiw.github.io.git/tags/linux/"},{"name":"集群","slug":"集群","permalink":"https://wisiw.github.io.git/tags/%E9%9B%86%E7%BE%A4/"}]},{"title":"【JavaScript】设计模式","slug":"【JavaScript】设计模式","date":"2021-01-27T07:47:26.000Z","updated":"2021-09-23T05:57:36.165Z","comments":true,"path":"2021/01/27/【JavaScript】设计模式/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/%E3%80%90JavaScript%E3%80%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"","categories":[{"name":"前端","slug":"前端","permalink":"https://wisiw.github.io.git/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript - 设计模式","slug":"JavaScript-设计模式","permalink":"https://wisiw.github.io.git/tags/JavaScript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"nginx使用","slug":"nginx使用","date":"2021-01-27T07:46:58.000Z","updated":"2021-06-21T08:13:03.420Z","comments":true,"path":"2021/01/27/nginx使用/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/nginx%E4%BD%BF%E7%94%A8/","excerpt":"","text":"","categories":[{"name":"代码工具","slug":"代码工具","permalink":"https://wisiw.github.io.git/categories/%E4%BB%A3%E7%A0%81%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://wisiw.github.io.git/tags/Nginx/"},{"name":"代码工具","slug":"代码工具","permalink":"https://wisiw.github.io.git/tags/%E4%BB%A3%E7%A0%81%E5%B7%A5%E5%85%B7/"}]},{"title":"【git】常用方法列表","slug":"【git】常用方法列表","date":"2021-01-27T07:46:16.000Z","updated":"2021-09-23T05:58:16.282Z","comments":true,"path":"2021/01/27/【git】常用方法列表/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/%E3%80%90git%E3%80%91%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E5%88%97%E8%A1%A8/","excerpt":"","text":"","categories":[{"name":"代码工具","slug":"代码工具","permalink":"https://wisiw.github.io.git/categories/%E4%BB%A3%E7%A0%81%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"代码工具","slug":"代码工具","permalink":"https://wisiw.github.io.git/tags/%E4%BB%A3%E7%A0%81%E5%B7%A5%E5%85%B7/"},{"name":"git","slug":"git","permalink":"https://wisiw.github.io.git/tags/git/"}]},{"title":"【源码解析】Promise","slug":"【源码解析】Promise","date":"2021-01-27T07:45:29.000Z","updated":"2021-09-23T05:53:39.202Z","comments":true,"path":"2021/01/27/【源码解析】Promise/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/%E3%80%90%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91Promise/","excerpt":"","text":"构造函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236/** * Promise构造函数 * excutor：执行器函数（同步执行） * @param excutor */function Promise(executor) &#123; const _this = this; _this.status = &quot;pending&quot;; // 给Promise对象指定status属性，初始值为pending _this.data = undefined; // 给Promise对象指定一个用于存储结果数据的属性 _this.callbacks = []; // 每个元素的结构：&#123;onResolve()&#123;&#125;,onReject()&#123;&#125;&#125; function resolve(value) &#123; // 如果状态已经修改，返回 if (_this.status !== &quot;pending&quot;) return; // 修改状态为fullFilled _this.status = &quot;fullFilled&quot;; // 保存value数据 _this.data = value; if (_this.callbacks.length &gt; 0) &#123; setTimeout(function () &#123; // 放入队列中执行所有成功的回调 _this.callbacks.forEach(callbackObj =&gt; &#123; callbackObj.onResolved(value) &#125;) &#125;) &#125; &#125; function reject(reason) &#123; // 如果状态已经修改，返回 if (_this.status !== &quot;pending&quot;) return; // 修改状态为fullFilled _this.status = &quot;rejected&quot;; // 保存value数据 _this.data = reason; if (_this.callbacks.length &gt; 0) &#123; setTimeout(function () &#123; // 放入队列中执行所有成功的回调 _this.callbacks.forEach(callbackObj =&gt; &#123; callbackObj.onRejected(reason) &#125;) &#125;) &#125; &#125; // 立即同步执行excutor try &#123; executor(resolve, reject) &#125; catch (reason) &#123; // 如果执行器抛出异常，Promise对象变为rejected状态 reject(reason) &#125;&#125;/** * Promise原型对象的then()，指定成功和失败的回调函数，返回一个新的Promise对象 * @param onResolved * @param onRejected */Promise.prototype.then = function (onResolved, onRejected) &#123; onResolved = typeof onResolved === &#x27;function&#x27; ? onResolved : value =&gt; value; // 向后传递成功的value // 指定默认的失败回调（实现错误/异常传递的关键点） onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : reason =&gt; &#123; throw reason &#125; // 向后传递失败的reason const _this = this; /** 调用指定回调函数执行 */ return new Promise((resolve, reject) =&gt; &#123; function handler(callback) &#123; /** 1. 如果抛出异常，return的Promise就会失败，reason就是error 2. 如果回调函数返回的不是Promise，return的Promise就会成功，value就是返回的值 3. 如果回调函数返回的是Promise，return的Promise结果就是这个Promise的结果 */ try &#123; const result = callback(_this.data); if (result instanceof Promise) &#123; result.then( value =&gt; resolve(value), // 当result成功时，让return的Promise也成功 reason =&gt; reject(reason) // 当result失败时，让return的Promise也失败 ) // 简洁写法 // result.then(resolve,reject) &#125; else &#123; resolve(result) &#125; &#125; catch (error) &#123; reject(error) &#125; &#125; // 当前状态还是pending状态，将回调函数保存 if (_this.status === &quot;pending&quot;) &#123; _this.callbacks.push(&#123; onResolved() &#123; handler(onResolved) &#125;, onRejected() &#123; handler(onRejected) &#125; &#125;) &#125; else if (_this.status === &quot;fullFilled&quot;) &#123; // 如果当前是fullFilled状态，异步执行onResolve并改变return的promise状态 setTimeout(() =&gt; &#123; handler(onResolved) &#125;) &#125; else &#123; // 如果当前是rejected状态，异步执行onReject并改变return的promise状态 setTimeout(() =&gt; &#123; handler(onRejected) &#125;) &#125; &#125;)&#125;;/** * Promise原型对象的catch()，指定失败的回调函数，返回一个新的Promise对象 * @param onRejected */Promise.prototype.catch = function (onRejected) &#123; return this.then(undefined, onRejected)&#125;;/** * Promise函数对象的resolve方法，返回一个指定value的成功的Promise * @param value */Promise.resolve = function (value) &#123; // 返回一个成功/失败的Promise return new Promise((resolve, reject) =&gt; &#123; // value是promise if (value instanceof Promise) &#123; value.then(resolve, reject) &#125; else &#123; resolve(value) &#125; &#125;)&#125;/** * Promise函数对象的reject方法，返回一个指定reason的失败的Promise * @param reason */Promise.reject = function (reason) &#123; // 返回一个失败的promise return new Promise((resolve, reject) =&gt; &#123; reject(reason) &#125;)&#125;/** * Promise函数对象的all方法，返回一个Promise，只有当所有的Promise都成功时才成功，否则只要有一个失败的就失败 * @param promises */Promise.all = function (promises) &#123; // 保存所有成功value的数组 const values = new Array(promises.length); // 用来保存成功Promise的数量 let count = 0; return new Promise((resolve, reject) =&gt; &#123; // 遍历获取每个Promise的结果 promises.forEach((p, index) =&gt; &#123; p.then( value =&gt; &#123; // 成功了数量+1 count++; // p成功，将成功的value保存入values values[index] = value; // 如果全部成功了，将return的Promise状态改为成功 if (count === promises.length) resolve(values); &#125;, reason =&gt; &#123; // 只要一个失败了，return的Promise就会失败 reject(reason) &#125; ) &#125;) &#125;)&#125;/** * Promise函数对象的race方法，返回一个Promise，只有当所有的Promise都成功时才成功，否则只要有一个失败的就失败 * @param promises */Promise.race = function (promises) &#123; return new Promise((resolve, reject) =&gt; &#123; // 遍历promises获取每个promise的结果 promises.forEach((p, index) =&gt; &#123; p.then( value =&gt; &#123; // 一旦成功了，就将返回的Promise状态变为成功 resolve(value) &#125;, reason =&gt; &#123; // 一旦失败了，就将返回的Promise状态变为失败 reject(reason) &#125; ) &#125;) &#125;)&#125;/** * 返回一个Promise对象，在指定的时间后才确定结果 * @param value * @param time */Promise.resolveDelay = function (value, time) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; if (value instanceof Promise) &#123; value.then(resolve, reject) &#125; else &#123; resolve(value) &#125; &#125;, time) &#125;)&#125;/** * 返回一个Promise对象，在指定的时间后才确定失败 * @param reason * @param time */Promise.rejectDelay = function (reason, time) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(reason) &#125;) &#125;, time)&#125;window.Promise = Promise; class版本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162class Promise &#123; constructor(executor) &#123; const _this = this; _this.status = &quot;pending&quot;; // 给Promise对象指定status属性，初始值为pending _this.data = undefined; // 给Promise对象指定一个用于存储结果数据的属性 _this.callbacks = []; // 每个元素的结构：&#123;onResolve()&#123;&#125;,onReject()&#123;&#125;&#125; function resolve(value) &#123; // 如果状态已经修改，返回 if (_this.status !== &quot;pending&quot;) return; // 修改状态为fullFilled _this.status = &quot;fullFilled&quot;; // 保存value数据 _this.data = value; if (_this.callbacks.length &gt; 0) &#123; setTimeout(function () &#123; // 放入队列中执行所有成功的回调 _this.callbacks.forEach(callbackObj =&gt; &#123; callbackObj.onResolved(value) &#125;) &#125;) &#125; &#125; function reject(reason) &#123; // 如果状态已经修改，返回 if (_this.status !== &quot;pending&quot;) return; // 修改状态为fullFilled _this.status = &quot;rejected&quot;; // 保存value数据 _this.data = reason; if (_this.callbacks.length &gt; 0) &#123; setTimeout(function () &#123; // 放入队列中执行所有成功的回调 _this.callbacks.forEach(callbackObj =&gt; &#123; callbackObj.onRejected(reason) &#125;) &#125;) &#125; &#125; // 立即同步执行executor try &#123; executor(resolve, reject) &#125; catch (reason) &#123; // 如果执行器抛出异常，Promise对象变为rejected状态 reject(reason) &#125; &#125; then(onResolve, onReject) &#123; onResolve = typeof onResolve === &#x27;function&#x27; ? onResolve : value =&gt; value; onReject = typeof onReject === &#x27;function&#x27; ? onReject : reason =&gt; throw reason; const _this = this; return new Promise((resolve, reject) =&gt; &#123; function handle(callback) &#123; try &#123; const result = callback(_this.data) if (result instanceof Promise) &#123; result.then( value =&gt; resolve(value), reason =&gt; reject(reason) ) &#125; else &#123; resolve(result) &#125; &#125; catch (error) &#123; reject(error) &#125; &#125; if (_this.status === &quot;pending&quot;) &#123; _this.callbacks.push(&#123; onResolved() &#123; handle(onResolve) &#125;, onRejected() &#123; handle(onReject) &#125; &#125;) &#125; else if (_this.status === &quot;fullFilled&quot;) &#123; setTimeout(() =&gt; &#123; handle(resolve) &#125;) &#125; else if (_this.status === &quot;rejected&quot;) &#123; setTimeout(() =&gt; &#123; handle(reject) &#125;) &#125; &#125;) &#125; catch(onRejected) &#123; return this.then(undefined, onRejected) &#125; static resolve(value)&#123; return new Promise((resolve,reject)=&gt;&#123; if(value instanceof Promise)&#123; value.then(resolve,reject) &#125;else&#123; resolve(value) &#125; &#125;) &#125; static reject(reason)&#123; return new Promise((resolve,reject)=&gt;&#123; reject(reason) &#125;) &#125; static all(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; const values = new Array(promises.length); let count = 0; promises.forEach((p, index) =&gt; &#123; p.then( value =&gt; &#123; count++; values[index] = value; if (count === promises.length) resolve(values) &#125;, reject ) &#125;) &#125;) &#125; static race(promise) &#123; return new Promise((resolve, reject) =&gt; &#123; promise.forEach((p, index) =&gt; &#123; p.then( value =&gt; resolve(value), reason =&gt; reject(reason) ) &#125;) &#125;) &#125; static resolveDelay(value, time) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; if (value instanceof Promise) &#123; value.then(resolve,reject) &#125; else &#123; resolve(value) &#125; &#125;, time) &#125;) &#125; static rejectDelay(reason, time) &#123; return new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; reject(reason) &#125;,time) &#125;) &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://wisiw.github.io.git/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wisiw.github.io.git/tags/JavaScript/"},{"name":"Promise","slug":"Promise","permalink":"https://wisiw.github.io.git/tags/Promise/"},{"name":"源码解析","slug":"源码解析","permalink":"https://wisiw.github.io.git/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"}]},{"title":"【Webpack】package.json解析","slug":"【Webpack】package.json解析","date":"2021-01-27T07:45:11.000Z","updated":"2022-05-11T06:13:00.391Z","comments":true,"path":"2021/01/27/【Webpack】package.json解析/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/%E3%80%90Webpack%E3%80%91package.json%E8%A7%A3%E6%9E%90/","excerpt":"","text":"","categories":[],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"https://wisiw.github.io.git/tags/Webpack/"}]},{"title":"【Webpack】热更新原理解析","slug":"【Webpack】热更新原理解析","date":"2021-01-27T07:45:11.000Z","updated":"2022-05-11T06:09:55.797Z","comments":true,"path":"2021/01/27/【Webpack】热更新原理解析/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/%E3%80%90Webpack%E3%80%91%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/","excerpt":"","text":"","categories":[],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"https://wisiw.github.io.git/tags/Webpack/"}]},{"title":"【源码解析】map","slug":"【源码解析】map","date":"2021-01-27T07:37:26.000Z","updated":"2021-09-23T05:55:48.495Z","comments":true,"path":"2021/01/27/【源码解析】map/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/%E3%80%90%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91map/","excerpt":"","text":"","categories":[{"name":"后端","slug":"后端","permalink":"https://wisiw.github.io.git/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wisiw.github.io.git/tags/Java/"},{"name":"源码解析","slug":"源码解析","permalink":"https://wisiw.github.io.git/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"name":"map","slug":"map","permalink":"https://wisiw.github.io.git/tags/map/"}]},{"title":"【源码解析】Vue：生命周期","slug":"【源码解析】Vue：生命周期","date":"2021-01-27T07:36:57.000Z","updated":"2021-09-23T06:19:00.907Z","comments":true,"path":"2021/01/27/【源码解析】Vue：生命周期/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/%E3%80%90%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91Vue%EF%BC%9A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://wisiw.github.io.git/tags/Vue/"},{"name":"源码解析","slug":"源码解析","permalink":"https://wisiw.github.io.git/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"name":"生命周期","slug":"生命周期","permalink":"https://wisiw.github.io.git/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"}]},{"title":"【源码解析】axios使用与源码解析","slug":"【源码解析】axios使用与源码解析","date":"2021-01-27T07:36:11.000Z","updated":"2022-06-07T05:27:23.037Z","comments":true,"path":"2021/01/27/【源码解析】axios使用与源码解析/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/%E3%80%90%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91axios%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","excerpt":"","text":"","categories":[{"name":"axios","slug":"axios","permalink":"https://wisiw.github.io.git/categories/axios/"}],"tags":[{"name":"源码","slug":"源码","permalink":"https://wisiw.github.io.git/tags/%E6%BA%90%E7%A0%81/"},{"name":"axios","slug":"axios","permalink":"https://wisiw.github.io.git/tags/axios/"}]},{"title":"【面试题】React","slug":"【面试题】React","date":"2021-01-26T09:57:12.000Z","updated":"2021-09-23T04:00:34.544Z","comments":true,"path":"2021/01/26/【面试题】React/","link":"","permalink":"https://wisiw.github.io.git/2021/01/26/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%91React/","excerpt":"","text":"","categories":[{"name":"前端","slug":"前端","permalink":"https://wisiw.github.io.git/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"React","slug":"React","permalink":"https://wisiw.github.io.git/tags/React/"},{"name":"面试题","slug":"面试题","permalink":"https://wisiw.github.io.git/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"【源码解析】Vue：数据响应式原理","slug":"【源码解析】Vue：数据响应式原理","date":"2021-01-26T09:55:19.000Z","updated":"2021-09-23T06:18:57.573Z","comments":true,"path":"2021/01/26/【源码解析】Vue：数据响应式原理/","link":"","permalink":"https://wisiw.github.io.git/2021/01/26/%E3%80%90%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91Vue%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/","excerpt":"","text":"VUE源码-数据响应式原理12345678910111213141516171819202122232425262728293031323334353637383940var data = &#123; name:&#x27;wsw&#x27;, info:[ 27, &#123;sex:1&#125; ]&#125;function observe(data)&#123; if(Array.isArray(data))&#123; data.__proto__ = arrayMethods; this.observerArray(data) &#125;else&#123; walk(data); &#125;&#125;function observerArray(value)&#123; for(let i = 0; i&lt; value.length;i++)&#123; observe(value[i]) &#125;&#125;function walk(data)&#123; let keys = Object.keys(data); keys.forEach((key) =&gt; &#123; defineReactive(data,key,data[key]) &#125;)&#125;function defineReactive(data,key,value) &#123; observe(value) Object.defineProperty(data,key,&#123; get() &#123; return value &#125;, set(newV) &#123; if(newV == value)return; console.log(&quot;数据修改&quot;) observe(newV) value = newV; &#125; &#125;)&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041// 重写数组的方法 push/shift/unshift/pop/reverse/sort/splicelet oldArrayMethods = Array.prototype;let arrayMethods = Object.create(oldArrayMethods);const methods = [ &#x27;push&#x27;, &quot;shift&quot;, &quot;unshift&quot;, &quot;pop&quot;, &quot;reverse&quot;, &quot;sort&quot;, &quot;splice&quot;]methods.forEach( method =&gt; &#123; arrayMethods[method] = function (...args) &#123; const result = oldArrayMethods[method].apply(this,args); let inserted; let ob = this.__ob__; switch (method) &#123; case &#x27;push&#x27;: break; case &#x27;shift&#x27;: break; case &#x27;unshift&#x27;: inserted = args; break; case &#x27;pop&#x27;: break; case &#x27;reverse&#x27;: break; case &#x27;sort&#x27;: break; case &#x27;splice&#x27;: inserted = args.splice(2) break; default: break; &#125; if(inserted)ob.observerArray(inserted); // 当新增属性继续观测 return result; &#125;&#125;)","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://wisiw.github.io.git/tags/Vue/"},{"name":"源码","slug":"源码","permalink":"https://wisiw.github.io.git/tags/%E6%BA%90%E7%A0%81/"},{"name":"数据响应式","slug":"数据响应式","permalink":"https://wisiw.github.io.git/tags/%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/"}]},{"title":"【源码解析】Vue：虚拟DOM与diff算法","slug":"【源码解析】Vue：虚拟DOM与diff算法","date":"2021-01-26T09:55:03.000Z","updated":"2021-09-23T06:19:04.207Z","comments":true,"path":"2021/01/26/【源码解析】Vue：虚拟DOM与diff算法/","link":"","permalink":"https://wisiw.github.io.git/2021/01/26/%E3%80%90%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91Vue%EF%BC%9A%E8%99%9A%E6%8B%9FDOM%E4%B8%8Ediff%E7%AE%97%E6%B3%95/","excerpt":"","text":"","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://wisiw.github.io.git/tags/Vue/"},{"name":"源码解析","slug":"源码解析","permalink":"https://wisiw.github.io.git/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"name":"虚拟DOM与diff算法","slug":"虚拟DOM与diff算法","permalink":"https://wisiw.github.io.git/tags/%E8%99%9A%E6%8B%9FDOM%E4%B8%8Ediff%E7%AE%97%E6%B3%95/"}]},{"title":"【源码解析】Vue：模板引擎","slug":"【源码解析】Vue：模板引擎","date":"2021-01-26T09:54:43.000Z","updated":"2021-09-23T06:18:57.565Z","comments":true,"path":"2021/01/26/【源码解析】Vue：模板引擎/","link":"","permalink":"https://wisiw.github.io.git/2021/01/26/%E3%80%90%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91Vue%EF%BC%9A%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/","excerpt":"","text":"","categories":[],"tags":[{"name":"模板引擎","slug":"模板引擎","permalink":"https://wisiw.github.io.git/tags/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"},{"name":"Vue","slug":"Vue","permalink":"https://wisiw.github.io.git/tags/Vue/"},{"name":"源码解析","slug":"源码解析","permalink":"https://wisiw.github.io.git/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"}]},{"title":"算法","slug":"算法","date":"2021-01-26T09:53:39.000Z","updated":"2021-06-21T08:13:22.325Z","comments":true,"path":"2021/01/26/算法/","link":"","permalink":"https://wisiw.github.io.git/2021/01/26/%E7%AE%97%E6%B3%95/","excerpt":"","text":"斐波那契数列使用递归123456789101112var cache = &#123;&#125;;function fib(n)&#123; if(cache.hasOwnProperty(n))&#123; return cache[n]; &#125; var v= n == 0 || n == 1?fib(n-1) + fib(n-2) cache[n] = v; return v;&#125;for(let i=0;i&lt;=9;i++)&#123; fib(i);&#125; 不使用递归123456function a(n)&#123; var arr = [1,1]; while(arr.length &lt;= n)&#123; arr.push(arr[arr.length-1] + arr[ arr.length-2])&#125;console.log(arr) 重复字符串中连续重复次数最多的字符12345678910111213var s = &quot;aaadafakssssshhhhhrrrrrgggggkkkkkffffwwwwddddd&quot;var maxRepeatCount = 0,maxReapeatChar = &#x27;&#x27;;var i = 0,j = 1;while ( i &lt;= s.length - 1 ) &#123; if(s[i] !== s[j])&#123; i = j; if(maxRepeatCount &lt; j-i)&#123; maxRepeatCount = j-i; maxReapeatChar = s[i] &#125; &#125; j++;&#125; 智能重复123456789101112131415161718192021222324252627282930var str = &quot;2[1[a]3[b]2[3[c]4[d]]]&quot;;function smartRepeat(str) &#123; var index = 0, stack1 = [], stack2 = [], rest = str; while (index &lt; str.length - 1) &#123; rest = str.substring(index); if (/^\\d+\\[/.test(rest)) &#123; // 剩余字符串以数字开头，1）取出这个数字压入数字栈；2）字符栈压入空字符串；3）指针后移至[之后 let times = Number(rest.match(/^(\\d+)\\[/)[1]); stack1.push(times); stack2.push(&#x27;&#x27;); index += times.toString().length + 1; &#125; else if (/^\\w+\\]/.test(rest)) &#123; // 剩余字符串以字母开头，1）取出字符并压入字符栈；2）指针后移至字符之后 let word = rest.match(/^(\\w+)\\]/)[1]; stack2[stack2.length - 1] = word; index += word.length; &#125; else if (rest[0] == &#x27;]&#x27;)&#123; // 剩余字符串以]开头，1）数字栈弹栈；2）字符栈弹栈3）弹出的字符重复刚才弹栈的次数并拼接到新的字符栈顶 let times = stack1.pop(); let word = stack2.pop(); stack2[stack2.length - 1] += word.repeat(times) index++; &#125; &#125; // 当while结束后，stack1和stack2中肯定存在剩余1项，返回stack2中剩余的这一项，重复stack1中剩余的这一项的次数，返回这个字符串 return stack2[0].repeat(stack1[0])&#125; 判断标签是否闭合使用while与replace12345678910function isValid(s) &#123; while (s.length) &#123; let temp = s; s = s.replace(&#x27;()&#x27;, &#x27;&#x27;); s = s.replace(&#x27;[]&#x27;, &#x27;&#x27;); s = s.replace(&#x27;&#123;&#125;&#x27;, &#x27;&#x27;); if (s == temp) return false &#125; return true;&#125; 使用指针与栈123456789101112131415161718function isValid(s) &#123; let map = &#123; &#x27;&#123;&#x27;: &#x27;&#125;&#x27;, &#x27;(&#x27;: &#x27;)&#x27;, &#x27;[&#x27;: &#x27;]&#x27; &#125; let stack = [] for(let i = 0; i &lt; s.length ; i++) &#123; // 如果此字符在集合中存在，存入栈中 if(map[s[i]]) &#123; stack.push(s[i]) &#125; else if(s[i] !== map[stack.pop()])&#123; // 如果此字符与栈顶不同，则说明字符串并不是封闭的 return false &#125; &#125; return stack.length === 0&#125; 树树的遍历深度优先（DFC）以深度优先为策略，从根节点开始一直遍历到某个叶子结点，再遍历另外一个分支 广度优先（BFC）##路径总和 相同的树对称二叉树翻转二叉树另一个树的子树验证二叉搜索树二叉树的最小深度平衡二叉树将有序数组转换为二叉搜索树二叉搜索树迭代器二叉搜索树的最近公共祖先二叉树的最近公共祖先链表合并两个有序链表反转链表回文链表倒数第K个节点找出链表的中间节点两个链表的第一个公共节点LRU的缓存机制#数组 打乱数组构建乘积数组##使数组唯一的最小增量##扑克牌中的顺子##数组的交集##数组的交集II##数组中的第K个最大元素##合并两个有序数组##全排列##螺旋矩阵##螺旋矩阵II##三数之和##更接近的三数之和 数学##计算质数##求众数##中位数##只出现一次的数字##有效的三角形个数 #动态规划 斐波那契数列买卖股票的最佳时机I买卖股票的最佳时机II盛最多水的容器接雨水无重复字符的最长子串最大子序和最长公共前缀最长回文子串打家劫舍打家劫舍 II打家劫舍 III","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://wisiw.github.io.git/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【代码片段】根据字符串路径访问对象的成员","slug":"【代码片段】根据字符串路径访问对象的成员","date":"2020-03-01T01:19:38.000Z","updated":"2021-09-23T06:07:06.533Z","comments":true,"path":"2020/03/01/【代码片段】根据字符串路径访问对象的成员/","link":"","permalink":"https://wisiw.github.io.git/2020/03/01/%E3%80%90%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E3%80%91%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%B7%AF%E5%BE%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%88%90%E5%91%98/","excerpt":"","text":"1234567891011121314151617181920/** * 在dataObj对象中，寻找用连续.符号（a.b.c）的keyName属性 * @param dataObj * @param keyName */function lookUp(dataObj, keyName) &#123; // 查看传入的keyName中有没有.符号 if (keyName.indexOf(&#x27;.&#x27;) != -1) &#123; let names = keyName.split(&quot;.&quot;); // 设置临时变量，存储当前层查找到的数据 let temp = dataObj; for (let i = 0; i &lt; names.length; i++) &#123; // 每找一层，就将临时变量设为新的 temp = temp[names[i]] &#125; return temp; &#125; // 如果没有.符号，直接返回dataObj[keyName] return dataObj[keyName]&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://wisiw.github.io.git/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://wisiw.github.io.git/tags/Vue/"},{"name":"代码片段","slug":"代码片段","permalink":"https://wisiw.github.io.git/tags/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"},{"name":"源码","slug":"源码","permalink":"https://wisiw.github.io.git/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"【代码片段】瀑布流","slug":"【代码片段】瀑布流","date":"2020-02-27T07:54:19.000Z","updated":"2021-09-23T06:05:53.301Z","comments":true,"path":"2020/02/27/【代码片段】瀑布流/","link":"","permalink":"https://wisiw.github.io.git/2020/02/27/%E3%80%90%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E3%80%91%E7%80%91%E5%B8%83%E6%B5%81/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html&gt;&lt;html lang=&quot;ch&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; body&#123; width: 100%; height: 100%; &#125; .main&#123; position: static; margin: 0; border: 0; padding: 0; background-color: antiquewhite; overflow: hidden; &#125; .main div&#123; width: 100px; padding: 10px; position: absolute; display: inline-block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;img style=&quot;width:100%;height: 200px&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;img style=&quot;width:100%;height: 151px&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;img style=&quot;width:100%;height: 256px&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;img style=&quot;width:100%;height: 331px&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;img style=&quot;width:100%;height: 222px&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;img style=&quot;width:100%;height: 444px&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;img style=&quot;width:100%;height: 111px&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;img style=&quot;width:100%;height: 531px&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;img style=&quot;width:100%;height: 661px&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;img style=&quot;width:100%;height: 145px&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;img style=&quot;width:100%;height: 103px&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;img style=&quot;width:100%;height: 133px&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; f(); window.onresize = () =&gt; f() function f() &#123; var box = document.getElementsByClassName(&quot;box&quot;), boxWidth = box[0].offsetWidth, screenWidth = document.getElementsByClassName(&quot;main&quot;)[0].offsetWidth, cols = parseInt(screenWidth/boxWidth), heightArr = []; for(let i =0 ;i&lt;box.length;i++)&#123; let boxHeight = box[i].offsetHeight, left = 0, top = 0; box[i].style.position = &quot;absolute&quot;; if(i&lt;cols)&#123; left = i * boxWidth; top = 0; heightArr[i] = boxHeight; &#125;else&#123; let num = parseInt(i%cols), min = Math.min(...heightArr), key = heightArr.indexOf(min); left = key * boxWidth; top = min; heightArr[key] += boxHeight; &#125; box[i].style.left = left + &quot;px&quot;; box[i].style.top = top + &quot;px&quot;; &#125; &#125;&lt;/script&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://wisiw.github.io.git/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"代码片段","slug":"代码片段","permalink":"https://wisiw.github.io.git/tags/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"},{"name":"瀑布流","slug":"瀑布流","permalink":"https://wisiw.github.io.git/tags/%E7%80%91%E5%B8%83%E6%B5%81/"}]},{"title":"【面试题】Vue","slug":"【面试题】Vue","date":"2020-01-25T07:17:13.000Z","updated":"2021-12-01T02:38:44.539Z","comments":true,"path":"2020/01/25/【面试题】Vue/","link":"","permalink":"https://wisiw.github.io.git/2020/01/25/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%91Vue/","excerpt":"","text":"一、Vue 基础 Vue的基本原理 双向数据绑定的原理 使用 Object.defineProperty() 来进行数据劫持有什么缺点？ MVVM、MVC、MVP的区别 Computed 和 Watch 的区别 Computed 和 Methods 的区别 slot是什么？有什么作用？原理是什么？ 过滤器的作用，如何实现一个过滤器 如何保存页面的当前的状态 常见的事件修饰符及其作用 v-if、v-show、v-html 的原理 v-if和v-show的区别 v-model 是如何实现的，语法糖实际是什么？ v-model 可以被用在自定义组件上吗？如果可以，如何使用？ data为什么是一个函数而不是对象 对keep-alive的理解，它是如何实现的，具体缓存的是什么？ $nextTick 原理及作用 Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？ Vue中封装的数组方法有哪些，其如何实现页面更新 Vue 单页应用与多页应用的区别 Vue template 到 render 的过程 Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？ 简述 mixin、extends 的覆盖逻辑 描述下Vue自定义指令 子组件可以直接改变父组件的数据吗？ Vue是如何收集依赖的？ 对 React 和 Vue 的理解，它们的异同 Vue的优点 assets和static的区别 delete和Vue.delete删除数组的区别 vue如何监听对象或者数组某个属性的变化 什么是 mixin ？ Vue模版编译原理 对SSR的理解 Vue的性能优化有哪些 对 SPA 单页面的理解，它的优缺点分别是什么？ template和jsx的有什么分别？ vue初始化页面闪动问题 extend 有什么作用 mixin 和 mixins 区别 MVVM的优缺点? 二、生命周期 说一下Vue的生命周期 Vue 子组件和父组件执行顺序 created和mounted的区别 一般在哪个生命周期请求异步数据 keep-alive 中的生命周期哪些 三、组件通信 组件通信的方式 四、路由 Vue-Router 的懒加载如何实现 路由的hash和history模式的区别 如何获取页面的hash变化 route和route 和route和router 的区别 如何定义动态路由？如何获取传过来的动态参数？ Vue-router 路由钩子在生命周期的体现 Vue-router跳转和location.href有什么区别 params和query的区别 Vue-router 导航守卫有哪些 对前端路由的理解 五、Vuex Vuex 的原理 Vuex中action和mutation的区别 Vuex 和 localStorage 的区别 Redux 和 Vuex 有什么区别，它们的共同思想 为什么要用 Vuex 或者 Redux Vuex有哪几种属性？ Vuex和单纯的全局对象有什么区别？ 为什么 Vuex 的 mutation 中不能做异步操作？ Vuex的严格模式是什么,有什么作用，如何开启？ 如何在组件中批量使用Vuex的getter属性 如何在组件中重复使用Vuex的mutation 六、Vue 3.0 Vue3.0有什么更新 defineProperty和proxy的区别 Vue3.0 为什么要用 proxy？ Vue 3.0 中的 Vue Composition API？ Composition API与React Hook很像，区别是什么 七、虚拟DOM 对虚拟DOM的理解？ 虚拟DOM的解析过程 为什么要用虚拟DOM 虚拟DOM真的比真实DOM性能好吗 DIFF算法的原理 Vue中key的作用 为什么不建议用index作为key? 生命周期VUE实例从创建到销毁的过程 浏览器渲染有8个钩子，服务端渲染只有beforeCreate和created beforeCreate当前阶段data、methods、computed、watch上的数据和方法都不能访问 可以在这加个loading事件，在加载实例时触发 created实例创建完成，当前阶段已经完成了数据观测，此时修改数据不会触发updated函数，可以在当前阶段获取一些初始数据，但DOM节点$el未创建，无法进行交互，但是可以通过$nextTick访问 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用 beforeMount挂载之前，在这之前template模板已导入渲染函数编译，虚拟DOM已经创建完成，即将开始渲染，此时可以进行数据更改，不会触发updated mounted挂载完成之后，真实DOM挂载完毕，数据完成双向绑定，可以访问到DOM节点，可以使用$ref对DOM进行操作 获取到DOM节点;对数据统一处理 beforeUpdate发生在更新之前，通过响应式数据更新触发，发生在虚拟DOM重新渲染之前，可以在当前阶段更改数据，不会造成重新渲染 update更新完成之后，当前节点组件DOM更新完成，避免在此阶段更改数据，因为可能会导致无限循环 beforeDestory实例销毁之前，当前阶段组件实例还存在，可以在当前阶段清除计时器、销毁父组件对子组件的重复监听 destoryed实例销毁之后，组件已被拆解，数据绑定被卸除，监听被移除，子实例被销毁 生命周期调用顺序为什么 vue 组件中 data 必须是一个函数？对象为引用类型，当复用组件时，由于数据对象都指向同一个 data 对象，当在一个组件中修改 data 时，其他重用的组件中的 data 会同时被修改；而使用返回对象的函数，由于每次返回的都是一个新对象（Object 的实例），引用地址不同，则不会出现这个问题。 vue 中 v-if 和 v-show 有什么区别？v-if 和 v-show 看起来似乎差不多，当条件不成立时，其所对应的标签元素都不可见，但是这两个选项是有区别的: 1、v-if 在条件切换时，会对标签进行适当的创建和销毁，而 v-show 则仅在初始化时加载一次，因此 v-if 的开销相对来说会比 v-show 大。 2、v-if 是惰性的，只有当条件为真时才会真正渲染标签；如果初始条件不为真，则 v-if 不会去渲染标签。v-show 则无论初始条件是否成立，都会渲染标签，它仅仅做的只是简单的 CSS 切换。 v-for与v-if的优先级问题1）v-for优先于v-if被解析 12// src/complier/codegen/index.js// 会优先处理for，两者不同级的话生成不同的渲染函数 2）如果同时出现，每次渲染会先执行循环再判断条件，无论如何循环都不可避免，浪费性能3）要避免这种情况，在外层嵌套template，在这一层进行v-if判断，然后在内部进行v-for Vue 组件中 data 为什么必须是函数？为什么根实例没有限制1// src/score/instance/state.js-initData() 因为Vue组件可能会存在多个实例，如果使用对象形式定义data，则会导致他们在内存中指向向同一个对象，会造成数据污染。 采用函数形式，在initData时会将其作为工厂函数返回一个全新的data对象，有效避免了多实例之间的数据污染问题。 而根实例不存在该限制，以为根实例有且只能有一个。 vue中key的作用和工作原理？1// src/core/vdom/patch.js-updateChildren() key的作用是为了高效的更新虚拟DOM，其原理是vue在patch过程中通过key精准判断两个节点是否是同一个，从而避免频繁地更新不同元素，使得整个patch过程更加高效，减少DOM的操作，提高性能 若不设置key还可能会在列表更新引发一些隐蔽的bug vue在使用相同标签名元素的过渡切换时，也会使用到key属性，其目的是为了让vue可以区分它们，否则vue只会替换内部标签属性而不会触发过渡过程 虚拟DOM为什么？虚拟DOM本质上是用JavaScript对象描述的DOM节点，是对真实DOM的抽象。 浏览器获取到页面资源后，会对页面进行渲染，分别生成DOM树和CSS样式表，合并生成Render树，进行布局绘制。 用原生JS和JQuery操作真实DOM时，浏览器会从头到尾执行一遍渲染流程，触发回流和重绘，频繁地操作DOM，会有一定的性能问题，因此需要在patch过程中尽可能的一次性将差异更新到DOM中，但还是不可避免的去操作真实DOM，因此出现了虚拟DOM，使用一个JavaScript对象去描真实的DOM节点，在patch中使用diff算法比较新旧虚拟DOM，获得最小差异，再将结果反映到真实DOM上。因为在浏览器中，js操作要比操作真实DOM迅速许多，所以可以节约大量的时间。 是什么？是一个用来描述真实DOM的JavaScript对象，在patch中使用Diff算法来获取最小更新，再反映到真实DOM中 优缺点？ 优点 保证性能下限（虽然不能达到手动优化的最好结果，但是比起粗暴的DOM操作，性能要好很多） 无需手动操作DOM 跨平台（本质上是JavaScript对象，可以更方便地跨平台操作，例如服务端渲染、移动端开发） 缺点 无法进行极致优化（比不上在代码中进行手工优化） Diff算法？diff算法是新旧虚拟DOM的比较算法，通过对两者进行比较，将变化的地方更新在真实DOM上。另外，也需要diff算法进行高效的对比过程，，从而降低时间复杂度O(n) vue2.X中为了降低watcher粒度，每个组件只有一个watcher与之对应，只有引入diff才能精确找到发生变化的地方 执行时刻是组件实例执行其更新函数patch时，它会对比上一次渲染结果的oldVnode与新的渲染结果newVnode 遵循深度优先，同层比较的策略： 两个节点之间的比较会根据他们是否有子节点或者文本节点做不同的操作； 使用列表比对，对两组子节点的头尾进行四次比较（旧前与新前、旧后与新后、旧前与新后、旧后与新前）；如果没有找到相同节点，按照通用方法遍历查找；查找结束后按照情况处理剩余节点。使用key可以精确查找到相同节点，因此patch过程非常高效 template编译先通过while和栈转化为AST树，再得到render函数返回VNode 通过compile编译器把template编译成AST语法树 AST经过generate得到render函数，render返回VNode 常用的事件修饰符 .stop: 阻止冒泡 .prevent: 阻止默认行为 .self: 仅绑定元素自身触发 .once: 2.1.4 新增，只触发一次 passive: 2.3.0 新增，滚动事件的默认行为 (即滚动行为) 将会立即触发，不能和.prevent 一起使用 .sync 修饰符 从 2.3.0 起 vue 重新引入了.sync 修饰符，但是这次它只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 v-on 监听器。示例代码如下： 1&lt;comp :foo.sync=&quot;bar&quot;&gt;&lt;/comp&gt; 会被扩展为： 1&lt;comp :foo=&quot;bar&quot; @update:foo=&quot;val =&gt; bar = val&quot;&gt;&lt;/comp&gt; 当子组件需要更新 foo 的值时，它需要显式地触发一个更新事件： 1this.$emit(&#x27;update:foo&#x27;, newValue) vue 如何获取 dom先给标签设置一个 ref 值，再通过 this.$refs.domName 获取，例如： 123&lt;div ref=&quot;test&quot;&gt;&lt;/div&gt;const dom = this.$refs.test v-on 可以监听多个方法吗？是可以的，来个例子： 1&lt;input type=&quot;text&quot; v-on=&quot;&#123; input:onInput,focus:onFocus,blur:onBlur, &#125;&quot;&gt; assets 和 static 的区别这两个都是用来存放项目中所使用的静态资源文件。 两者的区别： assets 中的文件在运行 npm run build 的时候会打包，简单来说就是会被压缩体积，代码格式化之类的。打包之后也会放到 static 中。 static 中的文件则不会被打包。 建议：将图片等未处理的文件放在 assets 中，打包减少体积。而对于第三方引入的一些资源文件如 iconfont.css 等可以放在 static 中，因为这些文件已经经过处理了。 slot 插槽很多时候，我们封装了一个子组件之后，在父组件使用的时候，想添加一些 dom 元素，这个时候就可以使用 slot 插槽了，但是这些 dom 是否显示以及在哪里显示，则是看子组件中 slot 组件的位置了。 vue 初始化页面闪动问题使用 vue 开发时，在 vue 初始化之前，由于 div 是不归 vue 管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于 的字样，虽然一般情况下这个时间很短暂，但是我们还是有必要让解决这个问题的。 首先：在 css 里加上以下代码 123[v-cloak] &#123; display: none;&#125; 如果没有彻底解决问题，则在根元素加上 style=“display: none;” :style=”{display: ‘block’}” 组件化组件化使开发者使用小型、独立和可复用的组件构建大型应用 能大幅提高应用开发效率、测试性、复用性等 按使用分类为：页面组件、业务组件、通用组件 VUE的组件是基于配置的，平时编写的组件是组件配置而非组件，框架后续会生成其构造函数，基于VueComponent，扩展于Vue vue中的组件化技术有：props、自定义事件、插槽等，主要用于组件通信、扩展等 合理的划分组件，有利于提升应用性能 组件应该是高内聚、低耦合 遵循单向数据流的原则 单向数据流是什么？所有的prop使得 其父子prop之间形成了一个单向下行绑定（父级prop的更新会向下流动到子组件中，但反过来则不行）。 为什么？防止从子组件意外改变父级组件的状态，从而导致应用的数据流向混乱 好处？组件的prop有了单一来源，每次父级组件发生更新时，子组件的所有prop都会刷新为最新值。 如果想要子组件更新父组件的状态，只能通过**$emit**派发一个自定义事件，父组件接收后，由父组件自身修改 需要改变prop的情况的处理1）prop用来传递初始值，组件将其作为一个本地data来处理此时，需要定义一个本地data的属性并将此prop作为其初始值 12345678export default &#123; props: [&#x27;initialCounter&#x27;], data: function () &#123; return &#123; counter: this.initialCounter//定义本地的data属性接收prop初始值 &#125; &#125;&#125; 2）prop以一种原始值传入，需要对其进行转换此时，最好使用这个prop的值来定义一个计算属性 12345678export default &#123; props: [&#x27;size&#x27;], computed: &#123; normalizedSize: function () &#123; return this.size.trim().toLowerCase() &#125; &#125;&#125; computed与watch计算属性 computed： 支持缓存，只有依赖数据发生改变，才会重新进行计算 不支持异步，当 computed 内有异步操作时无效，无法监听数据的变化 computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于 data 中声明过或者父组件传递的 props 中的数据通过计算得到的值 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用 computed 如果 computed 属性属性值是函数，那么默认会走 get 方法；函数的返回值就是属性的属性值；在 computed 中的，属性都有一个 get 和一个 set 方法，当数据变化时，调用 set 方法。 侦听属性 watch： 不支持缓存，数据变，直接会触发相应的操作； watch 支持异步； 监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值； 当一个属性发生变化时，需要执行对应的操作；一对多； 监听数据必须是 data 中声明过或者父组件传递过来的 props 中的数据，当数据变化时，触发其他操作，函数有两个参数： immediate：组件加载立即触发回调函数执行 1234567891011export default &#123; watch: &#123; firstName: &#123; handler(newName, oldName) &#123; this.fullName = newName + &#x27; &#x27; + this.lastName; &#125;, // 代表在wacth里声明了firstName这个方法之后立即执行handler方法 immediate: true &#125; &#125;&#125; deep: deep 的意思就是深入观察，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，但是这样性能开销就会非常大了，任何修改 obj 里面任何一个属性都会触发这个监听器里的 handler 1234567891011export default &#123; watch: &#123; obj: &#123; handler(newName, oldName) &#123; console.log(&#x27;obj.a changed&#x27;); &#125;, immediate: true, deep: true &#125; &#125;&#125; 优化：我们可以使用字符串的形式监听 1234567891011export default &#123; watch: &#123; &#x27;obj.a&#x27;: &#123; handler(newName, oldName) &#123; console.log(&#x27;obj.a changed&#x27;); &#125;, immediate: true, // deep: true &#125; &#125;&#125; 这样 Vue.js 才会一层一层解析下去，直到遇到属性 a，然后才给 a 设置监听函数。 组件通信父–&gt;子子–&gt;父兄弟vue-loadervue 文件的一个加载器，跟 template/js/style 转换成 js 模块 $nextTick 是什么？vue 实现响应式并不是数据发生变化后 dom 立即变化，而是按照一定的策略来进行 dom 更新。 nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 nextTick，则可以在回调中获取更新后的 DOM vue设计理念vue的双向绑定原理观察者（observer）利用Object.definePropertype()拿到data依赖，遍历子集依赖，如果是数组，vue是通过拦截器重写了数组的原型链方法。set拿到所有的子依赖，告诉watcher（订阅者）每收集一个子依赖就new一个订阅者，最后订阅者被收集起来，dep就是个收集器，是个集合或者数组。 complier（编译器）匹配模板中的指令，进行赋值，render到当前页面中 vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 具体步骤： 第一步：需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化 第二步：compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: 1、在自身实例化时往属性订阅器(dep)里面添加自己 2、自身必须有一个update()方法 3、待属性变动dep.notice()通知时，能调用自身的 update() 方法，并触发Compile中绑定的回调，则功成身退。 第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。 如何监听对象或者数组某个属性的变化因为Object.defineProperty()的限制，监听不到数组某一项或者对象的某个属性值的变化。 使用this.$set()或者调用splice()、 push()、pop()、shift()、unshift()、sort()、reverse() 什么是依赖需要用到数据的地方，称为依赖 Vue1.x，细粒度依赖，用到数据的DOM都是依赖 Vue2.X，中等粒度依赖，用到数据的组件是依赖 在getter中收集依赖，在setter中触发依赖 把依赖收集的代码封装成一个Dep类，专门用来管理依赖，每个Observer的实例，成员中都有一个Dep实例 Watcher是一个中介，数据发生变化时通过Watcher中转 Dep中收集的依赖是Watcher，只有Watcher触发的getter才会收集依赖，哪个Watcher触发了getter，就把哪个Watcher收集到Dep中 Dep使用了发布订阅模式，当数据发生变化时，会循环subs列表，把所有的Watcher都通知一遍 Watcher将自己设置到全局的指定位置window.target，然后读取数据，因为读取了数据，所以触发了这个数据的getter，在这个getter中就能获取当前正在读取数据的Watcher，并收集到Dep中 Vue 中操作 data 中数组的方法中哪些可以触发视图更新，哪些不可以，不可以的话有什么解决办法？push ()、pop ()、shift ()、unshift ()、splice ()、sort ()、reverse () 这些方法会改变被操作的数组； filter ()、concat ()、slice () 这些方法不会改变被操作的数组，返回一个新的数组； 以上方法都可以触发视图更新。 利用索引直接设置一个数组项，例：this.array[index] = newValue 直接修改数组的长度，例：this.array.length = newLength 以上两种方法不可以触发视图更新； 可以用 this.$set(this.array,index,newValue) 或 this.array.splice(index,1,newValue) 解决方法 1 可以用 this.array.splice(newLength) 解决方法 2 混入（mixin） 全局混入在项目中怎么用？ 在 main.js 中写入 1234 import Vue from &#x27;vue&#x27;; import mixins from &#x27;./mixins&#x27;; Vue.mixin(mixins);123 之后，全局混入可以写在 mixins 文件夹中 index.js 中，全局混入会影响到每一个之后创建的 Vue 实例（组件）； 局部混入在项目中怎么用 局部混入的注册，在 mixins 文件中创建一个 a_mixin.js 文件，然后再 a.vue 文件中写入 123456&lt;script&gt; import aMixin from &#x27;mixins/a_mixin&#x27; export default&#123; mixins:[aMixin], &#125;&lt;/script&gt; 局部混入只会影响 a.vue 文件中创建的 Vue 实例，不会影响到其子组件创建的 Vue 实例； 组件的选项和混入的选项是怎么合并的 数据对象【data 选项】，在内部进行递归合并，并在发生冲突时以组件数据优先； 同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用； watch 对象合并时，相同的 key 合成一个对象，且混入监听在组件监听之前调用； 值为对象的选项【filters 选项、computed 选项、methods 选项、components 选项、directives 选项】将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。 computed 中的属性名和 data 中的属性名可以相同吗？不能同名，因为不管是 computed 属性名还是 data 数据名还是 props 数据名都会被挂载在 vm 实例上，因此这三个都不能同名。 123456if (key in vm.$data) &#123; warn(`The computed property &quot;$&#123;key&#125;&quot; is already defined in data.`, vm)&#125; else if (vm.$options.props &amp;&amp; key in vm.$options.props) &#123; warn(`The computed property &quot;$&#123;key&#125;&quot; is already defined as a prop.`, vm)&#125;12345 怎么强制刷新组件？ this.$forceUpdate()。 组件上加上 key，然后变化 key 的值。 watch 的属性和 methods 方法能用箭头函数定义吗？不可以。this 会是 undefind, 因为箭头函数中的 this 指向的是定义时的 this，而不是执行时的 this，所以不会指向 Vue 实例的上下文。 给组件绑定自定义事件无效怎么解决？加上修饰词.native。 怎么访问子组件的实例或者子元素？先用 ref 特性为子组件赋予一个 ID 引用 &lt;base-input ref=&quot;myInput&quot;&gt;&lt;/&lt;base-input&gt; 比如子组件有个 focus 的方法，可以这样调用 this.$refs.myInput.focus()； 比如子组件有个 value 的数据，可以这样使用 this.$refs.myInput.value。 先用 ref 特性为普通的 DOM 元素赋予一个 ID 引用 1234&lt;ul ref=&quot;mydiv&quot;&gt; &lt;li class=&quot;item&quot;&gt;第一个li&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;第一个li&lt;/li&gt;&lt;/ul&gt; 1console.log(this.$refs[&#x27;mydiv&#x27;].getElementsByClassName(&#x27;item&#x27;)[0].innerHTML)//第一个li 怎么在子组件中访问父组件的实例？怎么在组件中访问到根实例？使用 this.$parent 来访问 1this.$root 组件会在什么时候下被销毁？ 没有使用 keep-alive 时的路由切换； v-if=&#39;false&#39;； 执行 vm.$destroy()； is 这个特性你有用过吗？主要用在哪些方面？ 动态组件 &lt;component :is=&quot;componentName&quot;&gt;&lt;/component&gt;， componentName 可以是在本页面已经注册的局部组件名和全局组件名，也可以是一个组件的选项对象。 当控制 componentName 改变时就可以动态切换选择组件。 is 的用法 有些 HTML 元素，诸如 &lt;ul&gt;、&lt;ol&gt;、&lt;table&gt; 和 &lt;select&gt;，对于哪些元素可以出现在其内部是有严格限制的。 而有些 HTML 元素，诸如 &lt;li&gt;、&lt;tr&gt; 和 &lt;option&gt;，只能出现在其它某些特定的元素内部。 123&lt;ul&gt; &lt;card-list&gt;&lt;/card-list&gt;&lt;/ul&gt; 所以上面 &lt;card-list&gt;&lt;/card-list&gt; 会被作为无效的内容提升到外部，并导致最终渲染结果出错。应该这么写： 123&lt;ul&gt; &lt;li is=&quot;cardList&quot;&gt;&lt;/li&gt;&lt;/ul&gt; prop 验证的 type 类型有哪几种？String、Number、Boolean、Array、Object、Date、Function、Symbol， 此外还可以是一个自定义的构造函数 Personnel，并且通过 instanceof 来验证 propwokrer 的值是否是通过这个自定义的构造函数创建的。 123456789function Personnel(name,age)&#123; this.name = name; this.age = age;&#125;export default &#123; props:&#123; wokrer:Personnel &#125;&#125; 在 Vue 事件中传入 $event ，使用 $event.target和 event.currentTarget 有什么区别？$event.currentTarget 始终指向事件所绑定的元素，而 $event.target 指向事件发生时的元素。 使用事件修饰符要注意什么？要注意顺序很重要，用 @click.prevent.self 会阻止所有的点击，而 @click.self.prevent 只会阻止对元素自身的点击。 说说你对 Vue 的表单修饰符.lazy 的理解？input 标签 v-model 用 lazy 修饰之后，并不会立即监听 input 的 value 的改变，会在 input 失去焦点之后，才会监听 input 的 value 的改变。 v-once 的使用场景有哪些？其作用是只渲染元素和组件一次。随后的重新渲染，元素 / 组件及其所有的子节点将被视为静态内容并跳过。故当组件中有大量的静态的内容可以使用这个指令。 v-cloak 和 v-pre 有什么作用？v-cloak：可以解决在页面渲染时把未编译的 Mustache 标签（&#123;&#123;value&#125;&#125;）给显示出来。 123456[v-cloak] &#123; display: none!important;&#125;&lt;div v-cloak&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt; v-pre：跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。 1&lt;span v-pre&gt;&#123;&#123; this will not be compiled &#125;&#125;&lt;/span&gt; 怎么使 css 样式只在当前组件中生效？在 style 上加 scoped 属性需要注意哪些？你知道 style 上加 scoped 属性的原理吗？1&lt;style lang=&quot;less&quot; scoped&gt; &lt;/style&gt; 如果在公共组件中使用，修改公共组件的样式需要用 /deep/。 vue 通过在 DOM 结构以及 css 样式上加上唯一的标记 data-v-xxxxxx，保证唯一，达到样式私有化，不污染全局的作用。 Vue 渲染模板时怎么保留模板中的 HTML 注释呢？ 在组件中将 comments 选项设置为 true &lt;template comments&gt; ... &lt;template&gt; Vue 中怎么重置 data？1Object.assign(this.$data,this.$options.data()) 过滤器中可以用 this 吗？不可以 Vue在created和mounted这两个生命周期中请求数据有什么区别呢？在created中，页面视图未出现，如果请求信息过多，页面会长时间处于白屏状态，DOM节点没出来，无法操作DOM节点。在mounted不会这样，比较好。 说说你对keep-alive的理解keep-alive是一个抽象组件：它自身不会渲染一个DOM元素，也不会出现在父组件链中；使用keep-alive包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。 其有三个参数 include定义缓存白名单，会缓存的组件； exclude定义缓存黑名单，不会缓存的组件； 以上两个参数可以是逗号分隔字符串、正则表达式或一个数组,include=&quot;a,b&quot;、:include=&quot;/a|b/&quot;、:include=&quot;[&#39;a&#39;, &#39;b&#39;]&quot;； 匹配首先检查组件自身的 name 选项，如果 name 选项不可用，则匹配它的局部注册名称 (父组件 components 选项的键值)。匿名组件不能被匹配； max最多可以缓存多少组件实例。一旦这个数字达到了，在新实例被创建之前，已缓存组件中最久没有被访问的实例会被销毁掉； 不会在函数式组件中正常工作，因为它们没有缓存实例； 当组件在内被切换，它的activated和deactivated这两个生命周期钩子函数将会被对应执行。 使用v-for遍历对象时，是按什么顺序遍历的？如何保证顺序？按 Object.keys() 的顺序的遍历，转成数组保证顺序。 key除了在v-for中使用，还有什么作用？还可以强制替换元素/组件而不是重复使用它。在以下场景可以使用 完整地触发组件的生命周期钩子 触发过渡 123&lt;transition&gt; &lt;span :key=&quot;text&quot;&gt;&#123;&#123; text &#125;&#125;&lt;/span&gt;&lt;/transition&gt; 当 text 发生改变时，&lt;span&gt;会随时被更新，因此会触发过渡。 使用key要什么要注意的吗？ 不要使用对象或数组之类的非基本类型值作为key，请用字符串或数值类型的值； 不要使用数组的index作为key值，因为在删除数组某一项，index也会随之变化，导致key变化，渲染会出错。 例：在渲染[a,b,c]用 index 作为 key，那么在删除第二项的时候，index 就会从 0 1 2 变成 0 1（而不是 0 2)，随之第三项的key变成1了，就会误把第三项删除了。 说说组件的命名规范给组件命名有两种方式，一种是使用链式命名my-component，一种是使用大驼峰命名MyComponent， 在字符串模板中&lt;my-component&gt;&lt;/my-component&gt; 和 &lt;MyComponent&gt;&lt;/MyComponent&gt;都可以使用， 在非字符串模板中最好使用&lt;MyComponent&gt;&lt;/MyComponent&gt;，因为要遵循W3C规范中的自定义组件名 (字母全小写且必须包含一个连字符)，避免和当前以及未来的 HTML 元素相冲突。 为什么组件中data必须用函数返回一个对象？对象为引用类型，当重用组件时，由于数据对象都指向同一个data对象，当在一个组件中修改data时，其他重用的组件中的data会同时被修改；而使用返回对象的函数，由于每次返回的都是一个新对象（Object的实例），引用地址不同，则不会出现这个问题。 组件的name选项有什么作用？ 递归组件时，组件调用自身使用； 用is特殊特性和component内置组件标签时使用； keep-alive内置组件标签中include和exclude属性中使用。 说下$attrs和$listeners的使用场景？$attrs: 包含了父作用域中（组件标签）不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。 在创建基础组件时候经常使用，可以和组件选项inheritAttrs:false和配合使用在组件内部标签上用v-bind=&quot;$attrs&quot;将非prop特性绑定上去； $listeners: 包含了父作用域中（组件标签）的 (不含.native) v-on 事件监听器。 在组件上监听一些特定的事件，比如focus事件时，如果组件的根元素不是表单元素的，则监听不到，那么可以用v-on=&quot;$listeners&quot;绑定到表单元素标签上解决。 EventBus注册在全局上时，路由切换时会重复触发事件，如何解决呢？在有使用$on的组件中要在beforeDestroy钩子函数中用$off销毁。 Vue组件里写的原生addEventListeners监听事件，要手动去销毁吗？为什么？要，不然会造成多次绑定和内存泄露。 Vue组件里的定时器要怎么销毁？ 如果页面上有很多定时器，可以在data选项中创建一个对象timer，给每个定时器取个名字一一映射在对象timer中，在beforeDestroy构造函数中for(let k in this.timer)&#123;clearInterval(k)&#125;； 如果页面只有单个定时器，可以这么做。 1234const timer = setInterval(() =&gt;&#123;&#125;, 500);this.$once(&#x27;hook:beforeDestroy&#x27;, () =&gt; &#123; clearInterval(timer);&#125;) Vue中能监听到数组变化的方法有哪些？为什么这些方法能监听到呢？push()、pop()、shift()、unshift()、splice()、sort()、reverse()，这些方法在Vue中被重新定义了，故可以监听到数组变化； filter()、concat()、slice()，这些方法会返回一个新数组，也可以监听到数组的变化。 在Vue中哪些数组变化无法监听，为什么，怎么解决？ 利用索引直接设置一个数组项时； 修改数组的长度时。 第一个情况，利用已有索引直接设置一个数组项时Object.defineProperty()是可以监听到，利用不存在的索引直接设置一个数组项时Object.defineProperty()是不可以监听到，但是官方给出的解释是由于JavaScript的限制，Vue不能检测以上数组的变动，其实根本原因是性能问题，性能代价和获得的用户体验收益不成正比。 第二个情况，原因是Object.defineProperty()不能监听到数组的length属性。 用this.$set(this.items, indexOfItem, newValue)或this.items.splice(indexOfItem, 1, newValue)来解决第一种情况； 用this.items.splice(newLength)来解决第二种情况。 在Vue中哪些对象变化无法监听，为什么，怎么解决？ 对象属性的添加 对象属性的删除 因为Vue是通过Object.defineProperty来将对象的key转成getter/setter的形式来追踪变化，但getter/setter只能追踪一个数据是否被修改，无法追踪新增属性和删除属性，所以才会导致上面对象变化无法监听。 用this.$set(this.obj,&quot;key&quot;,&quot;newValue&quot;)来解决第一种情况； 用Object.assign来解决第二种情况。 删除对象用delete和Vue.delete有什么区别？ delete：只是被删除对象成员变为&#39; &#39;或undefined，其他元素键值不变； Vue.delete：直接删了对象成员，如果对象是响应式的，确保删除能触发更新视图，这个方法主要用于避开 Vue 不能检测到属性被删除的限制。 &lt;template&gt;&lt;/template&gt;有什么用？当做一个不可见的包裹元素，减少不必要的DOM元素，整个结构会更加清晰。 Vue怎么定义全局方法有三种 挂载在Vue的prototype上 123456789// base.jsconst install = function (Vue, opts) &#123; Vue.prototype.demo = function () &#123; console.log(&#x27;我已经在Vue原型链上&#x27;) &#125;&#125;export default &#123; install&#125; 1234//main.js//注册全局函数import base from &#x27;service/base&#x27;;Vue.use(base); 利用全局混入mixin 用this.$root.$on绑定方法，用this.$root.$off解绑方法，用this.$root.$emit全局调用。 12345this.$root.$on(&#x27;demo&#x27;,function()&#123; console.log(&#x27;test&#x27;)&#125;)this.$root.$emit(&#x27;demo&#x27;)this.$root.$off(&#x27;demo&#x27;) Vue怎么改变插入模板的分隔符？用delimiters选项,其默认是[&quot;&#123;&#123;\", \"&#125;&#125;&quot;] 1234// 将分隔符变成ES6模板字符串的风格new Vue(&#123; delimiters: [&#x27;$&#123;&#x27;, &#x27;&#125;&#x27;]&#125;) Vue变量名如果以_、$开头的属性会发生什么问题？怎么访问到它们的值？以 _或 $ 开头的属性 不会 被 Vue 实例代理，因为它们可能和 Vue 内置的属性、API 方法冲突，你可以使用例如 vm.$data._property 的方式访问这些属性。 怎么捕获Vue组件的错误信息？errorCaptured是组件内部钩子，当捕获一个来自子孙组件的错误时被调用，接收error、vm、info三个参数，return false后可以阻止错误继续向上抛出。 errorHandler为全局钩子，使用Vue.config.errorHandler配置，接收参数与errorCaptured一致，2.6后可捕捉v-on与promise链的错误，可用于统一错误处理与错误兜底。 Vue.observable你有了解过吗？说说看让一个对象可响应。可以作为最小化的跨组件状态存储器。 Vue项目中如何配置favicon？ 静态配置 &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt;, 其中&lt;%= BASE_URL %&gt;等同vue.config.js中publicPath的配置; 动态配置 12&lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; href=&quot;&quot;&gt;1 123456789import browserImg from &#x27;images/kong.png&#x27;;//为favicon的默认图片const imgurl =&#x27;后端传回来的favicon.ico的线上地址&#x27;let link = document.querySelector(&#x27;link[type=&quot;image/png&quot;]&#x27;);if (imgurl) &#123; link.setAttribute(&#x27;href&#x27;, imgurl);&#125; else &#123; link.setAttribute(&#x27;href&#x27;, browserImg);&#125;12345678 怎么修改Vue项目打包后生成文件路径？ 在Vue CLI2中修改config/index.js文件中的build.assetsPublicPath的值； 在Vue CLI3中配置publicPath的值。 怎么解决Vue项目打包后静态资源图片失效的问题？在项目中一般通过配置alias路径别名的方式解决,下面是Vue CLI3的配置。 123456789101112configureWebpack: &#123; resolve: &#123; extensions: [&#x27;.js&#x27;, &#x27;.vue&#x27;, &#x27;.json&#x27;], alias: &#123; &#x27;@&#x27;: resolve(&#x27;src&#x27;), &#x27;assets&#x27;: resolve(&#x27;src/assets&#x27;), &#x27;css&#x27;: resolve(&#x27;src/assets/css&#x27;), &#x27;images&#x27;: resolve(&#x27;src/assets/images&#x27;), &#125; &#125;,&#125;,1234567891011 怎么解决Vue中动态设置img的src不生效的问题？因为动态添加src被当做静态资源处理了，没有进行编译，所以要加上require。 12345678910111213&lt;template&gt; &lt;img class=&quot;logo&quot; :src=&quot;logo&quot; alt=&quot;公司logo&quot;&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; logo:require(&quot;assets/images/logo.png&quot;), &#125;; &#125;&#125;;&lt;/script&gt;123456789101112 在Vue项目中如何引入第三方库（比如jQuery）？有哪些方法可以做到？先在主入口页面 index.html 中用 script 标签引入&lt;script src=&quot;./static/jquery-1.12.4.js&quot;&gt;&lt;/script&gt;,如果你的项目中有用ESLint检测，会报&#39;$&#39; is not defined，要在文件中加上/* eslint-disable */ 先在主入口页面 index.html 中用 script 标签引入&lt;script src=&quot;./static/jquery-1.12.4.js&quot;&gt;&lt;/script&gt;,然后在webpack 中配置一个 externals，即可在项目中使用。 123456export default &#123; // ... externals: &#123; &#x27;jquery&#x27;: &#x27;jQuery&#x27; &#125;&#125; 先在webpack中配置alias，最后在main.js中用import $ from &#39;jquery&#39;，即可在项目中使用。 12345678910export default &#123; // ... resolve: &#123; extensions: [&#x27;.js&#x27;, &#x27;.vue&#x27;, &#x27;.json&#x27;], alias: &#123; &#x27;@&#x27;: resolve(&#x27;src&#x27;), &#x27;jquery&#x27;: resolve(&#x27;static/jquery-1.12.4.js&#x27;) &#125; &#125;&#125; 在webpack中新增一个plugins，即可在项目中使用 12345678910export default &#123; // ... plugins: [ new webpack.ProvidePlugin(&#123; $:&quot;jquery&quot;, jQuery:&quot;jquery&quot;, &quot;windows.jQuery&quot;:&quot;jquery&quot; &#125;) ]&#125; 说说你对SPA单页面的理解，它的优缺点分别是什么？是一种只需要将单个页面加载到服务器之中的web应用程序。当浏览器向服务器发出第一个请求时，服务器会返回一个index.html文件，它所需的js，css等会在显示时统一加载，部分页面按需加载。url地址变化时不会向服务器在请求页面，通过路由才实现页面切换。 优点： 良好的交互体验，用户不需要重新刷新页面，获取数据也是通过Ajax异步获取，页面显示流畅； 良好的前后端工作分离模式。 缺点： SEO难度较高，由于所有的内容都在一个页面中动态替换显示，所以在SEO上其有着天然的弱势。 首屏加载过慢（初次加载耗时多） SPA单页面的实现方式有哪些？ 在hash模式中，在window上监听hashchange事件（地址栏中hash变化触发）驱动界面变化； 在history模式中，在window上监听popstate事件（浏览器的前进或后退按钮的点击触发）驱动界面变化，监听a链接点击事件用history.pushState、history.replaceState方法驱动界面变化； 直接在界面用显示隐藏事件驱动界面变化。 说说你对Object.defineProperty的理解 Object.defineProperty(obj,prop,descriptor)方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 obj：要在其上定义属性的对象。 prop：要定义或修改的属性的名称。 descriptor：将被定义或修改的属性描述符。 descriptor属性描述符主要有两种形式：数据描述符和存取描述符。 描述符必须是这两种形式之一；不能同时是两者。 数据描述符和存取描述符共同拥有 configurable：特性表示对象的属性是否可以被删除，以及除value和writable特性外的其他特性是否可以被修改。默认为false。 enumerable：当该属性的enumerable为true时，该属性才可以在for…in循环和Object.keys()中被枚举。默认为false。 数据描述符 value：该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为undefined。 writable：当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为false。 存取描述符 get：一个给属性提供 getter的方法，如果没有getter则为undefined。当访问该属性时，该方法会被执行，方法执行时没有参数传入，但是会传入this对象（由于继承关系，这里的this并不一定是定义该属性的对象）。默认为undefined。 set：一个给属性提供 setter的方法，如果没有setter则为undefined。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。默认为undefined。 定义descriptor时，最好先把这些属性都定义清楚，防止被继承和继承时出错。 1234567891011121314151617181920function Archiver() &#123; var temperature = null; var archive = []; Object.defineProperty(this, &#x27;temperature&#x27;, &#123; get: function() &#123; console.log(&#x27;get!&#x27;); return temperature; &#125;, set: function(value) &#123; temperature = value; archive.push(&#123; val: temperature &#125;); &#125; &#125;); this.getArchive = function() &#123; return archive; &#125;;&#125;var arc = new Archiver();arc.temperature; // &#x27;get!&#x27;arc.temperature = 11;arc.temperature = 13;arc.getArchive(); // [&#123; val: 11 &#125;, &#123; val: 13 &#125;] 说说你对Proxy的理解官方定义：proxy对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。 通俗来说是在对目标对象的操作之前提供了拦截，对外界的操作进行过滤和修改某些操作的默认行为，可以不直接操作对象本身，而是通过操作对象的代理对象来间接来操作对象。 1let proxy = new Proxy(target, handler) target 是用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）; handler 一个对象，其属性是当执行一个操作时定义代理的行为的函数，也就是自定义的行为。 handle可以为&#123;&#125;，但是不能为null，否则会报错 Proxy 目前提供了 13 种可代理操作，比较常用的 handler.get(target,property,receiver)获取值拦截 handler.set(target,property,value,receiver)设置值拦截 handler.has(target,prop)in 操作符拦截 12345678910111213141516171819202122232425262728let obj = &#123; a : 1, b : 2&#125;let test = new Proxy(obj,&#123; get : function (target,property) &#123; return property in target ? target[property] : 0 &#125;, set : function (target,property,value) &#123; target[property] = 6; &#125;, has: function (target,prop)&#123; if(prop == &#x27;b&#x27;)&#123; target[prop] = 6; &#125; return prop in target; &#125;,&#125;)console.log(test.a); // 1console.log(test.c); // 0test.a = 3;console.log(test.a) // 6if(&#x27;b&#x27; in test)&#123; console.log(test) // Proxy &#123;a: 6, b: 6&#125;&#125; Object.defineProperty和Proxy的区别Object.defineProperty 不能监听到数组length属性的变化； 不能监听对象的添加； 只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。 Proxy 可以监听数组length属性的变化； 可以监听对象的添加； 可代理整个对象，不需要对对象进行遍历，极大提高性能； 多达13种的拦截远超Object.defineProperty只有get和set两种拦截。 Vue的模板语法用的是哪个web模板引擎的吗？说说你对这模板引擎的理解?采用的是Mustache的web模板引擎mustache.js 1234567891011&lt;script type=&quot;text/javascript&quot; src=&quot;./mustache.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var data = &#123; &quot;company&quot;: &quot;Apple&quot;, &#125; var tpl = &#x27;&lt;h1&gt;Hello &#123;&#123;company&#125;&#125;&lt;/h1&gt;&#x27;; var html = Mustache.render(tpl, data); console.log(html);&lt;/script&gt; 你认为Vue的核心是什么？Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统。 说说你对单向数据流和双向数据流的理解单向数据流是指数据只能从父级向子级传递数据，子级不能改变父级向子级传递的数据。 双向数据流是指数据从父级向子级传递数据，子级可以通过一些手段改变父级向子级传递的数据。 比如用v-model、.sync来实现双向数据流。 什么是虚拟DOM？虚拟DOM是将状态映射成视图的众多解决方案中的一种，其是通过状态生成一个虚拟节点树，然后使用虚拟节点树进行渲染生成真实DOM，在渲染之前，会使用新生成的虚拟节点树和上一次虚拟节点树进行对比，只渲染不同的部分。 Vue中如何实现一个虚拟DOM？说说你的思路首先要构建一个VNode的类，DOM元素上的所有属性在VNode类实例化出来的对象上都存在对应的属性。例如tag表示一个元素节点的名称，text表示一个文本节点的文本，chlidren表示子节点等。将VNode类实例化出来的对象进行分类，例如注释节点、文本节点、元素节点、组件节点、函数式节点、克隆节点。 然后通过编译将模板转成渲染函数render，执行渲染函数render，在其中创建不同类型的VNode类，最后整合就可以得到一个虚拟DOM（vnode）。 最后通过patch将vnode和oldVnode进行比较后，生成真实DOM。 Vue为什么要求组件模板只能有一个根元素？当前的virtualDOM差异和diff算法在很大程度上依赖于每个子组件总是只有一个根元素。 axios是什么？怎样使用它？怎么解决跨域的问题？axios 是一个基于 promise 的 HTTP 库，先封装在使用。 使用proxyTable配置解决跨域问题。 比如你要调用http://172.16.13.205:9011/getList这个接口 先在axios.create()配置baseURL增加标志 1234const service = axios.create(&#123; baseURL: &#x27;/api&#x27;,&#125;);service.get(getList, &#123;params:data&#125;); 然后在config/index.js文件中配置 1234567891011121314module.exports = &#123; devServe:&#123; proxyTable: &#123; &#x27;/api&#x27;: &#123; target: &#x27;http://172.16.13.205:9011&#x27;, // 设置你调用的接口域名和端口号 secure: false, changeOrigin: true,// 跨域 pathRewrite: &#123; &#x27;^/api&#x27;: &#x27;&#x27; // 去掉标志 &#125; &#125; &#125;, &#125;&#125; 配置后要重新npm run dev F12中看到请求是http://localhost:8080/api/getList，实际上请求是http://172.16.13.205:9011/getList。 如果想扩展某个现有的Vue组件时，怎么做呢？ 用mixins混入 用extends，比mixins先触发 用高阶组件HOC封装 vue-loader是什么？它有什么作用？vue-loader是一个webpack的loader，是一个模块转换器，用于把模块原内容按照需求转换成新内容。 它允许你以一种名为单文件组件 (SFCs)的格式撰写 Vue 组件。可以解析和转换 .vue 文件，提取出其中的逻辑代码 script、样式代码 style、以及 HTML 模版 template，再分别把它们交给对应的loader去处理。 你有使用过JSX吗？说说你对JSX的理解？JSX就是Javascript和XML结合的一种格式。React发明了JSX，利用HTML语法来创建虚拟DOM。当遇到&lt;，JSX就当HTML解析，遇到&#123;就当JavaScript解析。","categories":[{"name":"前端","slug":"前端","permalink":"https://wisiw.github.io.git/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"https://wisiw.github.io.git/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://wisiw.github.io.git/tags/Vue/"},{"name":"面试题","slug":"面试题","permalink":"https://wisiw.github.io.git/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"author":"不爽的麻雀"}],"categories":[{"name":"前端","slug":"前端","permalink":"https://wisiw.github.io.git/categories/%E5%89%8D%E7%AB%AF/"},{"name":"微服务","slug":"微服务","permalink":"https://wisiw.github.io.git/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"cli","slug":"cli","permalink":"https://wisiw.github.io.git/categories/cli/"},{"name":"react","slug":"react","permalink":"https://wisiw.github.io.git/categories/react/"},{"name":"React","slug":"React","permalink":"https://wisiw.github.io.git/categories/React/"},{"name":"前端架构","slug":"前端架构","permalink":"https://wisiw.github.io.git/categories/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/"},{"name":"后端","slug":"后端","permalink":"https://wisiw.github.io.git/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Angular","slug":"Angular","permalink":"https://wisiw.github.io.git/categories/Angular/"},{"name":"代码工具","slug":"代码工具","permalink":"https://wisiw.github.io.git/categories/%E4%BB%A3%E7%A0%81%E5%B7%A5%E5%85%B7/"},{"name":"axios","slug":"axios","permalink":"https://wisiw.github.io.git/categories/axios/"},{"name":"Vue","slug":"Vue","permalink":"https://wisiw.github.io.git/categories/Vue/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://wisiw.github.io.git/tags/Python/"},{"name":"openCV","slug":"openCV","permalink":"https://wisiw.github.io.git/tags/openCV/"},{"name":"姿势识别","slug":"姿势识别","permalink":"https://wisiw.github.io.git/tags/%E5%A7%BF%E5%8A%BF%E8%AF%86%E5%88%AB/"},{"name":"图像识别","slug":"图像识别","permalink":"https://wisiw.github.io.git/tags/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"},{"name":"手势识别","slug":"手势识别","permalink":"https://wisiw.github.io.git/tags/%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB/"},{"name":"业务梳理","slug":"业务梳理","permalink":"https://wisiw.github.io.git/tags/%E4%B8%9A%E5%8A%A1%E6%A2%B3%E7%90%86/"},{"name":"滚动吸附","slug":"滚动吸附","permalink":"https://wisiw.github.io.git/tags/%E6%BB%9A%E5%8A%A8%E5%90%B8%E9%99%84/"},{"name":"Node","slug":"Node","permalink":"https://wisiw.github.io.git/tags/Node/"},{"name":"模板生成器","slug":"模板生成器","permalink":"https://wisiw.github.io.git/tags/%E6%A8%A1%E6%9D%BF%E7%94%9F%E6%88%90%E5%99%A8/"},{"name":"CSS","slug":"CSS","permalink":"https://wisiw.github.io.git/tags/CSS/"},{"name":"CSS翻滚","slug":"CSS翻滚","permalink":"https://wisiw.github.io.git/tags/CSS%E7%BF%BB%E6%BB%9A/"},{"name":"Echarts","slug":"Echarts","permalink":"https://wisiw.github.io.git/tags/Echarts/"},{"name":"element-ui","slug":"element-ui","permalink":"https://wisiw.github.io.git/tags/element-ui/"},{"name":"npm","slug":"npm","permalink":"https://wisiw.github.io.git/tags/npm/"},{"name":"postcss","slug":"postcss","permalink":"https://wisiw.github.io.git/tags/postcss/"},{"name":"适配","slug":"适配","permalink":"https://wisiw.github.io.git/tags/%E9%80%82%E9%85%8D/"},{"name":"SystemJS","slug":"SystemJS","permalink":"https://wisiw.github.io.git/tags/SystemJS/"},{"name":"安装","slug":"安装","permalink":"https://wisiw.github.io.git/tags/%E5%AE%89%E8%A3%85/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://wisiw.github.io.git/tags/TypeScript/"},{"name":"使用","slug":"使用","permalink":"https://wisiw.github.io.git/tags/%E4%BD%BF%E7%94%A8/"},{"name":"网页截图","slug":"网页截图","permalink":"https://wisiw.github.io.git/tags/%E7%BD%91%E9%A1%B5%E6%88%AA%E5%9B%BE/"},{"name":"webrtc","slug":"webrtc","permalink":"https://wisiw.github.io.git/tags/webrtc/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://wisiw.github.io.git/tags/JavaScript/"},{"name":"模板引擎","slug":"模板引擎","permalink":"https://wisiw.github.io.git/tags/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"},{"name":"node","slug":"node","permalink":"https://wisiw.github.io.git/tags/node/"},{"name":"electron","slug":"electron","permalink":"https://wisiw.github.io.git/tags/electron/"},{"name":"使用教程","slug":"使用教程","permalink":"https://wisiw.github.io.git/tags/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"name":"前端工程化","slug":"前端工程化","permalink":"https://wisiw.github.io.git/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"utils","slug":"utils","permalink":"https://wisiw.github.io.git/tags/utils/"},{"name":"重载","slug":"重载","permalink":"https://wisiw.github.io.git/tags/%E9%87%8D%E8%BD%BD/"},{"name":"神话Myth","slug":"神话Myth","permalink":"https://wisiw.github.io.git/tags/%E7%A5%9E%E8%AF%9DMyth/"},{"name":"神话概要","slug":"神话概要","permalink":"https://wisiw.github.io.git/tags/%E7%A5%9E%E8%AF%9D%E6%A6%82%E8%A6%81/"},{"name":"古生物","slug":"古生物","permalink":"https://wisiw.github.io.git/tags/%E5%8F%A4%E7%94%9F%E7%89%A9/"},{"name":"恐龙","slug":"恐龙","permalink":"https://wisiw.github.io.git/tags/%E6%81%90%E9%BE%99/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://wisiw.github.io.git/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"Web Componetns","slug":"Web-Componetns","permalink":"https://wisiw.github.io.git/tags/Web-Componetns/"},{"name":"拖拽","slug":"拖拽","permalink":"https://wisiw.github.io.git/tags/%E6%8B%96%E6%8B%BD/"},{"name":"自定义","slug":"自定义","permalink":"https://wisiw.github.io.git/tags/%E8%87%AA%E5%AE%9A%E4%B9%89/"},{"name":"图片压缩","slug":"图片压缩","permalink":"https://wisiw.github.io.git/tags/%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/"},{"name":"水印","slug":"水印","permalink":"https://wisiw.github.io.git/tags/%E6%B0%B4%E5%8D%B0/"},{"name":"JAVA","slug":"JAVA","permalink":"https://wisiw.github.io.git/tags/JAVA/"},{"name":"Spring","slug":"Spring","permalink":"https://wisiw.github.io.git/tags/Spring/"},{"name":"权限验证","slug":"权限验证","permalink":"https://wisiw.github.io.git/tags/%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81/"},{"name":"文字滚动","slug":"文字滚动","permalink":"https://wisiw.github.io.git/tags/%E6%96%87%E5%AD%97%E6%BB%9A%E5%8A%A8/"},{"name":"H5","slug":"H5","permalink":"https://wisiw.github.io.git/tags/H5/"},{"name":"single","slug":"single","permalink":"https://wisiw.github.io.git/tags/single/"},{"name":"响应式","slug":"响应式","permalink":"https://wisiw.github.io.git/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"},{"name":"transform","slug":"transform","permalink":"https://wisiw.github.io.git/tags/transform/"},{"name":"爬坑","slug":"爬坑","permalink":"https://wisiw.github.io.git/tags/%E7%88%AC%E5%9D%91/"},{"name":"小程序","slug":"小程序","permalink":"https://wisiw.github.io.git/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"混入","slug":"混入","permalink":"https://wisiw.github.io.git/tags/%E6%B7%B7%E5%85%A5/"},{"name":"mixin","slug":"mixin","permalink":"https://wisiw.github.io.git/tags/mixin/"},{"name":"canvas","slug":"canvas","permalink":"https://wisiw.github.io.git/tags/canvas/"},{"name":"绘图","slug":"绘图","permalink":"https://wisiw.github.io.git/tags/%E7%BB%98%E5%9B%BE/"},{"name":"签名","slug":"签名","permalink":"https://wisiw.github.io.git/tags/%E7%AD%BE%E5%90%8D/"},{"name":"echarts","slug":"echarts","permalink":"https://wisiw.github.io.git/tags/echarts/"},{"name":"踩坑","slug":"踩坑","permalink":"https://wisiw.github.io.git/tags/%E8%B8%A9%E5%9D%91/"},{"name":"git","slug":"git","permalink":"https://wisiw.github.io.git/tags/git/"},{"name":"分支管理","slug":"分支管理","permalink":"https://wisiw.github.io.git/tags/%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/"},{"name":"webpack","slug":"webpack","permalink":"https://wisiw.github.io.git/tags/webpack/"},{"name":"NodeJs","slug":"NodeJs","permalink":"https://wisiw.github.io.git/tags/NodeJs/"},{"name":"Vue","slug":"Vue","permalink":"https://wisiw.github.io.git/tags/Vue/"},{"name":"代码片段","slug":"代码片段","permalink":"https://wisiw.github.io.git/tags/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"},{"name":"权限管理","slug":"权限管理","permalink":"https://wisiw.github.io.git/tags/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"},{"name":"CommonJS","slug":"CommonJS","permalink":"https://wisiw.github.io.git/tags/CommonJS/"},{"name":"ES6","slug":"ES6","permalink":"https://wisiw.github.io.git/tags/ES6/"},{"name":"module","slug":"module","permalink":"https://wisiw.github.io.git/tags/module/"},{"name":"算法","slug":"算法","permalink":"https://wisiw.github.io.git/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据压缩","slug":"数据压缩","permalink":"https://wisiw.github.io.git/tags/%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/"},{"name":"二叉树","slug":"二叉树","permalink":"https://wisiw.github.io.git/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"哈希表","slug":"哈希表","permalink":"https://wisiw.github.io.git/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"斐波那契查找","slug":"斐波那契查找","permalink":"https://wisiw.github.io.git/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE/"},{"name":"插值查找","slug":"插值查找","permalink":"https://wisiw.github.io.git/tags/%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE/"},{"name":"二分查找","slug":"二分查找","permalink":"https://wisiw.github.io.git/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"算法 -时间复杂度计算","slug":"算法-时间复杂度计算","permalink":"https://wisiw.github.io.git/tags/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97/"},{"name":"排序","slug":"排序","permalink":"https://wisiw.github.io.git/tags/%E6%8E%92%E5%BA%8F/"},{"name":"八皇后问题","slug":"八皇后问题","permalink":"https://wisiw.github.io.git/tags/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"},{"name":"迷宫回溯","slug":"迷宫回溯","permalink":"https://wisiw.github.io.git/tags/%E8%BF%B7%E5%AE%AB%E5%9B%9E%E6%BA%AF/"},{"name":"逆波兰式","slug":"逆波兰式","permalink":"https://wisiw.github.io.git/tags/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/"},{"name":"前缀、中缀、后缀表达式","slug":"前缀、中缀、后缀表达式","permalink":"https://wisiw.github.io.git/tags/%E5%89%8D%E7%BC%80%E3%80%81%E4%B8%AD%E7%BC%80%E3%80%81%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"栈","slug":"栈","permalink":"https://wisiw.github.io.git/tags/%E6%A0%88/"},{"name":"约瑟夫问题","slug":"约瑟夫问题","permalink":"https://wisiw.github.io.git/tags/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/"},{"name":"链表","slug":"链表","permalink":"https://wisiw.github.io.git/tags/%E9%93%BE%E8%A1%A8/"},{"name":"队列","slug":"队列","permalink":"https://wisiw.github.io.git/tags/%E9%98%9F%E5%88%97/"},{"name":"稀疏数组","slug":"稀疏数组","permalink":"https://wisiw.github.io.git/tags/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/"},{"name":"面试题","slug":"面试题","permalink":"https://wisiw.github.io.git/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"Vue-cli","slug":"Vue-cli","permalink":"https://wisiw.github.io.git/tags/Vue-cli/"},{"name":"组件化","slug":"组件化","permalink":"https://wisiw.github.io.git/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"},{"name":"断点续传","slug":"断点续传","permalink":"https://wisiw.github.io.git/tags/%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0/"},{"name":"Markdown","slug":"Markdown","permalink":"https://wisiw.github.io.git/tags/Markdown/"},{"name":"局部样式","slug":"局部样式","permalink":"https://wisiw.github.io.git/tags/%E5%B1%80%E9%83%A8%E6%A0%B7%E5%BC%8F/"},{"name":"React","slug":"React","permalink":"https://wisiw.github.io.git/tags/React/"},{"name":"vue-loader","slug":"vue-loader","permalink":"https://wisiw.github.io.git/tags/vue-loader/"},{"name":"Webpack","slug":"Webpack","permalink":"https://wisiw.github.io.git/tags/Webpack/"},{"name":"模块打包","slug":"模块打包","permalink":"https://wisiw.github.io.git/tags/%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85/"},{"name":"功能代码","slug":"功能代码","permalink":"https://wisiw.github.io.git/tags/%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"name":"Uni","slug":"Uni","permalink":"https://wisiw.github.io.git/tags/Uni/"},{"name":"fileUpload","slug":"fileUpload","permalink":"https://wisiw.github.io.git/tags/fileUpload/"},{"name":"fileDownload","slug":"fileDownload","permalink":"https://wisiw.github.io.git/tags/fileDownload/"},{"name":"route","slug":"route","permalink":"https://wisiw.github.io.git/tags/route/"},{"name":"基础","slug":"基础","permalink":"https://wisiw.github.io.git/tags/%E5%9F%BA%E7%A1%80/"},{"name":"组件","slug":"组件","permalink":"https://wisiw.github.io.git/tags/%E7%BB%84%E4%BB%B6/"},{"name":"前端组件化","slug":"前端组件化","permalink":"https://wisiw.github.io.git/tags/%E5%89%8D%E7%AB%AF%E7%BB%84%E4%BB%B6%E5%8C%96/"},{"name":"app","slug":"app","permalink":"https://wisiw.github.io.git/tags/app/"},{"name":"源码","slug":"源码","permalink":"https://wisiw.github.io.git/tags/%E6%BA%90%E7%A0%81/"},{"name":"backbone.js","slug":"backbone-js","permalink":"https://wisiw.github.io.git/tags/backbone-js/"},{"name":"架构","slug":"架构","permalink":"https://wisiw.github.io.git/tags/%E6%9E%B6%E6%9E%84/"},{"name":"SysemJS","slug":"SysemJS","permalink":"https://wisiw.github.io.git/tags/SysemJS/"},{"name":"原理","slug":"原理","permalink":"https://wisiw.github.io.git/tags/%E5%8E%9F%E7%90%86/"},{"name":"全局弹窗","slug":"全局弹窗","permalink":"https://wisiw.github.io.git/tags/%E5%85%A8%E5%B1%80%E5%BC%B9%E7%AA%97/"},{"name":"数据、算法","slug":"数据、算法","permalink":"https://wisiw.github.io.git/tags/%E6%95%B0%E6%8D%AE%E3%80%81%E7%AE%97%E6%B3%95/"},{"name":"数组实现包","slug":"数组实现包","permalink":"https://wisiw.github.io.git/tags/%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%8C%85/"},{"name":"Java","slug":"Java","permalink":"https://wisiw.github.io.git/tags/Java/"},{"name":"数据结构","slug":"数据结构","permalink":"https://wisiw.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"技巧","slug":"技巧","permalink":"https://wisiw.github.io.git/tags/%E6%8A%80%E5%B7%A7/"},{"name":"数据库","slug":"数据库","permalink":"https://wisiw.github.io.git/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MyBatis-Plus","slug":"MyBatis-Plus","permalink":"https://wisiw.github.io.git/tags/MyBatis-Plus/"},{"name":"系统架构设计师考试","slug":"系统架构设计师考试","permalink":"https://wisiw.github.io.git/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%80%83%E8%AF%95/"},{"name":"第一章","slug":"第一章","permalink":"https://wisiw.github.io.git/tags/%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"name":"vuex","slug":"vuex","permalink":"https://wisiw.github.io.git/tags/vuex/"},{"name":"VueRouter","slug":"VueRouter","permalink":"https://wisiw.github.io.git/tags/VueRouter/"},{"name":"编程题","slug":"编程题","permalink":"https://wisiw.github.io.git/tags/%E7%BC%96%E7%A8%8B%E9%A2%98/"},{"name":"前端","slug":"前端","permalink":"https://wisiw.github.io.git/tags/%E5%89%8D%E7%AB%AF/"},{"name":"browser","slug":"browser","permalink":"https://wisiw.github.io.git/tags/browser/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://wisiw.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Flux","slug":"Flux","permalink":"https://wisiw.github.io.git/tags/Flux/"},{"name":"mybatis","slug":"mybatis","permalink":"https://wisiw.github.io.git/tags/mybatis/"},{"name":"工具","slug":"工具","permalink":"https://wisiw.github.io.git/tags/%E5%B7%A5%E5%85%B7/"},{"name":"微服务","slug":"微服务","permalink":"https://wisiw.github.io.git/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"教程","slug":"教程","permalink":"https://wisiw.github.io.git/tags/%E6%95%99%E7%A8%8B/"},{"name":"手写","slug":"手写","permalink":"https://wisiw.github.io.git/tags/%E6%89%8B%E5%86%99/"},{"name":"源码解析","slug":"源码解析","permalink":"https://wisiw.github.io.git/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"name":"AST语法树","slug":"AST语法树","permalink":"https://wisiw.github.io.git/tags/AST%E8%AF%AD%E6%B3%95%E6%A0%91/"},{"name":"模板解析","slug":"模板解析","permalink":"https://wisiw.github.io.git/tags/%E6%A8%A1%E6%9D%BF%E8%A7%A3%E6%9E%90/"},{"name":"cli","slug":"cli","permalink":"https://wisiw.github.io.git/tags/cli/"},{"name":"react","slug":"react","permalink":"https://wisiw.github.io.git/tags/react/"},{"name":"《深入React技术栈》","slug":"《深入React技术栈》","permalink":"https://wisiw.github.io.git/tags/%E3%80%8A%E6%B7%B1%E5%85%A5React%E6%8A%80%E6%9C%AF%E6%A0%88%E3%80%8B/"},{"name":"读书笔记 - React - 《深入React技术栈》","slug":"读书笔记-React-《深入React技术栈》","permalink":"https://wisiw.github.io.git/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-React-%E3%80%8A%E6%B7%B1%E5%85%A5React%E6%8A%80%E6%9C%AF%E6%A0%88%E3%80%8B/"},{"name":"微前端","slug":"微前端","permalink":"https://wisiw.github.io.git/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"},{"name":"前端 - 架构","slug":"前端-架构","permalink":"https://wisiw.github.io.git/tags/%E5%89%8D%E7%AB%AF-%E6%9E%B6%E6%9E%84/"},{"name":"Excel","slug":"Excel","permalink":"https://wisiw.github.io.git/tags/Excel/"},{"name":"前端架构","slug":"前端架构","permalink":"https://wisiw.github.io.git/tags/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/"},{"name":"Docker","slug":"Docker","permalink":"https://wisiw.github.io.git/tags/Docker/"},{"name":"后端","slug":"后端","permalink":"https://wisiw.github.io.git/tags/%E5%90%8E%E7%AB%AF/"},{"name":"Angular","slug":"Angular","permalink":"https://wisiw.github.io.git/tags/Angular/"},{"name":"linux","slug":"linux","permalink":"https://wisiw.github.io.git/tags/linux/"},{"name":"集群","slug":"集群","permalink":"https://wisiw.github.io.git/tags/%E9%9B%86%E7%BE%A4/"},{"name":"JavaScript - 设计模式","slug":"JavaScript-设计模式","permalink":"https://wisiw.github.io.git/tags/JavaScript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Nginx","slug":"Nginx","permalink":"https://wisiw.github.io.git/tags/Nginx/"},{"name":"代码工具","slug":"代码工具","permalink":"https://wisiw.github.io.git/tags/%E4%BB%A3%E7%A0%81%E5%B7%A5%E5%85%B7/"},{"name":"Promise","slug":"Promise","permalink":"https://wisiw.github.io.git/tags/Promise/"},{"name":"map","slug":"map","permalink":"https://wisiw.github.io.git/tags/map/"},{"name":"生命周期","slug":"生命周期","permalink":"https://wisiw.github.io.git/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"name":"axios","slug":"axios","permalink":"https://wisiw.github.io.git/tags/axios/"},{"name":"数据响应式","slug":"数据响应式","permalink":"https://wisiw.github.io.git/tags/%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/"},{"name":"虚拟DOM与diff算法","slug":"虚拟DOM与diff算法","permalink":"https://wisiw.github.io.git/tags/%E8%99%9A%E6%8B%9FDOM%E4%B8%8Ediff%E7%AE%97%E6%B3%95/"},{"name":"瀑布流","slug":"瀑布流","permalink":"https://wisiw.github.io.git/tags/%E7%80%91%E5%B8%83%E6%B5%81/"}]}