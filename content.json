{"meta":{"title":"韦绍炜的博客","subtitle":"","description":"","author":"wsw","url":"https://WiSiW.github.io.git","root":"/"},"pages":[],"posts":[{"title":"【route】导航基础","slug":"【Route】导航基础","date":"2021-09-23T01:58:28.000Z","updated":"2021-09-23T01:59:23.778Z","comments":true,"path":"2021/09/23/【Route】导航基础/","link":"","permalink":"https://wisiw.github.io.git/2021/09/23/%E3%80%90Route%E3%80%91%E5%AF%BC%E8%88%AA%E5%9F%BA%E7%A1%80/","excerpt":"","text":"URI与URL","categories":[],"tags":[{"name":"route","slug":"route","permalink":"https://wisiw.github.io.git/tags/route/"},{"name":"基础","slug":"基础","permalink":"https://wisiw.github.io.git/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"【代码片段】自动化导入组件模块","slug":"【代码片段】根据组件目录全局注册组件","date":"2021-09-22T05:55:54.000Z","updated":"2021-09-22T07:33:46.913Z","comments":true,"path":"2021/09/22/【代码片段】根据组件目录全局注册组件/","link":"","permalink":"https://wisiw.github.io.git/2021/09/22/%E3%80%90%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E3%80%91%E6%A0%B9%E6%8D%AE%E7%BB%84%E4%BB%B6%E7%9B%AE%E5%BD%95%E5%85%A8%E5%B1%80%E6%B3%A8%E5%86%8C%E7%BB%84%E4%BB%B6/","excerpt":"","text":"使用require.context代替大量使用import1.require.context()123456/** * dir:要查找的文件路径 * useSubdirectories:是否查找子目录 * regExp:要匹配文件的正则 */require.context(dir, useSubdirectories, regExp) 2.使用 目录结构src ├── components | ├─ A.js | ├─ B.js | └─ C.js └── index.js 1234567// index.jsconst ctx = require.context(&#x27;./components/&#x27;, true, /\\.js$/)console.log(ctx.id) // &#x27;./src/components&#x27;// 返回的是模块内部变量map的keys，通过模块提供的keys()方法访问console.log(ctx.keys()) // [&#x27;./A.js&#x27;, &#x27;./B.js&#x27;, &#x27;./C.js&#x27; ]// 返回相对于整个工程的相对路径console.log(ctx.resolve(&#x27;./A.js&#x27;)) // &#x27;./src/components/A.js&#x27; 12345678910111213141516171819202122232425var map = &#123; &quot;./A.js&quot;: &quot;./src/components/A.js&quot;, &quot;./B.js&quot;: &quot;./src/components/B.js&quot;, &quot;./C.js&quot;: &quot;./src/components/C.js&quot;&#125;;function webpackContext(req) &#123; var id = webpackContextResolve(req); return __webpack_require__(id);&#125;function webpackContextResolve(req) &#123; var id = map[req]; if(!(id + 1)) &#123; // check for number or string var e = new Error(&quot;Cannot find module &#x27;&quot; + req + &quot;&#x27;&quot;); e.code = &#x27;MODULE_NOT_FOUND&#x27;; throw e; &#125; return id;&#125;webpackContext.keys = function webpackContextKeys() &#123; return Object.keys(map);&#125;;webpackContext.resolve = webpackContextResolve;webpackContext.id = &quot;./src/components sync recursive \\\\.js$&quot;;module.exports = webpackContext; 2.实际使用1234567891011121314// ./src/components/index.js// 查找当前目录下所有的index.vueconst ctx = require.context(&#x27;./&#x27;, true, /index\\.vue$/)// install() 被Vue.use()调用export default &#123; install: (Vue) =&gt; &#123; ctx.keys().forEach(i =&gt; &#123; const component = ctx(i).default Vue.component(component.name, component) &#125;) &#125;&#125; 123456// ./src/main.jsimport Vue from &#x27;vue&#x27;import Components from &#x27;@/components/index.js&#x27;// 全局注册公用组件Vue.use(Components)","categories":[],"tags":[{"name":"代码片段","slug":"代码片段","permalink":"https://wisiw.github.io.git/tags/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"},{"name":"组件","slug":"组件","permalink":"https://wisiw.github.io.git/tags/%E7%BB%84%E4%BB%B6/"},{"name":"前端组件化","slug":"前端组件化","permalink":"https://wisiw.github.io.git/tags/%E5%89%8D%E7%AB%AF%E7%BB%84%E4%BB%B6%E5%8C%96/"}]},{"title":"【Node】module.exports与exports的区别","slug":"【Node】module-exports与exports的区别","date":"2021-09-14T07:03:30.000Z","updated":"2021-09-23T05:57:04.390Z","comments":true,"path":"2021/09/14/【Node】module-exports与exports的区别/","link":"","permalink":"https://wisiw.github.io.git/2021/09/14/%E3%80%90Node%E3%80%91module-exports%E4%B8%8Eexports%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://wisiw.github.io.git/tags/node/"}]},{"title":"app相关代码","slug":"app相关代码","date":"2021-09-13T03:14:23.000Z","updated":"2021-09-13T03:17:34.994Z","comments":true,"path":"2021/09/13/app相关代码/","link":"","permalink":"https://wisiw.github.io.git/2021/09/13/app%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/","excerpt":"","text":"跳转到应用商店: 1(https)|(itms-apps):&#x2F;&#x2F;itunes.apple.com&#x2F;app&#x2F;id&#123;appID&#125; 跳转到撰写评价： 1(https)|(itms-apps):&#x2F;&#x2F;itunes.apple.com&#x2F;app&#x2F;id&#123;appID&#125;?action&#x3D;write-review 跳转到查看评价： 1(https)|(itms-apps):&#x2F;&#x2F;itunes.apple.com&#x2F;app&#x2F;viewContentsUserReviews?id&#x3D;&#123;appID&#125; 示例： 1window.location.href = &#x27;itms-apps://itunes.apple.com/app/id414478124?action=write-review&#x27;","categories":[],"tags":[{"name":"app","slug":"app","permalink":"https://wisiw.github.io.git/tags/app/"}]},{"title":"【源码解析】backbone.js","slug":"【源码解析】backbone.js","date":"2021-09-10T06:55:28.000Z","updated":"2021-09-10T07:09:40.692Z","comments":true,"path":"2021/09/10/【源码解析】backbone.js/","link":"","permalink":"https://wisiw.github.io.git/2021/09/10/%E3%80%90%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91backbone.js/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221122212231224122512261227122812291230123112321233123412351236123712381239124012411242124312441245124612471248124912501251125212531254125512561257125812591260126112621263126412651266126712681269127012711272127312741275127612771278127912801281128212831284128512861287128812891290129112921293129412951296129712981299130013011302130313041305130613071308130913101311131213131314131513161317131813191320132113221323132413251326132713281329133013311332133313341335133613371338133913401341134213431344134513461347134813491350135113521353135413551356135713581359136013611362136313641365136613671368136913701371137213731374137513761377137813791380138113821383138413851386138713881389139013911392139313941395139613971398139914001401140214031404140514061407140814091410141114121413141414151416141714181419142014211422142314241425142614271428142914301431143214331434143514361437143814391440144114421443144414451446144714481449145014511452145314541455145614571458145914601461146214631464146514661467146814691470147114721473147414751476147714781479148014811482148314841485148614871488148914901491149214931494149514961497149814991500150115021503150415051506150715081509151015111512151315141515151615171518151915201521152215231524152515261527152815291530153115321533153415351536153715381539154015411542154315441545154615471548154915501551155215531554155515561557155815591560156115621563156415651566156715681569157015711572157315741575157615771578157915801581158215831584158515861587158815891590159115921593159415951596159715981599160016011602160316041605160616071608160916101611161216131614161516161617161816191620162116221623162416251626162716281629163016311632163316341635163616371638163916401641164216431644164516461647164816491650165116521653165416551656165716581659166016611662166316641665166616671668166916701671167216731674167516761677167816791680168116821683168416851686168716881689169016911692169316941695169616971698169917001701170217031704170517061707170817091710171117121713171417151716171717181719172017211722172317241725172617271728172917301731173217331734173517361737173817391740174117421743174417451746174717481749175017511752175317541755175617571758175917601761176217631764176517661767176817691770177117721773177417751776177717781779178017811782178317841785178617871788178917901791179217931794179517961797179817991800180118021803180418051806180718081809181018111812181318141815181618171818181918201821182218231824182518261827182818291830183118321833183418351836183718381839184018411842184318441845184618471848184918501851185218531854185518561857185818591860186118621863186418651866186718681869187018711872187318741875187618771878187918801881188218831884188518861887188818891890189118921893189418951896189718981899190019011902190319041905190619071908190919101911191219131914191519161917191819191920192119221923192419251926192719281929193019311932193319341935193619371938193919401941194219431944194519461947194819491950195119521953195419551956195719581959196019611962196319641965196619671968196919701971197219731974197519761977197819791980198119821983198419851986198719881989199019911992199319941995199619971998199920002001200220032004200520062007200820092010201120122013201420152016201720182019202020212022202320242025202620272028202920302031203220332034203520362037203820392040204120422043204420452046204720482049205020512052205320542055205620572058205920602061206220632064206520662067206820692070207120722073207420752076207720782079208020812082208320842085208620872088208920902091209220932094209520962097// Backbone.js 1.4.0// (c) 2010-2019 Jeremy Ashkenas and DocumentCloud// Backbone may be freely distributed under the MIT license.// For all details and documentation:// http://backbonejs.org(function(factory) &#123; // Establish the root object, `window` (`self`) in the browser, or `global` on the server. // We use `self` instead of `window` for `WebWorker` support. var root = typeof self == &#x27;object&#x27; &amp;&amp; self.self === self &amp;&amp; self || typeof global == &#x27;object&#x27; &amp;&amp; global.global === global &amp;&amp; global; // Set up Backbone appropriately for the environment. Start with AMD. if (typeof define === &#x27;function&#x27; &amp;&amp; define.amd) &#123; define([&#x27;underscore&#x27;, &#x27;jquery&#x27;, &#x27;exports&#x27;], function(_, $, exports) &#123; // Export global even in AMD case in case this script is loaded with // others that may still expect a global Backbone. root.Backbone = factory(root, exports, _, $); &#125;); // Next for Node.js or CommonJS. jQuery may not be needed as a module. &#125; else if (typeof exports !== &#x27;undefined&#x27;) &#123; var _ = require(&#x27;underscore&#x27;), $; try &#123; $ = require(&#x27;jquery&#x27;); &#125; catch (e) &#123;&#125; factory(root, exports, _, $); // Finally, as a browser global. &#125; else &#123; root.Backbone = factory(root, &#123;&#125;, root._, root.jQuery || root.Zepto || root.ender || root.$); &#125;&#125;)(function(root, Backbone, _, $) &#123; // Initial Setup // ------------- // Save the previous value of the `Backbone` variable, so that it can be // restored later on, if `noConflict` is used. var previousBackbone = root.Backbone; // Create a local reference to a common array method we&#x27;ll want to use later. var slice = Array.prototype.slice; // Current version of the library. Keep in sync with `package.json`. Backbone.VERSION = &#x27;1.4.0&#x27;; // For Backbone&#x27;s purposes, jQuery, Zepto, Ender, or My Library (kidding) owns // the `$` variable. Backbone.$ = $; // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable // to its previous owner. Returns a reference to this Backbone object. Backbone.noConflict = function() &#123; root.Backbone = previousBackbone; return this; &#125;; // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option // will fake `&quot;PATCH&quot;`, `&quot;PUT&quot;` and `&quot;DELETE&quot;` requests via the `_method` parameter and // set a `X-Http-Method-Override` header. Backbone.emulateHTTP = false; // Turn on `emulateJSON` to support legacy servers that can&#x27;t deal with direct // `application/json` requests ... this will encode the body as // `application/x-www-form-urlencoded` instead and will send the model in a // form param named `model`. Backbone.emulateJSON = false; // Backbone.Events // --------------- // A module that can be mixed in to *any object* in order to provide it with // a custom event channel. You may bind a callback to an event with `on` or // remove with `off`; `trigger`-ing an event fires all callbacks in // succession. // // var object = &#123;&#125;; // _.extend(object, Backbone.Events); // object.on(&#x27;expand&#x27;, function()&#123; alert(&#x27;expanded&#x27;); &#125;); // object.trigger(&#x27;expand&#x27;); // var Events = Backbone.Events = &#123;&#125;; // Regular expression used to split event strings. var eventSplitter = /\\s+/; // A private global variable to share between listeners and listenees. var _listening; // Iterates over the standard `event, callback` (as well as the fancy multiple // space-separated events `&quot;change blur&quot;, callback` and jQuery-style event // maps `&#123;event: callback&#125;`). var eventsApi = function(iteratee, events, name, callback, opts) &#123; var i = 0, names; if (name &amp;&amp; typeof name === &#x27;object&#x27;) &#123; // Handle event maps. if (callback !== void 0 &amp;&amp; &#x27;context&#x27; in opts &amp;&amp; opts.context === void 0) opts.context = callback; for (names = _.keys(name); i &lt; names.length ; i++) &#123; events = eventsApi(iteratee, events, names[i], name[names[i]], opts); &#125; &#125; else if (name &amp;&amp; eventSplitter.test(name)) &#123; // Handle space-separated event names by delegating them individually. for (names = name.split(eventSplitter); i &lt; names.length; i++) &#123; events = iteratee(events, names[i], callback, opts); &#125; &#125; else &#123; // Finally, standard events. events = iteratee(events, name, callback, opts); &#125; return events; &#125;; // Bind an event to a `callback` function. Passing `&quot;all&quot;` will bind // the callback to all events fired. Events.on = function(name, callback, context) &#123; this._events = eventsApi(onApi, this._events || &#123;&#125;, name, callback, &#123; context: context, ctx: this, listening: _listening &#125;); if (_listening) &#123; var listeners = this._listeners || (this._listeners = &#123;&#125;); listeners[_listening.id] = _listening; // Allow the listening to use a counter, instead of tracking // callbacks for library interop _listening.interop = false; &#125; return this; &#125;; // Inversion-of-control versions of `on`. Tell *this* object to listen to // an event in another object... keeping track of what it&#x27;s listening to // for easier unbinding later. Events.listenTo = function(obj, name, callback) &#123; if (!obj) return this; var id = obj._listenId || (obj._listenId = _.uniqueId(&#x27;l&#x27;)); var listeningTo = this._listeningTo || (this._listeningTo = &#123;&#125;); var listening = _listening = listeningTo[id]; // This object is not listening to any other events on `obj` yet. // Setup the necessary references to track the listening callbacks. if (!listening) &#123; this._listenId || (this._listenId = _.uniqueId(&#x27;l&#x27;)); listening = _listening = listeningTo[id] = new Listening(this, obj); &#125; // Bind callbacks on obj. var error = tryCatchOn(obj, name, callback, this); _listening = void 0; if (error) throw error; // If the target obj is not Backbone.Events, track events manually. if (listening.interop) listening.on(name, callback); return this; &#125;; // The reducing API that adds a callback to the `events` object. var onApi = function(events, name, callback, options) &#123; if (callback) &#123; var handlers = events[name] || (events[name] = []); var context = options.context, ctx = options.ctx, listening = options.listening; if (listening) listening.count++; handlers.push(&#123;callback: callback, context: context, ctx: context || ctx, listening: listening&#125;); &#125; return events; &#125;; // An try-catch guarded #on function, to prevent poisoning the global // `_listening` variable. var tryCatchOn = function(obj, name, callback, context) &#123; try &#123; obj.on(name, callback, context); &#125; catch (e) &#123; return e; &#125; &#125;; // Remove one or many callbacks. If `context` is null, removes all // callbacks with that function. If `callback` is null, removes all // callbacks for the event. If `name` is null, removes all bound // callbacks for all events. Events.off = function(name, callback, context) &#123; if (!this._events) return this; this._events = eventsApi(offApi, this._events, name, callback, &#123; context: context, listeners: this._listeners &#125;); return this; &#125;; // Tell this object to stop listening to either specific events ... or // to every object it&#x27;s currently listening to. Events.stopListening = function(obj, name, callback) &#123; var listeningTo = this._listeningTo; if (!listeningTo) return this; var ids = obj ? [obj._listenId] : _.keys(listeningTo); for (var i = 0; i &lt; ids.length; i++) &#123; var listening = listeningTo[ids[i]]; // If listening doesn&#x27;t exist, this object is not currently // listening to obj. Break out early. if (!listening) break; listening.obj.off(name, callback, this); if (listening.interop) listening.off(name, callback); &#125; if (_.isEmpty(listeningTo)) this._listeningTo = void 0; return this; &#125;; // The reducing API that removes a callback from the `events` object. var offApi = function(events, name, callback, options) &#123; if (!events) return; var context = options.context, listeners = options.listeners; var i = 0, names; // Delete all event listeners and &quot;drop&quot; events. if (!name &amp;&amp; !context &amp;&amp; !callback) &#123; for (names = _.keys(listeners); i &lt; names.length; i++) &#123; listeners[names[i]].cleanup(); &#125; return; &#125; names = name ? [name] : _.keys(events); for (; i &lt; names.length; i++) &#123; name = names[i]; var handlers = events[name]; // Bail out if there are no events stored. if (!handlers) break; // Find any remaining events. var remaining = []; for (var j = 0; j &lt; handlers.length; j++) &#123; var handler = handlers[j]; if ( callback &amp;&amp; callback !== handler.callback &amp;&amp; callback !== handler.callback._callback || context &amp;&amp; context !== handler.context ) &#123; remaining.push(handler); &#125; else &#123; var listening = handler.listening; if (listening) listening.off(name, callback); &#125; &#125; // Replace events if there are any remaining. Otherwise, clean up. if (remaining.length) &#123; events[name] = remaining; &#125; else &#123; delete events[name]; &#125; &#125; return events; &#125;; // Bind an event to only be triggered a single time. After the first time // the callback is invoked, its listener will be removed. If multiple events // are passed in using the space-separated syntax, the handler will fire // once for each event, not once for a combination of all events. Events.once = function(name, callback, context) &#123; // Map the event into a `&#123;event: once&#125;` object. var events = eventsApi(onceMap, &#123;&#125;, name, callback, this.off.bind(this)); if (typeof name === &#x27;string&#x27; &amp;&amp; context == null) callback = void 0; return this.on(events, callback, context); &#125;; // Inversion-of-control versions of `once`. Events.listenToOnce = function(obj, name, callback) &#123; // Map the event into a `&#123;event: once&#125;` object. var events = eventsApi(onceMap, &#123;&#125;, name, callback, this.stopListening.bind(this, obj)); return this.listenTo(obj, events); &#125;; // Reduces the event callbacks into a map of `&#123;event: onceWrapper&#125;`. // `offer` unbinds the `onceWrapper` after it has been called. var onceMap = function(map, name, callback, offer) &#123; if (callback) &#123; var once = map[name] = _.once(function() &#123; offer(name, once); callback.apply(this, arguments); &#125;); once._callback = callback; &#125; return map; &#125;; // Trigger one or many events, firing all bound callbacks. Callbacks are // passed the same arguments as `trigger` is, apart from the event name // (unless you&#x27;re listening on `&quot;all&quot;`, which will cause your callback to // receive the true name of the event as the first argument). Events.trigger = function(name) &#123; if (!this._events) return this; var length = Math.max(0, arguments.length - 1); var args = Array(length); for (var i = 0; i &lt; length; i++) args[i] = arguments[i + 1]; eventsApi(triggerApi, this._events, name, void 0, args); return this; &#125;; // Handles triggering the appropriate event callbacks. var triggerApi = function(objEvents, name, callback, args) &#123; if (objEvents) &#123; var events = objEvents[name]; var allEvents = objEvents.all; if (events &amp;&amp; allEvents) allEvents = allEvents.slice(); if (events) triggerEvents(events, args); if (allEvents) triggerEvents(allEvents, [name].concat(args)); &#125; return objEvents; &#125;; // A difficult-to-believe, but optimized internal dispatch function for // triggering events. Tries to keep the usual cases speedy (most internal // Backbone events have 3 arguments). var triggerEvents = function(events, args) &#123; var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2]; switch (args.length) &#123; case 0: while (++i &lt; l) (ev = events[i]).callback.call(ev.ctx); return; case 1: while (++i &lt; l) (ev = events[i]).callback.call(ev.ctx, a1); return; case 2: while (++i &lt; l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return; case 3: while (++i &lt; l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return; default: while (++i &lt; l) (ev = events[i]).callback.apply(ev.ctx, args); return; &#125; &#125;; // A listening class that tracks and cleans up memory bindings // when all callbacks have been offed. var Listening = function(listener, obj) &#123; this.id = listener._listenId; this.listener = listener; this.obj = obj; this.interop = true; this.count = 0; this._events = void 0; &#125;; Listening.prototype.on = Events.on; // Offs a callback (or several). // Uses an optimized counter if the listenee uses Backbone.Events. // Otherwise, falls back to manual tracking to support events // library interop. Listening.prototype.off = function(name, callback) &#123; var cleanup; if (this.interop) &#123; this._events = eventsApi(offApi, this._events, name, callback, &#123; context: void 0, listeners: void 0 &#125;); cleanup = !this._events; &#125; else &#123; this.count--; cleanup = this.count === 0; &#125; if (cleanup) this.cleanup(); &#125;; // Cleans up memory bindings between the listener and the listenee. Listening.prototype.cleanup = function() &#123; delete this.listener._listeningTo[this.obj._listenId]; if (!this.interop) delete this.obj._listeners[this.id]; &#125;; // Aliases for backwards compatibility. Events.bind = Events.on; Events.unbind = Events.off; // Allow the `Backbone` object to serve as a global event bus, for folks who // want global &quot;pubsub&quot; in a convenient place. _.extend(Backbone, Events); // Backbone.Model // -------------- // Backbone **Models** are the basic data object in the framework -- // frequently representing a row in a table in a database on your server. // A discrete chunk of data and a bunch of useful, related methods for // performing computations and transformations on that data. // Create a new model with the specified attributes. A client id (`cid`) // is automatically generated and assigned for you. var Model = Backbone.Model = function(attributes, options) &#123; var attrs = attributes || &#123;&#125;; options || (options = &#123;&#125;); this.preinitialize.apply(this, arguments); this.cid = _.uniqueId(this.cidPrefix); this.attributes = &#123;&#125;; if (options.collection) this.collection = options.collection; if (options.parse) attrs = this.parse(attrs, options) || &#123;&#125;; var defaults = _.result(this, &#x27;defaults&#x27;); attrs = _.defaults(_.extend(&#123;&#125;, defaults, attrs), defaults); this.set(attrs, options); this.changed = &#123;&#125;; this.initialize.apply(this, arguments); &#125;; // Attach all inheritable methods to the Model prototype. _.extend(Model.prototype, Events, &#123; // A hash of attributes whose current and previous value differ. changed: null, // The value returned during the last failed validation. validationError: null, // The default name for the JSON `id` attribute is `&quot;id&quot;`. MongoDB and // CouchDB users may want to set this to `&quot;_id&quot;`. idAttribute: &#x27;id&#x27;, // The prefix is used to create the client id which is used to identify models locally. // You may want to override this if you&#x27;re experiencing name clashes with model ids. cidPrefix: &#x27;c&#x27;, // preinitialize is an empty function by default. You can override it with a function // or object. preinitialize will run before any instantiation logic is run in the Model. preinitialize: function()&#123;&#125;, // Initialize is an empty function by default. Override it with your own // initialization logic. initialize: function()&#123;&#125;, // Return a copy of the model&#x27;s `attributes` object. toJSON: function(options) &#123; return _.clone(this.attributes); &#125;, // Proxy `Backbone.sync` by default -- but override this if you need // custom syncing semantics for *this* particular model. sync: function() &#123; return Backbone.sync.apply(this, arguments); &#125;, // Get the value of an attribute. get: function(attr) &#123; return this.attributes[attr]; &#125;, // Get the HTML-escaped value of an attribute. escape: function(attr) &#123; return _.escape(this.get(attr)); &#125;, // Returns `true` if the attribute contains a value that is not null // or undefined. has: function(attr) &#123; return this.get(attr) != null; &#125;, // Special-cased proxy to underscore&#x27;s `_.matches` method. matches: function(attrs) &#123; return !!_.iteratee(attrs, this)(this.attributes); &#125;, // Set a hash of model attributes on the object, firing `&quot;change&quot;`. This is // the core primitive operation of a model, updating the data and notifying // anyone who needs to know about the change in state. The heart of the beast. set: function(key, val, options) &#123; if (key == null) return this; // Handle both `&quot;key&quot;, value` and `&#123;key: value&#125;` -style arguments. var attrs; if (typeof key === &#x27;object&#x27;) &#123; attrs = key; options = val; &#125; else &#123; (attrs = &#123;&#125;)[key] = val; &#125; options || (options = &#123;&#125;); // Run validation. if (!this._validate(attrs, options)) return false; // Extract attributes and options. var unset = options.unset; var silent = options.silent; var changes = []; var changing = this._changing; this._changing = true; if (!changing) &#123; this._previousAttributes = _.clone(this.attributes); this.changed = &#123;&#125;; &#125; var current = this.attributes; var changed = this.changed; var prev = this._previousAttributes; // For each `set` attribute, update or delete the current value. for (var attr in attrs) &#123; val = attrs[attr]; if (!_.isEqual(current[attr], val)) changes.push(attr); if (!_.isEqual(prev[attr], val)) &#123; changed[attr] = val; &#125; else &#123; delete changed[attr]; &#125; unset ? delete current[attr] : current[attr] = val; &#125; // Update the `id`. if (this.idAttribute in attrs) this.id = this.get(this.idAttribute); // Trigger all relevant attribute changes. if (!silent) &#123; if (changes.length) this._pending = options; for (var i = 0; i &lt; changes.length; i++) &#123; this.trigger(&#x27;change:&#x27; + changes[i], this, current[changes[i]], options); &#125; &#125; // You might be wondering why there&#x27;s a `while` loop here. Changes can // be recursively nested within `&quot;change&quot;` events. if (changing) return this; if (!silent) &#123; while (this._pending) &#123; options = this._pending; this._pending = false; this.trigger(&#x27;change&#x27;, this, options); &#125; &#125; this._pending = false; this._changing = false; return this; &#125;, // Remove an attribute from the model, firing `&quot;change&quot;`. `unset` is a noop // if the attribute doesn&#x27;t exist. unset: function(attr, options) &#123; return this.set(attr, void 0, _.extend(&#123;&#125;, options, &#123;unset: true&#125;)); &#125;, // Clear all attributes on the model, firing `&quot;change&quot;`. clear: function(options) &#123; var attrs = &#123;&#125;; for (var key in this.attributes) attrs[key] = void 0; return this.set(attrs, _.extend(&#123;&#125;, options, &#123;unset: true&#125;)); &#125;, // Determine if the model has changed since the last `&quot;change&quot;` event. // If you specify an attribute name, determine if that attribute has changed. hasChanged: function(attr) &#123; if (attr == null) return !_.isEmpty(this.changed); return _.has(this.changed, attr); &#125;, // Return an object containing all the attributes that have changed, or // false if there are no changed attributes. Useful for determining what // parts of a view need to be updated and/or what attributes need to be // persisted to the server. Unset attributes will be set to undefined. // You can also pass an attributes object to diff against the model, // determining if there *would be* a change. changedAttributes: function(diff) &#123; if (!diff) return this.hasChanged() ? _.clone(this.changed) : false; var old = this._changing ? this._previousAttributes : this.attributes; var changed = &#123;&#125;; var hasChanged; for (var attr in diff) &#123; var val = diff[attr]; if (_.isEqual(old[attr], val)) continue; changed[attr] = val; hasChanged = true; &#125; return hasChanged ? changed : false; &#125;, // Get the previous value of an attribute, recorded at the time the last // `&quot;change&quot;` event was fired. previous: function(attr) &#123; if (attr == null || !this._previousAttributes) return null; return this._previousAttributes[attr]; &#125;, // Get all of the attributes of the model at the time of the previous // `&quot;change&quot;` event. previousAttributes: function() &#123; return _.clone(this._previousAttributes); &#125;, // Fetch the model from the server, merging the response with the model&#x27;s // local attributes. Any changed attributes will trigger a &quot;change&quot; event. fetch: function(options) &#123; options = _.extend(&#123;parse: true&#125;, options); var model = this; var success = options.success; options.success = function(resp) &#123; var serverAttrs = options.parse ? model.parse(resp, options) : resp; if (!model.set(serverAttrs, options)) return false; if (success) success.call(options.context, model, resp, options); model.trigger(&#x27;sync&#x27;, model, resp, options); &#125;; wrapError(this, options); return this.sync(&#x27;read&#x27;, this, options); &#125;, // Set a hash of model attributes, and sync the model to the server. // If the server returns an attributes hash that differs, the model&#x27;s // state will be `set` again. save: function(key, val, options) &#123; // Handle both `&quot;key&quot;, value` and `&#123;key: value&#125;` -style arguments. var attrs; if (key == null || typeof key === &#x27;object&#x27;) &#123; attrs = key; options = val; &#125; else &#123; (attrs = &#123;&#125;)[key] = val; &#125; options = _.extend(&#123;validate: true, parse: true&#125;, options); var wait = options.wait; // If we&#x27;re not waiting and attributes exist, save acts as // `set(attr).save(null, opts)` with validation. Otherwise, check if // the model will be valid when the attributes, if any, are set. if (attrs &amp;&amp; !wait) &#123; if (!this.set(attrs, options)) return false; &#125; else if (!this._validate(attrs, options)) &#123; return false; &#125; // After a successful server-side save, the client is (optionally) // updated with the server-side state. var model = this; var success = options.success; var attributes = this.attributes; options.success = function(resp) &#123; // Ensure attributes are restored during synchronous saves. model.attributes = attributes; var serverAttrs = options.parse ? model.parse(resp, options) : resp; if (wait) serverAttrs = _.extend(&#123;&#125;, attrs, serverAttrs); if (serverAttrs &amp;&amp; !model.set(serverAttrs, options)) return false; if (success) success.call(options.context, model, resp, options); model.trigger(&#x27;sync&#x27;, model, resp, options); &#125;; wrapError(this, options); // Set temporary attributes if `&#123;wait: true&#125;` to properly find new ids. if (attrs &amp;&amp; wait) this.attributes = _.extend(&#123;&#125;, attributes, attrs); var method = this.isNew() ? &#x27;create&#x27; : options.patch ? &#x27;patch&#x27; : &#x27;update&#x27;; if (method === &#x27;patch&#x27; &amp;&amp; !options.attrs) options.attrs = attrs; var xhr = this.sync(method, this, options); // Restore attributes. this.attributes = attributes; return xhr; &#125;, // Destroy this model on the server if it was already persisted. // Optimistically removes the model from its collection, if it has one. // If `wait: true` is passed, waits for the server to respond before removal. destroy: function(options) &#123; options = options ? _.clone(options) : &#123;&#125;; var model = this; var success = options.success; var wait = options.wait; var destroy = function() &#123; model.stopListening(); model.trigger(&#x27;destroy&#x27;, model, model.collection, options); &#125;; options.success = function(resp) &#123; if (wait) destroy(); if (success) success.call(options.context, model, resp, options); if (!model.isNew()) model.trigger(&#x27;sync&#x27;, model, resp, options); &#125;; var xhr = false; if (this.isNew()) &#123; _.defer(options.success); &#125; else &#123; wrapError(this, options); xhr = this.sync(&#x27;delete&#x27;, this, options); &#125; if (!wait) destroy(); return xhr; &#125;, // Default URL for the model&#x27;s representation on the server -- if you&#x27;re // using Backbone&#x27;s restful methods, override this to change the endpoint // that will be called. url: function() &#123; var base = _.result(this, &#x27;urlRoot&#x27;) || _.result(this.collection, &#x27;url&#x27;) || urlError(); if (this.isNew()) return base; var id = this.get(this.idAttribute); return base.replace(/[^\\/]$/, &#x27;$&amp;/&#x27;) + encodeURIComponent(id); &#125;, // **parse** converts a response into the hash of attributes to be `set` on // the model. The default implementation is just to pass the response along. parse: function(resp, options) &#123; return resp; &#125;, // Create a new model with identical attributes to this one. clone: function() &#123; return new this.constructor(this.attributes); &#125;, // A model is new if it has never been saved to the server, and lacks an id. isNew: function() &#123; return !this.has(this.idAttribute); &#125;, // Check if the model is currently in a valid state. isValid: function(options) &#123; return this._validate(&#123;&#125;, _.extend(&#123;&#125;, options, &#123;validate: true&#125;)); &#125;, // Run validation against the next complete set of model attributes, // returning `true` if all is well. Otherwise, fire an `&quot;invalid&quot;` event. _validate: function(attrs, options) &#123; if (!options.validate || !this.validate) return true; attrs = _.extend(&#123;&#125;, this.attributes, attrs); var error = this.validationError = this.validate(attrs, options) || null; if (!error) return true; this.trigger(&#x27;invalid&#x27;, this, error, _.extend(options, &#123;validationError: error&#125;)); return false; &#125; &#125;); // Backbone.Collection // ------------------- // If models tend to represent a single row of data, a Backbone Collection is // more analogous to a table full of data ... or a small slice or page of that // table, or a collection of rows that belong together for a particular reason // -- all of the messages in this particular folder, all of the documents // belonging to this particular author, and so on. Collections maintain // indexes of their models, both in order, and for lookup by `id`. // Create a new **Collection**, perhaps to contain a specific type of `model`. // If a `comparator` is specified, the Collection will maintain // its models in sort order, as they&#x27;re added and removed. var Collection = Backbone.Collection = function(models, options) &#123; options || (options = &#123;&#125;); this.preinitialize.apply(this, arguments); if (options.model) this.model = options.model; if (options.comparator !== void 0) this.comparator = options.comparator; this._reset(); this.initialize.apply(this, arguments); if (models) this.reset(models, _.extend(&#123;silent: true&#125;, options)); &#125;; // Default options for `Collection#set`. var setOptions = &#123;add: true, remove: true, merge: true&#125;; var addOptions = &#123;add: true, remove: false&#125;; // Splices `insert` into `array` at index `at`. var splice = function(array, insert, at) &#123; at = Math.min(Math.max(at, 0), array.length); var tail = Array(array.length - at); var length = insert.length; var i; for (i = 0; i &lt; tail.length; i++) tail[i] = array[i + at]; for (i = 0; i &lt; length; i++) array[i + at] = insert[i]; for (i = 0; i &lt; tail.length; i++) array[i + length + at] = tail[i]; &#125;; // Define the Collection&#x27;s inheritable methods. _.extend(Collection.prototype, Events, &#123; // The default model for a collection is just a **Backbone.Model**. // This should be overridden in most cases. model: Model, // preinitialize is an empty function by default. You can override it with a function // or object. preinitialize will run before any instantiation logic is run in the Collection. preinitialize: function()&#123;&#125;, // Initialize is an empty function by default. Override it with your own // initialization logic. initialize: function()&#123;&#125;, // The JSON representation of a Collection is an array of the // models&#x27; attributes. toJSON: function(options) &#123; return this.map(function(model) &#123; return model.toJSON(options); &#125;); &#125;, // Proxy `Backbone.sync` by default. sync: function() &#123; return Backbone.sync.apply(this, arguments); &#125;, // Add a model, or list of models to the set. `models` may be Backbone // Models or raw JavaScript objects to be converted to Models, or any // combination of the two. add: function(models, options) &#123; return this.set(models, _.extend(&#123;merge: false&#125;, options, addOptions)); &#125;, // Remove a model, or a list of models from the set. remove: function(models, options) &#123; options = _.extend(&#123;&#125;, options); var singular = !_.isArray(models); models = singular ? [models] : models.slice(); var removed = this._removeModels(models, options); if (!options.silent &amp;&amp; removed.length) &#123; options.changes = &#123;added: [], merged: [], removed: removed&#125;; this.trigger(&#x27;update&#x27;, this, options); &#125; return singular ? removed[0] : removed; &#125;, // Update a collection by `set`-ing a new list of models, adding new ones, // removing models that are no longer present, and merging models that // already exist in the collection, as necessary. Similar to **Model#set**, // the core operation for updating the data contained by the collection. set: function(models, options) &#123; if (models == null) return; options = _.extend(&#123;&#125;, setOptions, options); if (options.parse &amp;&amp; !this._isModel(models)) &#123; models = this.parse(models, options) || []; &#125; var singular = !_.isArray(models); models = singular ? [models] : models.slice(); var at = options.at; if (at != null) at = +at; if (at &gt; this.length) at = this.length; if (at &lt; 0) at += this.length + 1; var set = []; var toAdd = []; var toMerge = []; var toRemove = []; var modelMap = &#123;&#125;; var add = options.add; var merge = options.merge; var remove = options.remove; var sort = false; var sortable = this.comparator &amp;&amp; at == null &amp;&amp; options.sort !== false; var sortAttr = _.isString(this.comparator) ? this.comparator : null; // Turn bare objects into model references, and prevent invalid models // from being added. var model, i; for (i = 0; i &lt; models.length; i++) &#123; model = models[i]; // If a duplicate is found, prevent it from being added and // optionally merge it into the existing model. var existing = this.get(model); if (existing) &#123; if (merge &amp;&amp; model !== existing) &#123; var attrs = this._isModel(model) ? model.attributes : model; if (options.parse) attrs = existing.parse(attrs, options); existing.set(attrs, options); toMerge.push(existing); if (sortable &amp;&amp; !sort) sort = existing.hasChanged(sortAttr); &#125; if (!modelMap[existing.cid]) &#123; modelMap[existing.cid] = true; set.push(existing); &#125; models[i] = existing; // If this is a new, valid model, push it to the `toAdd` list. &#125; else if (add) &#123; model = models[i] = this._prepareModel(model, options); if (model) &#123; toAdd.push(model); this._addReference(model, options); modelMap[model.cid] = true; set.push(model); &#125; &#125; &#125; // Remove stale models. if (remove) &#123; for (i = 0; i &lt; this.length; i++) &#123; model = this.models[i]; if (!modelMap[model.cid]) toRemove.push(model); &#125; if (toRemove.length) this._removeModels(toRemove, options); &#125; // See if sorting is needed, update `length` and splice in new models. var orderChanged = false; var replace = !sortable &amp;&amp; add &amp;&amp; remove; if (set.length &amp;&amp; replace) &#123; orderChanged = this.length !== set.length || _.some(this.models, function(m, index) &#123; return m !== set[index]; &#125;); this.models.length = 0; splice(this.models, set, 0); this.length = this.models.length; &#125; else if (toAdd.length) &#123; if (sortable) sort = true; splice(this.models, toAdd, at == null ? this.length : at); this.length = this.models.length; &#125; // Silently sort the collection if appropriate. if (sort) this.sort(&#123;silent: true&#125;); // Unless silenced, it&#x27;s time to fire all appropriate add/sort/update events. if (!options.silent) &#123; for (i = 0; i &lt; toAdd.length; i++) &#123; if (at != null) options.index = at + i; model = toAdd[i]; model.trigger(&#x27;add&#x27;, model, this, options); &#125; if (sort || orderChanged) this.trigger(&#x27;sort&#x27;, this, options); if (toAdd.length || toRemove.length || toMerge.length) &#123; options.changes = &#123; added: toAdd, removed: toRemove, merged: toMerge &#125;; this.trigger(&#x27;update&#x27;, this, options); &#125; &#125; // Return the added (or merged) model (or models). return singular ? models[0] : models; &#125;, // When you have more items than you want to add or remove individually, // you can reset the entire set with a new list of models, without firing // any granular `add` or `remove` events. Fires `reset` when finished. // Useful for bulk operations and optimizations. reset: function(models, options) &#123; options = options ? _.clone(options) : &#123;&#125;; for (var i = 0; i &lt; this.models.length; i++) &#123; this._removeReference(this.models[i], options); &#125; options.previousModels = this.models; this._reset(); models = this.add(models, _.extend(&#123;silent: true&#125;, options)); if (!options.silent) this.trigger(&#x27;reset&#x27;, this, options); return models; &#125;, // Add a model to the end of the collection. push: function(model, options) &#123; return this.add(model, _.extend(&#123;at: this.length&#125;, options)); &#125;, // Remove a model from the end of the collection. pop: function(options) &#123; var model = this.at(this.length - 1); return this.remove(model, options); &#125;, // Add a model to the beginning of the collection. unshift: function(model, options) &#123; return this.add(model, _.extend(&#123;at: 0&#125;, options)); &#125;, // Remove a model from the beginning of the collection. shift: function(options) &#123; var model = this.at(0); return this.remove(model, options); &#125;, // Slice out a sub-array of models from the collection. slice: function() &#123; return slice.apply(this.models, arguments); &#125;, // Get a model from the set by id, cid, model object with id or cid // properties, or an attributes object that is transformed through modelId. get: function(obj) &#123; if (obj == null) return void 0; return this._byId[obj] || this._byId[this.modelId(this._isModel(obj) ? obj.attributes : obj)] || obj.cid &amp;&amp; this._byId[obj.cid]; &#125;, // Returns `true` if the model is in the collection. has: function(obj) &#123; return this.get(obj) != null; &#125;, // Get the model at the given index. at: function(index) &#123; if (index &lt; 0) index += this.length; return this.models[index]; &#125;, // Return models with matching attributes. Useful for simple cases of // `filter`. where: function(attrs, first) &#123; return this[first ? &#x27;find&#x27; : &#x27;filter&#x27;](attrs); &#125;, // Return the first model with matching attributes. Useful for simple cases // of `find`. findWhere: function(attrs) &#123; return this.where(attrs, true); &#125;, // Force the collection to re-sort itself. You don&#x27;t need to call this under // normal circumstances, as the set will maintain sort order as each item // is added. sort: function(options) &#123; var comparator = this.comparator; if (!comparator) throw new Error(&#x27;Cannot sort a set without a comparator&#x27;); options || (options = &#123;&#125;); var length = comparator.length; if (_.isFunction(comparator)) comparator = comparator.bind(this); // Run sort based on type of `comparator`. if (length === 1 || _.isString(comparator)) &#123; this.models = this.sortBy(comparator); &#125; else &#123; this.models.sort(comparator); &#125; if (!options.silent) this.trigger(&#x27;sort&#x27;, this, options); return this; &#125;, // Pluck an attribute from each model in the collection. pluck: function(attr) &#123; return this.map(attr + &#x27;&#x27;); &#125;, // Fetch the default set of models for this collection, resetting the // collection when they arrive. If `reset: true` is passed, the response // data will be passed through the `reset` method instead of `set`. fetch: function(options) &#123; options = _.extend(&#123;parse: true&#125;, options); var success = options.success; var collection = this; options.success = function(resp) &#123; var method = options.reset ? &#x27;reset&#x27; : &#x27;set&#x27;; collection[method](resp, options); if (success) success.call(options.context, collection, resp, options); collection.trigger(&#x27;sync&#x27;, collection, resp, options); &#125;; wrapError(this, options); return this.sync(&#x27;read&#x27;, this, options); &#125;, // Create a new instance of a model in this collection. Add the model to the // collection immediately, unless `wait: true` is passed, in which case we // wait for the server to agree. create: function(model, options) &#123; options = options ? _.clone(options) : &#123;&#125;; var wait = options.wait; model = this._prepareModel(model, options); if (!model) return false; if (!wait) this.add(model, options); var collection = this; var success = options.success; options.success = function(m, resp, callbackOpts) &#123; if (wait) collection.add(m, callbackOpts); if (success) success.call(callbackOpts.context, m, resp, callbackOpts); &#125;; model.save(null, options); return model; &#125;, // **parse** converts a response into a list of models to be added to the // collection. The default implementation is just to pass it through. parse: function(resp, options) &#123; return resp; &#125;, // Create a new collection with an identical list of models as this one. clone: function() &#123; return new this.constructor(this.models, &#123; model: this.model, comparator: this.comparator &#125;); &#125;, // Define how to uniquely identify models in the collection. modelId: function(attrs) &#123; return attrs[this.model.prototype.idAttribute || &#x27;id&#x27;]; &#125;, // Get an iterator of all models in this collection. values: function() &#123; return new CollectionIterator(this, ITERATOR_VALUES); &#125;, // Get an iterator of all model IDs in this collection. keys: function() &#123; return new CollectionIterator(this, ITERATOR_KEYS); &#125;, // Get an iterator of all [ID, model] tuples in this collection. entries: function() &#123; return new CollectionIterator(this, ITERATOR_KEYSVALUES); &#125;, // Private method to reset all internal state. Called when the collection // is first initialized or reset. _reset: function() &#123; this.length = 0; this.models = []; this._byId = &#123;&#125;; &#125;, // Prepare a hash of attributes (or other model) to be added to this // collection. _prepareModel: function(attrs, options) &#123; if (this._isModel(attrs)) &#123; if (!attrs.collection) attrs.collection = this; return attrs; &#125; options = options ? _.clone(options) : &#123;&#125;; options.collection = this; var model = new this.model(attrs, options); if (!model.validationError) return model; this.trigger(&#x27;invalid&#x27;, this, model.validationError, options); return false; &#125;, // Internal method called by both remove and set. _removeModels: function(models, options) &#123; var removed = []; for (var i = 0; i &lt; models.length; i++) &#123; var model = this.get(models[i]); if (!model) continue; var index = this.indexOf(model); this.models.splice(index, 1); this.length--; // Remove references before triggering &#x27;remove&#x27; event to prevent an // infinite loop. #3693 delete this._byId[model.cid]; var id = this.modelId(model.attributes); if (id != null) delete this._byId[id]; if (!options.silent) &#123; options.index = index; model.trigger(&#x27;remove&#x27;, model, this, options); &#125; removed.push(model); this._removeReference(model, options); &#125; return removed; &#125;, // Method for checking whether an object should be considered a model for // the purposes of adding to the collection. _isModel: function(model) &#123; return model instanceof Model; &#125;, // Internal method to create a model&#x27;s ties to a collection. _addReference: function(model, options) &#123; this._byId[model.cid] = model; var id = this.modelId(model.attributes); if (id != null) this._byId[id] = model; model.on(&#x27;all&#x27;, this._onModelEvent, this); &#125;, // Internal method to sever a model&#x27;s ties to a collection. _removeReference: function(model, options) &#123; delete this._byId[model.cid]; var id = this.modelId(model.attributes); if (id != null) delete this._byId[id]; if (this === model.collection) delete model.collection; model.off(&#x27;all&#x27;, this._onModelEvent, this); &#125;, // Internal method called every time a model in the set fires an event. // Sets need to update their indexes when models change ids. All other // events simply proxy through. &quot;add&quot; and &quot;remove&quot; events that originate // in other collections are ignored. _onModelEvent: function(event, model, collection, options) &#123; if (model) &#123; if ((event === &#x27;add&#x27; || event === &#x27;remove&#x27;) &amp;&amp; collection !== this) return; if (event === &#x27;destroy&#x27;) this.remove(model, options); if (event === &#x27;change&#x27;) &#123; var prevId = this.modelId(model.previousAttributes()); var id = this.modelId(model.attributes); if (prevId !== id) &#123; if (prevId != null) delete this._byId[prevId]; if (id != null) this._byId[id] = model; &#125; &#125; &#125; this.trigger.apply(this, arguments); &#125; &#125;); // Defining an @@iterator method implements JavaScript&#x27;s Iterable protocol. // In modern ES2015 browsers, this value is found at Symbol.iterator. /* global Symbol */ var $$iterator = typeof Symbol === &#x27;function&#x27; &amp;&amp; Symbol.iterator; if ($$iterator) &#123; Collection.prototype[$$iterator] = Collection.prototype.values; &#125; // CollectionIterator // ------------------ // A CollectionIterator implements JavaScript&#x27;s Iterator protocol, allowing the // use of `for of` loops in modern browsers and interoperation between // Backbone.Collection and other JavaScript functions and third-party libraries // which can operate on Iterables. var CollectionIterator = function(collection, kind) &#123; this._collection = collection; this._kind = kind; this._index = 0; &#125;; // This &quot;enum&quot; defines the three possible kinds of values which can be emitted // by a CollectionIterator that correspond to the values(), keys() and entries() // methods on Collection, respectively. var ITERATOR_VALUES = 1; var ITERATOR_KEYS = 2; var ITERATOR_KEYSVALUES = 3; // All Iterators should themselves be Iterable. if ($$iterator) &#123; CollectionIterator.prototype[$$iterator] = function() &#123; return this; &#125;; &#125; CollectionIterator.prototype.next = function() &#123; if (this._collection) &#123; // Only continue iterating if the iterated collection is long enough. if (this._index &lt; this._collection.length) &#123; var model = this._collection.at(this._index); this._index++; // Construct a value depending on what kind of values should be iterated. var value; if (this._kind === ITERATOR_VALUES) &#123; value = model; &#125; else &#123; var id = this._collection.modelId(model.attributes); if (this._kind === ITERATOR_KEYS) &#123; value = id; &#125; else &#123; // ITERATOR_KEYSVALUES value = [id, model]; &#125; &#125; return &#123;value: value, done: false&#125;; &#125; // Once exhausted, remove the reference to the collection so future // calls to the next method always return done. this._collection = void 0; &#125; return &#123;value: void 0, done: true&#125;; &#125;; // Backbone.View // ------------- // Backbone Views are almost more convention than they are actual code. A View // is simply a JavaScript object that represents a logical chunk of UI in the // DOM. This might be a single item, an entire list, a sidebar or panel, or // even the surrounding frame which wraps your whole app. Defining a chunk of // UI as a **View** allows you to define your DOM events declaratively, without // having to worry about render order ... and makes it easy for the view to // react to specific changes in the state of your models. // Creating a Backbone.View creates its initial element outside of the DOM, // if an existing element is not provided... var View = Backbone.View = function(options) &#123; this.cid = _.uniqueId(&#x27;view&#x27;); this.preinitialize.apply(this, arguments); _.extend(this, _.pick(options, viewOptions)); this._ensureElement(); this.initialize.apply(this, arguments); &#125;; // Cached regex to split keys for `delegate`. var delegateEventSplitter = /^(\\S+)\\s*(.*)$/; // List of view options to be set as properties. var viewOptions = [&#x27;model&#x27;, &#x27;collection&#x27;, &#x27;el&#x27;, &#x27;id&#x27;, &#x27;attributes&#x27;, &#x27;className&#x27;, &#x27;tagName&#x27;, &#x27;events&#x27;]; // Set up all inheritable **Backbone.View** properties and methods. _.extend(View.prototype, Events, &#123; // The default `tagName` of a View&#x27;s element is `&quot;div&quot;`. tagName: &#x27;div&#x27;, // jQuery delegate for element lookup, scoped to DOM elements within the // current view. This should be preferred to global lookups where possible. $: function(selector) &#123; return this.$el.find(selector); &#125;, // preinitialize is an empty function by default. You can override it with a function // or object. preinitialize will run before any instantiation logic is run in the View preinitialize: function()&#123;&#125;, // Initialize is an empty function by default. Override it with your own // initialization logic. initialize: function()&#123;&#125;, // **render** is the core function that your view should override, in order // to populate its element (`this.el`), with the appropriate HTML. The // convention is for **render** to always return `this`. render: function() &#123; return this; &#125;, // Remove this view by taking the element out of the DOM, and removing any // applicable Backbone.Events listeners. remove: function() &#123; this._removeElement(); this.stopListening(); return this; &#125;, // Remove this view&#x27;s element from the document and all event listeners // attached to it. Exposed for subclasses using an alternative DOM // manipulation API. _removeElement: function() &#123; this.$el.remove(); &#125;, // Change the view&#x27;s element (`this.el` property) and re-delegate the // view&#x27;s events on the new element. setElement: function(element) &#123; this.undelegateEvents(); this._setElement(element); this.delegateEvents(); return this; &#125;, // Creates the `this.el` and `this.$el` references for this view using the // given `el`. `el` can be a CSS selector or an HTML string, a jQuery // context or an element. Subclasses can override this to utilize an // alternative DOM manipulation API and are only required to set the // `this.el` property. _setElement: function(el) &#123; this.$el = el instanceof Backbone.$ ? el : Backbone.$(el); this.el = this.$el[0]; &#125;, // Set callbacks, where `this.events` is a hash of // // *&#123;&quot;event selector&quot;: &quot;callback&quot;&#125;* // // &#123; // &#x27;mousedown .title&#x27;: &#x27;edit&#x27;, // &#x27;click .button&#x27;: &#x27;save&#x27;, // &#x27;click .open&#x27;: function(e) &#123; ... &#125; // &#125; // // pairs. Callbacks will be bound to the view, with `this` set properly. // Uses event delegation for efficiency. // Omitting the selector binds the event to `this.el`. delegateEvents: function(events) &#123; events || (events = _.result(this, &#x27;events&#x27;)); if (!events) return this; this.undelegateEvents(); for (var key in events) &#123; var method = events[key]; if (!_.isFunction(method)) method = this[method]; if (!method) continue; var match = key.match(delegateEventSplitter); this.delegate(match[1], match[2], method.bind(this)); &#125; return this; &#125;, // Add a single event listener to the view&#x27;s element (or a child element // using `selector`). This only works for delegate-able events: not `focus`, // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer. delegate: function(eventName, selector, listener) &#123; this.$el.on(eventName + &#x27;.delegateEvents&#x27; + this.cid, selector, listener); return this; &#125;, // Clears all callbacks previously bound to the view by `delegateEvents`. // You usually don&#x27;t need to use this, but may wish to if you have multiple // Backbone views attached to the same DOM element. undelegateEvents: function() &#123; if (this.$el) this.$el.off(&#x27;.delegateEvents&#x27; + this.cid); return this; &#125;, // A finer-grained `undelegateEvents` for removing a single delegated event. // `selector` and `listener` are both optional. undelegate: function(eventName, selector, listener) &#123; this.$el.off(eventName + &#x27;.delegateEvents&#x27; + this.cid, selector, listener); return this; &#125;, // Produces a DOM element to be assigned to your view. Exposed for // subclasses using an alternative DOM manipulation API. _createElement: function(tagName) &#123; return document.createElement(tagName); &#125;, // Ensure that the View has a DOM element to render into. // If `this.el` is a string, pass it through `$()`, take the first // matching element, and re-assign it to `el`. Otherwise, create // an element from the `id`, `className` and `tagName` properties. _ensureElement: function() &#123; if (!this.el) &#123; var attrs = _.extend(&#123;&#125;, _.result(this, &#x27;attributes&#x27;)); if (this.id) attrs.id = _.result(this, &#x27;id&#x27;); if (this.className) attrs[&#x27;class&#x27;] = _.result(this, &#x27;className&#x27;); this.setElement(this._createElement(_.result(this, &#x27;tagName&#x27;))); this._setAttributes(attrs); &#125; else &#123; this.setElement(_.result(this, &#x27;el&#x27;)); &#125; &#125;, // Set attributes from a hash on this view&#x27;s element. Exposed for // subclasses using an alternative DOM manipulation API. _setAttributes: function(attributes) &#123; this.$el.attr(attributes); &#125; &#125;); // Proxy Backbone class methods to Underscore functions, wrapping the model&#x27;s // `attributes` object or collection&#x27;s `models` array behind the scenes. // // collection.filter(function(model) &#123; return model.get(&#x27;age&#x27;) &gt; 10 &#125;); // collection.each(this.addView); // // `Function#apply` can be slow so we use the method&#x27;s arg count, if we know it. var addMethod = function(base, length, method, attribute) &#123; switch (length) &#123; case 1: return function() &#123; return base[method](this[attribute]); &#125;; case 2: return function(value) &#123; return base[method](this[attribute], value); &#125;; case 3: return function(iteratee, context) &#123; return base[method](this[attribute], cb(iteratee, this), context); &#125;; case 4: return function(iteratee, defaultVal, context) &#123; return base[method](this[attribute], cb(iteratee, this), defaultVal, context); &#125;; default: return function() &#123; var args = slice.call(arguments); args.unshift(this[attribute]); return base[method].apply(base, args); &#125;; &#125; &#125;; var addUnderscoreMethods = function(Class, base, methods, attribute) &#123; _.each(methods, function(length, method) &#123; if (base[method]) Class.prototype[method] = addMethod(base, length, method, attribute); &#125;); &#125;; // Support `collection.sortBy(&#x27;attr&#x27;)` and `collection.findWhere(&#123;id: 1&#125;)`. var cb = function(iteratee, instance) &#123; if (_.isFunction(iteratee)) return iteratee; if (_.isObject(iteratee) &amp;&amp; !instance._isModel(iteratee)) return modelMatcher(iteratee); if (_.isString(iteratee)) return function(model) &#123; return model.get(iteratee); &#125;; return iteratee; &#125;; var modelMatcher = function(attrs) &#123; var matcher = _.matches(attrs); return function(model) &#123; return matcher(model.attributes); &#125;; &#125;; // Underscore methods that we want to implement on the Collection. // 90% of the core usefulness of Backbone Collections is actually implemented // right here: var collectionMethods = &#123;forEach: 3, each: 3, map: 3, collect: 3, reduce: 0, foldl: 0, inject: 0, reduceRight: 0, foldr: 0, find: 3, detect: 3, filter: 3, select: 3, reject: 3, every: 3, all: 3, some: 3, any: 3, include: 3, includes: 3, contains: 3, invoke: 0, max: 3, min: 3, toArray: 1, size: 1, first: 3, head: 3, take: 3, initial: 3, rest: 3, tail: 3, drop: 3, last: 3, without: 0, difference: 0, indexOf: 3, shuffle: 1, lastIndexOf: 3, isEmpty: 1, chain: 1, sample: 3, partition: 3, groupBy: 3, countBy: 3, sortBy: 3, indexBy: 3, findIndex: 3, findLastIndex: 3&#125;; // Underscore methods that we want to implement on the Model, mapped to the // number of arguments they take. var modelMethods = &#123;keys: 1, values: 1, pairs: 1, invert: 1, pick: 0, omit: 0, chain: 1, isEmpty: 1&#125;; // Mix in each Underscore method as a proxy to `Collection#models`. _.each([ [Collection, collectionMethods, &#x27;models&#x27;], [Model, modelMethods, &#x27;attributes&#x27;] ], function(config) &#123; var Base = config[0], methods = config[1], attribute = config[2]; Base.mixin = function(obj) &#123; var mappings = _.reduce(_.functions(obj), function(memo, name) &#123; memo[name] = 0; return memo; &#125;, &#123;&#125;); addUnderscoreMethods(Base, obj, mappings, attribute); &#125;; addUnderscoreMethods(Base, _, methods, attribute); &#125;); // Backbone.sync // ------------- // Override this function to change the manner in which Backbone persists // models to the server. You will be passed the type of request, and the // model in question. By default, makes a RESTful Ajax request // to the model&#x27;s `url()`. Some possible customizations could be: // // * Use `setTimeout` to batch rapid-fire updates into a single request. // * Send up the models as XML instead of JSON. // * Persist models via WebSockets instead of Ajax. // // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests // as `POST`, with a `_method` parameter containing the true HTTP method, // as well as all requests with the body as `application/x-www-form-urlencoded` // instead of `application/json` with the model in a param named `model`. // Useful when interfacing with server-side languages like **PHP** that make // it difficult to read the body of `PUT` requests. Backbone.sync = function(method, model, options) &#123; var type = methodMap[method]; // Default options, unless specified. _.defaults(options || (options = &#123;&#125;), &#123; emulateHTTP: Backbone.emulateHTTP, emulateJSON: Backbone.emulateJSON &#125;); // Default JSON-request options. var params = &#123;type: type, dataType: &#x27;json&#x27;&#125;; // Ensure that we have a URL. if (!options.url) &#123; params.url = _.result(model, &#x27;url&#x27;) || urlError(); &#125; // Ensure that we have the appropriate request data. if (options.data == null &amp;&amp; model &amp;&amp; (method === &#x27;create&#x27; || method === &#x27;update&#x27; || method === &#x27;patch&#x27;)) &#123; params.contentType = &#x27;application/json&#x27;; params.data = JSON.stringify(options.attrs || model.toJSON(options)); &#125; // For older servers, emulate JSON by encoding the request into an HTML-form. if (options.emulateJSON) &#123; params.contentType = &#x27;application/x-www-form-urlencoded&#x27;; params.data = params.data ? &#123;model: params.data&#125; : &#123;&#125;; &#125; // For older servers, emulate HTTP by mimicking the HTTP method with `_method` // And an `X-HTTP-Method-Override` header. if (options.emulateHTTP &amp;&amp; (type === &#x27;PUT&#x27; || type === &#x27;DELETE&#x27; || type === &#x27;PATCH&#x27;)) &#123; params.type = &#x27;POST&#x27;; if (options.emulateJSON) params.data._method = type; var beforeSend = options.beforeSend; options.beforeSend = function(xhr) &#123; xhr.setRequestHeader(&#x27;X-HTTP-Method-Override&#x27;, type); if (beforeSend) return beforeSend.apply(this, arguments); &#125;; &#125; // Don&#x27;t process data on a non-GET request. if (params.type !== &#x27;GET&#x27; &amp;&amp; !options.emulateJSON) &#123; params.processData = false; &#125; // Pass along `textStatus` and `errorThrown` from jQuery. var error = options.error; options.error = function(xhr, textStatus, errorThrown) &#123; options.textStatus = textStatus; options.errorThrown = errorThrown; if (error) error.call(options.context, xhr, textStatus, errorThrown); &#125;; // Make the request, allowing the user to override any Ajax options. var xhr = options.xhr = Backbone.ajax(_.extend(params, options)); model.trigger(&#x27;request&#x27;, model, xhr, options); return xhr; &#125;; // Map from CRUD to HTTP for our default `Backbone.sync` implementation. var methodMap = &#123; create: &#x27;POST&#x27;, update: &#x27;PUT&#x27;, patch: &#x27;PATCH&#x27;, delete: &#x27;DELETE&#x27;, read: &#x27;GET&#x27; &#125;; // Set the default implementation of `Backbone.ajax` to proxy through to `$`. // Override this if you&#x27;d like to use a different library. Backbone.ajax = function() &#123; return Backbone.$.ajax.apply(Backbone.$, arguments); &#125;; // Backbone.Router // --------------- // Routers map faux-URLs to actions, and fire events when routes are // matched. Creating a new one sets its `routes` hash, if not set statically. var Router = Backbone.Router = function(options) &#123; options || (options = &#123;&#125;); this.preinitialize.apply(this, arguments); if (options.routes) this.routes = options.routes; this._bindRoutes(); this.initialize.apply(this, arguments); &#125;; // Cached regular expressions for matching named param parts and splatted // parts of route strings. var optionalParam = /\\((.*?)\\)/g; var namedParam = /(\\(\\?)?:\\w+/g; var splatParam = /\\*\\w+/g; var escapeRegExp = /[\\-&#123;&#125;\\[\\]+?.,\\\\\\^$|#\\s]/g; // Set up all inheritable **Backbone.Router** properties and methods. _.extend(Router.prototype, Events, &#123; // preinitialize is an empty function by default. You can override it with a function // or object. preinitialize will run before any instantiation logic is run in the Router. preinitialize: function()&#123;&#125;, // Initialize is an empty function by default. Override it with your own // initialization logic. initialize: function()&#123;&#125;, // Manually bind a single named route to a callback. For example: // // this.route(&#x27;search/:query/p:num&#x27;, &#x27;search&#x27;, function(query, num) &#123; // ... // &#125;); // route: function(route, name, callback) &#123; if (!_.isRegExp(route)) route = this._routeToRegExp(route); if (_.isFunction(name)) &#123; callback = name; name = &#x27;&#x27;; &#125; if (!callback) callback = this[name]; var router = this; Backbone.history.route(route, function(fragment) &#123; var args = router._extractParameters(route, fragment); if (router.execute(callback, args, name) !== false) &#123; router.trigger.apply(router, [&#x27;route:&#x27; + name].concat(args)); router.trigger(&#x27;route&#x27;, name, args); Backbone.history.trigger(&#x27;route&#x27;, router, name, args); &#125; &#125;); return this; &#125;, // Execute a route handler with the provided parameters. This is an // excellent place to do pre-route setup or post-route cleanup. execute: function(callback, args, name) &#123; if (callback) callback.apply(this, args); &#125;, // Simple proxy to `Backbone.history` to save a fragment into the history. navigate: function(fragment, options) &#123; Backbone.history.navigate(fragment, options); return this; &#125;, // Bind all defined routes to `Backbone.history`. We have to reverse the // order of the routes here to support behavior where the most general // routes can be defined at the bottom of the route map. _bindRoutes: function() &#123; if (!this.routes) return; this.routes = _.result(this, &#x27;routes&#x27;); var route, routes = _.keys(this.routes); while ((route = routes.pop()) != null) &#123; this.route(route, this.routes[route]); &#125; &#125;, // Convert a route string into a regular expression, suitable for matching // against the current location hash. _routeToRegExp: function(route) &#123; route = route.replace(escapeRegExp, &#x27;\\\\$&amp;&#x27;) .replace(optionalParam, &#x27;(?:$1)?&#x27;) .replace(namedParam, function(match, optional) &#123; return optional ? match : &#x27;([^/?]+)&#x27;; &#125;) .replace(splatParam, &#x27;([^?]*?)&#x27;); return new RegExp(&#x27;^&#x27; + route + &#x27;(?:\\\\?([\\\\s\\\\S]*))?$&#x27;); &#125;, // Given a route, and a URL fragment that it matches, return the array of // extracted decoded parameters. Empty or unmatched parameters will be // treated as `null` to normalize cross-browser behavior. _extractParameters: function(route, fragment) &#123; var params = route.exec(fragment).slice(1); return _.map(params, function(param, i) &#123; // Don&#x27;t decode the search params. if (i === params.length - 1) return param || null; return param ? decodeURIComponent(param) : null; &#125;); &#125; &#125;); // Backbone.History // ---------------- // Handles cross-browser history management, based on either // [pushState](http://diveintohtml5.info/history.html) and real URLs, or // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange) // and URL fragments. If the browser supports neither (old IE, natch), // falls back to polling. var History = Backbone.History = function() &#123; this.handlers = []; this.checkUrl = this.checkUrl.bind(this); // Ensure that `History` can be used outside of the browser. if (typeof window !== &#x27;undefined&#x27;) &#123; this.location = window.location; this.history = window.history; &#125; &#125;; // Cached regex for stripping a leading hash/slash and trailing space. var routeStripper = /^[#\\/]|\\s+$/g; // Cached regex for stripping leading and trailing slashes. var rootStripper = /^\\/+|\\/+$/g; // Cached regex for stripping urls of hash. var pathStripper = /#.*$/; // Has the history handling already been started? History.started = false; // Set up all inheritable **Backbone.History** properties and methods. _.extend(History.prototype, Events, &#123; // The default interval to poll for hash changes, if necessary, is // twenty times a second. interval: 50, // Are we at the app root? atRoot: function() &#123; var path = this.location.pathname.replace(/[^\\/]$/, &#x27;$&amp;/&#x27;); return path === this.root &amp;&amp; !this.getSearch(); &#125;, // Does the pathname match the root? matchRoot: function() &#123; var path = this.decodeFragment(this.location.pathname); var rootPath = path.slice(0, this.root.length - 1) + &#x27;/&#x27;; return rootPath === this.root; &#125;, // Unicode characters in `location.pathname` are percent encoded so they&#x27;re // decoded for comparison. `%25` should not be decoded since it may be part // of an encoded parameter. decodeFragment: function(fragment) &#123; return decodeURI(fragment.replace(/%25/g, &#x27;%2525&#x27;)); &#125;, // In IE6, the hash fragment and search params are incorrect if the // fragment contains `?`. getSearch: function() &#123; var match = this.location.href.replace(/#.*/, &#x27;&#x27;).match(/\\?.+/); return match ? match[0] : &#x27;&#x27;; &#125;, // Gets the true hash value. Cannot use location.hash directly due to bug // in Firefox where location.hash will always be decoded. getHash: function(window) &#123; var match = (window || this).location.href.match(/#(.*)$/); return match ? match[1] : &#x27;&#x27;; &#125;, // Get the pathname and search params, without the root. getPath: function() &#123; var path = this.decodeFragment( this.location.pathname + this.getSearch() ).slice(this.root.length - 1); return path.charAt(0) === &#x27;/&#x27; ? path.slice(1) : path; &#125;, // Get the cross-browser normalized URL fragment from the path or hash. getFragment: function(fragment) &#123; if (fragment == null) &#123; if (this._usePushState || !this._wantsHashChange) &#123; fragment = this.getPath(); &#125; else &#123; fragment = this.getHash(); &#125; &#125; return fragment.replace(routeStripper, &#x27;&#x27;); &#125;, // Start the hash change handling, returning `true` if the current URL matches // an existing route, and `false` otherwise. start: function(options) &#123; if (History.started) throw new Error(&#x27;Backbone.history has already been started&#x27;); History.started = true; // Figure out the initial configuration. Do we need an iframe? // Is pushState desired ... is it available? this.options = _.extend(&#123;root: &#x27;/&#x27;&#125;, this.options, options); this.root = this.options.root; this._wantsHashChange = this.options.hashChange !== false; this._hasHashChange = &#x27;onhashchange&#x27; in window &amp;&amp; (document.documentMode === void 0 || document.documentMode &gt; 7); this._useHashChange = this._wantsHashChange &amp;&amp; this._hasHashChange; this._wantsPushState = !!this.options.pushState; this._hasPushState = !!(this.history &amp;&amp; this.history.pushState); this._usePushState = this._wantsPushState &amp;&amp; this._hasPushState; this.fragment = this.getFragment(); // Normalize root to always include a leading and trailing slash. this.root = (&#x27;/&#x27; + this.root + &#x27;/&#x27;).replace(rootStripper, &#x27;/&#x27;); // Transition from hashChange to pushState or vice versa if both are // requested. if (this._wantsHashChange &amp;&amp; this._wantsPushState) &#123; // If we&#x27;ve started off with a route from a `pushState`-enabled // browser, but we&#x27;re currently in a browser that doesn&#x27;t support it... if (!this._hasPushState &amp;&amp; !this.atRoot()) &#123; var rootPath = this.root.slice(0, -1) || &#x27;/&#x27;; this.location.replace(rootPath + &#x27;#&#x27; + this.getPath()); // Return immediately as browser will do redirect to new url return true; // Or if we&#x27;ve started out with a hash-based route, but we&#x27;re currently // in a browser where it could be `pushState`-based instead... &#125; else if (this._hasPushState &amp;&amp; this.atRoot()) &#123; this.navigate(this.getHash(), &#123;replace: true&#125;); &#125; &#125; // Proxy an iframe to handle location events if the browser doesn&#x27;t // support the `hashchange` event, HTML5 history, or the user wants // `hashChange` but not `pushState`. if (!this._hasHashChange &amp;&amp; this._wantsHashChange &amp;&amp; !this._usePushState) &#123; this.iframe = document.createElement(&#x27;iframe&#x27;); this.iframe.src = &#x27;javascript:0&#x27;; this.iframe.style.display = &#x27;none&#x27;; this.iframe.tabIndex = -1; var body = document.body; // Using `appendChild` will throw on IE &lt; 9 if the document is not ready. var iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow; iWindow.document.open(); iWindow.document.close(); iWindow.location.hash = &#x27;#&#x27; + this.fragment; &#125; // Add a cross-platform `addEventListener` shim for older browsers. var addEventListener = window.addEventListener || function(eventName, listener) &#123; return attachEvent(&#x27;on&#x27; + eventName, listener); &#125;; // Depending on whether we&#x27;re using pushState or hashes, and whether // &#x27;onhashchange&#x27; is supported, determine how we check the URL state. if (this._usePushState) &#123; addEventListener(&#x27;popstate&#x27;, this.checkUrl, false); &#125; else if (this._useHashChange &amp;&amp; !this.iframe) &#123; addEventListener(&#x27;hashchange&#x27;, this.checkUrl, false); &#125; else if (this._wantsHashChange) &#123; this._checkUrlInterval = setInterval(this.checkUrl, this.interval); &#125; if (!this.options.silent) return this.loadUrl(); &#125;, // Disable Backbone.history, perhaps temporarily. Not useful in a real app, // but possibly useful for unit testing Routers. stop: function() &#123; // Add a cross-platform `removeEventListener` shim for older browsers. var removeEventListener = window.removeEventListener || function(eventName, listener) &#123; return detachEvent(&#x27;on&#x27; + eventName, listener); &#125;; // Remove window listeners. if (this._usePushState) &#123; removeEventListener(&#x27;popstate&#x27;, this.checkUrl, false); &#125; else if (this._useHashChange &amp;&amp; !this.iframe) &#123; removeEventListener(&#x27;hashchange&#x27;, this.checkUrl, false); &#125; // Clean up the iframe if necessary. if (this.iframe) &#123; document.body.removeChild(this.iframe); this.iframe = null; &#125; // Some environments will throw when clearing an undefined interval. if (this._checkUrlInterval) clearInterval(this._checkUrlInterval); History.started = false; &#125;, // Add a route to be tested when the fragment changes. Routes added later // may override previous routes. route: function(route, callback) &#123; this.handlers.unshift(&#123;route: route, callback: callback&#125;); &#125;, // Checks the current URL to see if it has changed, and if it has, // calls `loadUrl`, normalizing across the hidden iframe. checkUrl: function(e) &#123; var current = this.getFragment(); // If the user pressed the back button, the iframe&#x27;s hash will have // changed and we should use that for comparison. if (current === this.fragment &amp;&amp; this.iframe) &#123; current = this.getHash(this.iframe.contentWindow); &#125; if (current === this.fragment) return false; if (this.iframe) this.navigate(current); this.loadUrl(); &#125;, // Attempt to load the current URL fragment. If a route succeeds with a // match, returns `true`. If no defined routes matches the fragment, // returns `false`. loadUrl: function(fragment) &#123; // If the root doesn&#x27;t match, no routes can match either. if (!this.matchRoot()) return false; fragment = this.fragment = this.getFragment(fragment); return _.some(this.handlers, function(handler) &#123; if (handler.route.test(fragment)) &#123; handler.callback(fragment); return true; &#125; &#125;); &#125;, // Save a fragment into the hash history, or replace the URL state if the // &#x27;replace&#x27; option is passed. You are responsible for properly URL-encoding // the fragment in advance. // // The options object can contain `trigger: true` if you wish to have the // route callback be fired (not usually desirable), or `replace: true`, if // you wish to modify the current URL without adding an entry to the history. navigate: function(fragment, options) &#123; if (!History.started) return false; if (!options || options === true) options = &#123;trigger: !!options&#125;; // Normalize the fragment. fragment = this.getFragment(fragment || &#x27;&#x27;); // Don&#x27;t include a trailing slash on the root. var rootPath = this.root; if (fragment === &#x27;&#x27; || fragment.charAt(0) === &#x27;?&#x27;) &#123; rootPath = rootPath.slice(0, -1) || &#x27;/&#x27;; &#125; var url = rootPath + fragment; // Strip the fragment of the query and hash for matching. fragment = fragment.replace(pathStripper, &#x27;&#x27;); // Decode for matching. var decodedFragment = this.decodeFragment(fragment); if (this.fragment === decodedFragment) return; this.fragment = decodedFragment; // If pushState is available, we use it to set the fragment as a real URL. if (this._usePushState) &#123; this.history[options.replace ? &#x27;replaceState&#x27; : &#x27;pushState&#x27;](&#123;&#125;, document.title, url); // If hash changes haven&#x27;t been explicitly disabled, update the hash // fragment to store history. &#125; else if (this._wantsHashChange) &#123; this._updateHash(this.location, fragment, options.replace); if (this.iframe &amp;&amp; fragment !== this.getHash(this.iframe.contentWindow)) &#123; var iWindow = this.iframe.contentWindow; // Opening and closing the iframe tricks IE7 and earlier to push a // history entry on hash-tag change. When replace is true, we don&#x27;t // want this. if (!options.replace) &#123; iWindow.document.open(); iWindow.document.close(); &#125; this._updateHash(iWindow.location, fragment, options.replace); &#125; // If you&#x27;ve told us that you explicitly don&#x27;t want fallback hashchange- // based history, then `navigate` becomes a page refresh. &#125; else &#123; return this.location.assign(url); &#125; if (options.trigger) return this.loadUrl(fragment); &#125;, // Update the hash location, either replacing the current entry, or adding // a new one to the browser history. _updateHash: function(location, fragment, replace) &#123; if (replace) &#123; var href = location.href.replace(/(javascript:|#).*$/, &#x27;&#x27;); location.replace(href + &#x27;#&#x27; + fragment); &#125; else &#123; // Some browsers require that `hash` contains a leading #. location.hash = &#x27;#&#x27; + fragment; &#125; &#125; &#125;); // Create the default Backbone.history. Backbone.history = new History; // Helpers // ------- // Helper function to correctly set up the prototype chain for subclasses. // Similar to `goog.inherits`, but uses a hash of prototype properties and // class properties to be extended. var extend = function(protoProps, staticProps) &#123; var parent = this; var child; // The constructor function for the new subclass is either defined by you // (the &quot;constructor&quot; property in your `extend` definition), or defaulted // by us to simply call the parent constructor. if (protoProps &amp;&amp; _.has(protoProps, &#x27;constructor&#x27;)) &#123; child = protoProps.constructor; &#125; else &#123; child = function()&#123; return parent.apply(this, arguments); &#125;; &#125; // Add static properties to the constructor function, if supplied. _.extend(child, parent, staticProps); // Set the prototype chain to inherit from `parent`, without calling // `parent`&#x27;s constructor function and add the prototype properties. child.prototype = _.create(parent.prototype, protoProps); child.prototype.constructor = child; // Set a convenience property in case the parent&#x27;s prototype is needed // later. child.__super__ = parent.prototype; return child; &#125;; // Set up inheritance for the model, collection, router, view and history. Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend; // Throw an error when a URL is needed, and none is supplied. var urlError = function() &#123; throw new Error(&#x27;A &quot;url&quot; property or function must be specified&#x27;); &#125;; // Wrap an optional error callback with a fallback error event. var wrapError = function(model, options) &#123; var error = options.error; options.error = function(resp) &#123; if (error) error.call(options.context, model, resp, options); model.trigger(&#x27;error&#x27;, model, resp, options); &#125;; &#125;; return Backbone;&#125;);","categories":[],"tags":[{"name":"源码","slug":"源码","permalink":"https://wisiw.github.io.git/tags/%E6%BA%90%E7%A0%81/"},{"name":"backbone.js","slug":"backbone-js","permalink":"https://wisiw.github.io.git/tags/backbone-js/"}]},{"title":"【JavaScript】forEach、map、reduce、filter的区别","slug":"【JavaScript】forEach、map、reduce、filter的区别","date":"2021-08-30T03:43:43.000Z","updated":"2021-09-23T03:59:09.193Z","comments":true,"path":"2021/08/30/【JavaScript】forEach、map、reduce、filter的区别/","link":"","permalink":"https://wisiw.github.io.git/2021/08/30/%E3%80%90JavaScript%E3%80%91forEach%E3%80%81map%E3%80%81reduce%E3%80%81filter%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"forEach 循环数组 return只能打断当前循环中的执行的代码，不能打断循环本身；不支持continue 与 break map 循环数组，返回新数组 return会改变返回数组 reduce 循环数组，依次相加 filter 循环数组，根据条件返回新数组 some every","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wisiw.github.io.git/tags/JavaScript/"}]},{"title":"【架构】前端工程化（二）：添加路由","slug":"【架构】前端工程化（二）：添加路由","date":"2021-08-13T03:41:46.000Z","updated":"2021-08-13T03:51:27.296Z","comments":true,"path":"2021/08/13/【架构】前端工程化（二）：添加路由/","link":"","permalink":"https://wisiw.github.io.git/2021/08/13/%E3%80%90%E6%9E%B6%E6%9E%84%E3%80%91%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%B7%BB%E5%8A%A0%E8%B7%AF%E7%94%B1/","excerpt":"","text":"目录结构 1234567└── src ├── config │ └── router.js ├── router │ └── index.js └── APP.vue └── main.js 1.创建公共路由12345678// src/config/router.jsexport default [ &#123; path: &#x27;/alert&#x27;, name: &#x27;alert&#x27;, component: () =&gt; import(&#x27;module_vue/packages/alert&#x27;) &#125;] 2.引用公共路由123456789101112// src/router/index.jsimport Vue from &#x27;vue&#x27;import VueRouter from &#x27;vue-router&#x27;import commonRouter from &#x27;../config/router&#x27;Vue.use(VueRouter)const router = new VueRouter(&#123; routes: commonRouter, mode: &#x27;hash&#x27;, // default: hash ,history&#125;)export default router 3.项目中引入路由123456789// src/main.jsimport Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router/index&#x27;new Vue(&#123; router, render: h =&gt; h(App),&#125;).$mount(&#x27;#app&#x27;) 12345678910111213141516&#x2F;&#x2F; src&#x2F;App.vue&lt;template&gt; &lt;div&gt; &lt;router-view &#x2F;&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &#39;App&#39;, components: &#123; &#125;, mounted() &#123; &#125;&#125;&lt;&#x2F;script&gt;","categories":[],"tags":[{"name":"架构","slug":"架构","permalink":"https://wisiw.github.io.git/tags/%E6%9E%B6%E6%9E%84/"},{"name":"前端工程化","slug":"前端工程化","permalink":"https://wisiw.github.io.git/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}]},{"title":"【架构】前端工程化（一）业务模块拆分,独立成npm包","slug":"【架构】前端工程化（一）：业务模块拆分-独立成npm包","date":"2021-08-13T03:07:02.000Z","updated":"2021-08-13T03:42:44.221Z","comments":true,"path":"2021/08/13/【架构】前端工程化（一）：业务模块拆分-独立成npm包/","link":"","permalink":"https://wisiw.github.io.git/2021/08/13/%E3%80%90%E6%9E%B6%E6%9E%84%E3%80%91%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%B8%9A%E5%8A%A1%E6%A8%A1%E5%9D%97%E6%8B%86%E5%88%86-%E7%8B%AC%E7%AB%8B%E6%88%90npm%E5%8C%85/","excerpt":"","text":"1.构建业务模块npm包123mkdir module_vuecd module_vuenpm init -y 文件目录1234567├── packages│ └── alert│ ├── src│ │ └── main.vue│ └── index.js└── src └── index.js 模块 123456789101112131415161718&#x2F;&#x2F; packages&#x2F;alert&#x2F;src&#x2F;main.vue&lt;template&gt; &lt;div&gt;alert&lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; name: &quot;Alert&quot;, data() &#123; return &#123; &#125; &#125; &#125;&lt;&#x2F;script&gt;&lt;style scoped&gt;&lt;&#x2F;style&gt; 导出模块 12345678// packages/alert/index.jsimport Alert from &#x27;./src/main&#x27;;Alert.install = function(Vue) &#123; Vue.component(Alert.name, Alert);&#125;;export default Alert; VUE中注册模块组件 123456789101112131415161718192021222324// src/index.jsimport Alert from &#x27;../packages/alert/index.js&#x27;;const components = [ Alert];const install = function(Vue) &#123; components.forEach(component =&gt; &#123; Vue.component(component.name, component); &#125;);&#125;;/* istanbul ignore if */if (typeof window !== &#x27;undefined&#x27; &amp;&amp; window.Vue) &#123; install(window.Vue);&#125;export default &#123; version: &#x27;0.1.0&#x27;, install, Alert&#125;; 2.项目引用本地模块npm包2.1 webpack 4.X 开始，需要安装 webpack-cli 依赖1npm install webpack webpack-cli -g 2.2 如果未安装vue-cli，全局安装1npm install --global vue-cli 2.3 创建项目12vue create projectcd project 2.4 安装本地npm包1npm install &lt;package path&gt;&#x2F;module_vue 2.5 建立npm本地映射，此操作是为了方便开发1npm link module_vue 此操作可以将node_modules中的module_vue链接到本地module_vue，实时更新","categories":[],"tags":[{"name":"架构","slug":"架构","permalink":"https://wisiw.github.io.git/tags/%E6%9E%B6%E6%9E%84/"},{"name":"前端工程化","slug":"前端工程化","permalink":"https://wisiw.github.io.git/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}]},{"title":"【原理】响应式原理","slug":"【原理】响应式原理","date":"2021-08-11T06:12:09.000Z","updated":"2021-08-11T08:37:41.173Z","comments":true,"path":"2021/08/11/【原理】响应式原理/","link":"","permalink":"https://wisiw.github.io.git/2021/08/11/%E3%80%90%E5%8E%9F%E7%90%86%E3%80%91%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const data = &#123; price: 10, quantity: 2&#125;// 创建一个收集依赖项（依赖）并重新运行所有依赖项（通知）的Dep 类class Dep &#123; constructor () &#123; this.subscribers = [] &#125; depend () &#123; if (target &amp;&amp; !this.subscribers.includes(target)) &#123; this.subscribers.push(target) &#125; &#125; notify () &#123; this.subscribers.forEach(sub =&gt; sub()) &#125;&#125;// 使用Object.defineProperty()创建 getter 和 setterObject.keys(data).forEach( key =&gt; &#123; let internalValue = data[key] const dep = new Dep() Object.defineProperty( data, key, &#123; get () &#123; dep.depend() return internalValue &#125;, set (newV) &#123; internalValue = newV dep.notify() &#125; &#125;)&#125;)// 创建一个观察者来管理我们正在运行的代码，这可能需要作为依赖项添加（目标）function watcher(myFunc) &#123; target = myFunc target() target = null&#125;watcher(() =&gt; &#123; data.total = data.price * data.quantity&#125;)data.price = 20console.log(data.total)","categories":[],"tags":[{"name":"原理","slug":"原理","permalink":"https://wisiw.github.io.git/tags/%E5%8E%9F%E7%90%86/"},{"name":"响应式","slug":"响应式","permalink":"https://wisiw.github.io.git/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"}]},{"title":"【面试题】基础、业务、笔试","slug":"【面试题】基础、业务、笔试","date":"2021-08-09T08:02:48.000Z","updated":"2021-08-09T08:03:19.090Z","comments":true,"path":"2021/08/09/【面试题】基础、业务、笔试/","link":"","permalink":"https://wisiw.github.io.git/2021/08/09/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%91%E5%9F%BA%E7%A1%80%E3%80%81%E4%B8%9A%E5%8A%A1%E3%80%81%E7%AC%94%E8%AF%95/","excerpt":"","text":"面试题。 基础知识基础知识主要包含以下几个方面： 基础：计算机原理、编译原理、数据结构、算法、设计模式、编程范式等基本知识了解 语法：JavaScript、ECMAScript、CSS、TypeScript、HTML、Node.js 等语法的了解和使用 框架：React、Vue、Egg、Koa、Express、Webpack 等原理的了解和使用 工程：编译工具、格式工具、Git、NPM、单元测试、Nginx、PM2、CI / CD 了解和使用 网络：HTTP、TCP、UDP、WebSocket、Cookie、Session、跨域、缓存、协议的了解 性能：编译性能、监控、白屏检测、SEO、Service Worker 等了解 插件：Chrome 、Vue CLI 、Webpack 等插件设计思路的理解 系统：Mac、Windows、Linux 系统配置的实践 后端：Redis 缓存、数据库、Graphql、SSR、模板引擎等了解和使用 基础 列举你所了解的计算机存储设备类型？ 一般代码存储在计算机的哪个设备中？代码在 CPU 中是如何运行的？ 什么是指令和指令集？ 复杂指令集和精简指令集有什么区别？ JavaScript 是如何运行的？解释型语言和编译型语言的差异是什么？ 简单描述一下 Babel 的编译过程？ JavaScript 中的数组和函数在内存中是如何存储的？ 浏览器和 Node.js 中的事件循环机制有什么区别？ ES6 Modules 相对于 CommonJS 的优势是什么？ 高级程序设计语言是如何编译成机器语言的？ 编译器一般由哪几个阶段组成？数据类型检查一般在什么阶段进行？ 编译过程中虚拟机的作用是什么？ 什么是中间代码（IR），它的作用是什么？ 什么是交叉编译？ 发布 / 订阅模式和观察者模式的区别是什么？ 装饰器模式一般会在什么场合使用？ 谈谈你对大型项目的代码解耦设计理解？什么是 Ioc？一般 DI 采用什么设计模式实现？ 列举你所了解的编程范式？ 什么是面向切面（AOP）的编程？ 什么是函数式编程？什么是响应式编程？什么是函数响应式编程？ 响应式编程或者函数响应式编程的使用场景有哪些？ 语法 如何实现一个上中下三行布局，顶部和底部最小高度是 100px，中间自适应? 如何判断一个元素 CSS 样式溢出，从而可以选择性的加 title 或者 Tooltip? 如何让 CSS 元素左侧自动溢出（… 溢出在左侧）？ 什么是沙箱？浏览器的沙箱有什么作用？ 如何处理浏览器中表单项的密码自动填充问题？ Hash 和 History 路由的区别和优缺点？ JavaScript 中的 const 数组可以进行 push 操作吗？为什么？ JavaScript 中对象的属性描述符有哪些？分别有什么作用？ JavaScript 中 console 有哪些 api ? 简单对比一下 Callback、Promise、Generator、Async 几个异步 API 的优劣？ Object.defineProperty 有哪几个参数？各自都有什么作用？ Object.defineProperty 和 ES6 的 Proxy 有什么区别？ ES6 中 Symbol、Map、Decorator 的使用场景有哪些？或者你在哪些库的源码里见过这些 API 的使用？ 为什么要使用 TypeScript ? TypeScript 相对于 JavaScript 的优势是什么？ TypeScript 中 const 和 readonly 的区别？枚举和常量枚举的区别？接口和类型别名的区别？ TypeScript 中 any 类型的作用是什么？ TypeScript 中 any、never、unknown 和 void 有什么区别？ TypeScript 中 interface 可以给 Function / Array / Class（Indexable）做声明吗？ TypeScript 中可以使用 String、Number、Boolean、Symbol、Object 等给类型做声明吗？ TypeScript 中的 this 和 JavaScript 中的 this 有什么差异？ TypeScript 中使用 Unions 时有哪些注意事项？ TypeScript 如何设计 Class 的声明？ TypeScript 中如何联合枚举类型的 Key? TypeScript 中 ?.、??、!.、_、** 等符号的含义？ TypeScript 中预定义的有条件类型有哪些？ 简单介绍一下 TypeScript 模块的加载机制？ 简单聊聊你对 TypeScript 类型兼容性的理解？抗变、双变、协变和逆变的简单理解？ TypeScript 中对象展开会有什么副作用吗？ TypeScript 中 interface、type、enum 声明有作用域的功能吗？ TypeScript 中同名的 interface 或者同名的 interface 和 class 可以合并吗？ 如何使 TypeScript 项目引入并识别编译为 JavaScript 的 npm 库包？ TypeScript 的 tsconfig.json 中有哪些配置项信息？ TypeScript 中如何设置模块导入的路径别名？ 框架 React Class 组件有哪些周期函数？分别有什么作用？ React Class 组件中请求可以在 componentWillMount 中发起吗？为什么？ React Class 组件和 React Hook 的区别有哪些？ React 中高阶函数和自定义 Hook 的优缺点？ 简要说明 React Hook 中 useState 和 useEffect 的运行原理？ React 如何发现重渲染、什么原因容易造成重渲染、如何避免重渲染？ React Hook 中 useEffect 有哪些参数，如何检测数组依赖项的变化？ React 的 useEffect 是如何监听数组依赖项的变化的？ React Hook 和闭包有什么关联关系？ React 中 useState 是如何做数据初始化的？ 列举你常用的 React 性能优化技巧？ Vue 2.x 模板中的指令是如何解析实现的？ 简要说明 Vue 2.x 的全链路运作机制？ 简单介绍一下 Element UI 的框架设计？ 如何理解 Vue 是一个渐进式框架？ Vue 里实现跨组件通信的方式有哪些？ Vue 中响应式数据是如何做到对某个对象的深层次属性的监听的？ MVVM、MVC 和 MVP 的区别是什么？各自有什么应用场景？、 什么是 MVVM 框架？ 工程 Vue CLI 3.x 有哪些功能？Vue CLI 3.x 的插件系统了解？ Vue CLI 3.x 中的 Webpack 是如何组装处理的？ Vue 2.x 如何支持 TypeScript 语法？ 如何配置环境使得 JavaScript 项目可以支持 TypeScript 语法？ 如何对 TypeScript 进行 Lint 校验？ESLint 和 TSLint 有什么区别？ Node.js 如何支持 TypeScript 语法？ TypeScript 如何自动生成库包的声明文件？ Babel 对于 TypeScript 的支持有哪些限制？ Webpack 中 Loader 和 Plugin 的区别是什么？ 在 Webpack 中是如何做到支持类似于 JSX 语法的 Sourcemap 定位？ 发布 Npm 包如何指定引入地址？ 如何发布开发项目的特定文件夹为 Npm 包的根目录？ 如何发布一个支持 Tree Shaking 机制的 Npm 包？ Npm 包中 peerDependencies 的作用是什么？ 如何优雅的调试需要发布的 Npm 包？ 在设计一些库包时如何生成版本日志？ 了解 Git （Submodule）子模块吗？简单介绍一下 Git 子模块的作用？ Git 如何修改已经提交的 Commit 信息？ Git 如何撤销 Commit 并保存之前的修改？ Git 如何 ignore 被 commit 过的文件？ 在使用 Git 的时候如何规范 Git 的提交说明（Commit 信息）？ 简述符合 Angular 规范的提交说明的结构组成？ Commit 信息如何和 Github Issues 关联？ Git Hook 在项目中哪些作用？ Git Hook 中客户端和服务端钩子各自用于什么作用？ Git Hook 中常用的钩子有哪些？ pre-commit 和 commit-msg 钩子的区别是什么？各自可用于做什么？ husky 以及 ghook 等工具制作 Git Hook 的原理是什么？ 如何设计一个通用的 Git Hook ？ Git Hook 可以采用 Node 脚本进行设计吗？如何做到？ 如何确保别人上传的代码没有 Lint 错误？如何确保代码构建没有 Lint 错误？ 如何在 Vs Code 中进行 Lint 校验提示？如何在 Vs Code 中进行 Lint 保存格式化？ ESLint 和 Prettier 的区别是什么？两者在一起工作时会产生问题吗？ 如何有效的识别 ESLint 和 Prettier 可能产生冲突的格式规则？如何解决此类规则冲突问题？ 在通常的脚手架项目中进行热更新（hot module replacement）时如何做到 ESLint 实时打印校验错误信息？ 谈谈你对 SourceMap 的了解？ 如何调试 Node.js 代码？如何调试 Node.js TypeScript 代码？在浏览器中如何调试 Node.js 代码？ 列举你知道的所有构建工具并说说这些工具的优缺点？这些构建工具在不同的场景下应该如何选型？ VS Code 配置中的用户和工作区有什么区别？ VS Code 的插件可以只对当前项目生效吗？ 你所知道的测试有哪些测试类型？ 你所知道的测试框架有哪些？ 什么是 e2e 测试？有哪些 e2e 的测试框架？ 假设现在有一个插入排序算法，如何对该算法进行单元测试？ 网络 CDN 服务如何实现网络加速？ WebSocket 使用的是 TCP 还是 UDP 协议？ 什么是单工、半双工和全双工通信？ 简单描述 HTTP 协议发送一个带域名的 URL 请求的协议传输过程？（DNS、TCP、IP、链路） 什么是正向代理？什么是反向代理？ Cookie 可以在服务端生成吗？Cookie 在服务端生成后的工作流程是什么样的？ Session、Cookie 的区别和关联？如何进行临时性和永久性的 Session 存储？ 设置 Cookie 时候如何防止 XSS 攻击？ 简单描述一下用户免登陆的实现过程？可能会出现哪些安全性问题？一般如何对用户登录的密码进行加密？ HTTP 中提升传输速率的方式有哪些？常用的内容编码方式有哪些？ 传输图片的过程中如果突然中断，如何在恢复后从之前的中断中恢复传输？ 什么是代理？什么是网关？代理和网关的作用是什么？ HTTPS 相比 HTTP 为什么更加安全可靠？ 什么是对称密钥（共享密钥）加密？什么是非对称密钥（公开密钥）加密？哪个更加安全？ 你觉得 HTTP 协议目前存在哪些缺点？ 性能 在 React 中如何识别一个表单项里的表单做到了最小粒度 / 代价的渲染？ 在 React 的开发的过程中你能想到哪些控制渲染成本的方法？ 插件 Vue CLI 3.x 的插件系统是如何设计的？ Webpack 中的插件机制是如何设计的？ 系统 \\r\\n（CRLF） 和 \\n （LF）的区别是什么？(Vs Code 的右下角可以切换) /dev/null 的作用是啥？ 如何在 Mac 的终端中设置一个命令的别名？ 如何在 Windows 中设置环境变量？ Mac 的文件操作系统默认区分文件路径的大小写吗？ 编写 Shell 脚本时如何设置文件的绝对路径？ 后端 Session、Cookie 的区别和关联？如何进行临时性和永久性的 Session 存储？ 如何部署 Node.js 应用？如何处理负载均衡中 Session 的一致性问题？ 如何提升 Node.js 代码的运行稳定性？ GraphQL 与 Restful 的区别，它有什么优点？ Vue SSR 的工作原理？Vuex 的数据如何同构渲染？ SSR 技术和 SPA 技术的各自的优缺点是什么？ 如何处理 Node.js 渲染 HTML 压力过大问题？ 业务思考业务思考更多的是结合基础知识的广度和深度进行的具体业务实践，主要包含以下几个方面： 工程化：代码部署、CI / CD 流程设计、Jenkins、Gitlab、Docker 等 通用性：脚手架、SDK、组件库等框架设计 应用框架：Hybrid 混合、微前端、BFF、Monorepo 可视化： 低代码：通用表单设计、通用布局设计、通用页面设计、JSON Schema 协议设计等 测试：E2E 测试、单元测试、测试覆盖率、测试报告等 业务：数据、体验、复杂度、监控 工程化 你所知道的 CI / CD 工具有哪些？在项目中有接触过类似的流程吗？ 如果让你实现一个 Web 前端的 CI / CD 工程研发平台，你会如何设计？ 如果我们需要将已有项目中的线上产物资源（例如图片）转换成本地私有化资源，你有什么解决方案？ 如何使用 Vue CLI 3.x 定制一个脚手架？比如内部自动集成了 i18n、 axios、Element UI、路由守卫等？ Jenkins 如何配合 Node.js 脚本进行 CI / CD 设计？ 通用性 如果让你设计一个通用的项目脚手架，你会如何设计？一个通用的脚手架一般需要具备哪些能力？ 如果让你设计一个通用的工具库，你会如何设计？一个通用的工具库一般需要具备哪些能力？ 假设你自己实现的 React 或 Vue 的组件库要设计演示文档，你会如何设计？设计的文档需要实现哪些功能？ 在设计工具库包的时候你是如何设计 API 文档的？ 应用框架 谈谈 Electron、Nw.js、CEF、Flutter 和原生开发的理解？ 谈谈桌面端应用中 HotFix 的理解？ 你觉得什么样的场景需要使用微前端框架？ 业务 什么是单点登录？如何做单点登录？ 如何做一个项目的国际化方案？ 如何做一个项目的监控和埋点方案？ 如何建设项目的稳定性（监控、灰度、错误降级、回滚…）？ 一般管理后台型的应用需要考虑哪些性能方面的优化？ 简述一些提升项目体验的案例和技术方案（骨架屏、Loading 处理、缓存、错误降级、请求重试…）？ 假设需要对页面设计一个水印方案，你会如何设计？ 低代码 如何设计一个通用的 JSON Schema 协议使其可以动态渲染一个通用的联动表单？ 一般的低代码平台需要具备哪些能力？ 笔试实践笔试更多的是考验应聘者的逻辑思维能力和代码书写风格，主要包含以下几个方面： 正则表达式 算法 数据结构 设计模式 框架的部分原理实现 TypeScript 语法 模板解析 数据结构 使用 TypeScript 语法将没有层级的扁平数据转换成树形结构的数据 12345678910111213141516171819202122232425262728&#x2F;&#x2F; 扁平数据[&#123; name: &#39;文本1&#39;, parent: null, id: 1,&#125;, &#123; name: &#39;文本2&#39;, id: 2, parent: 1&#125;, &#123; name: &#39;文本3&#39;, parent: 2, id: 3,&#125;]&#x2F;&#x2F; 树状数据[&#123; name: &#39;文本1&#39;, id: 1, children: [&#123; name: &#39;文本2&#39;, id: 2, children: [&#123; name: &#39;文本3&#39;, id: 3 &#125;] &#125;]&#125;] 模板解析 实现一个简易的模板引擎 1234567891011121314const template &#x3D; &#39;嗨，&#123;&#123; info.name.value &#125;&#125;您好，今天是星期 &#123;&#123; day.value &#125;&#125;&#39;;const data &#x3D; &#123; info: &#123; name: &#123; value: &#39;张三&#39; &#125; &#125;, day: &#123; value: &#39;三&#39; &#125;&#125;;render(template, data); &#x2F;&#x2F; 嗨，张三您好，今天是星期三 设计模式 简单实现一个发布 / 订阅模式 正则表达式 匹配出字符串中 const a = require(‘xxx’) 中的 xxx","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://wisiw.github.io.git/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"【Vue】全局引入组件，挂载在原型链上","slug":"【Vue】全局引入组件，挂载在原型链上","date":"2021-08-04T15:44:01.000Z","updated":"2021-09-23T05:54:13.551Z","comments":true,"path":"2021/08/04/【Vue】全局引入组件，挂载在原型链上/","link":"","permalink":"https://wisiw.github.io.git/2021/08/04/%E3%80%90Vue%E3%80%91%E5%85%A8%E5%B1%80%E5%BC%95%E5%85%A5%E7%BB%84%E4%BB%B6%EF%BC%8C%E6%8C%82%E8%BD%BD%E5%9C%A8%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8A/","excerpt":"","text":"","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://wisiw.github.io.git/tags/Vue/"},{"name":"全局弹窗","slug":"全局弹窗","permalink":"https://wisiw.github.io.git/tags/%E5%85%A8%E5%B1%80%E5%BC%B9%E7%AA%97/"}]},{"title":"【Node】npm库","slug":"【Node】npm库","date":"2021-08-04T03:32:47.000Z","updated":"2021-09-23T05:56:50.248Z","comments":true,"path":"2021/08/04/【Node】npm库/","link":"","permalink":"https://wisiw.github.io.git/2021/08/04/%E3%80%90Node%E3%80%91npm%E5%BA%93/","excerpt":"","text":"oraElegant terminal spinner 1github.com/sindresorhus/ora chalkTerminal string styling done right 1https://github.com/chalk/chalk octokitThe all-batteries-included GitHub SDK for Browsers, Node.js, and Deno. 1https://github.com/octokit/octokit.js @octokit/coreExtendable client for GitHub’s REST &amp; GraphQL APIs 1https://github.com/octokit/core.js options name type description options.authStrategy Function Defaults to @octokit/auth-token. See Authentication below for examples. options.auth String or Object See Authentication below for examples. options.baseUrl String When using with GitHub Enterprise Server, set options.baseUrl to the root URL of the API. For example, if your GitHub Enterprise Server’s hostname is github.acme-inc.com, then set options.baseUrl to https://github.acme-inc.com/api/v3. Exampleconst octokit = new Octokit(&#123; baseUrl: &quot;https://github.acme-inc.com/api/v3&quot;, &#125;); options.previews Array of Strings Some REST API endpoints require preview headers to be set, or enable additional features. Preview headers can be set on a per-request basis, e.g.octokit.request(&quot;POST /repos/&#123;owner&#125;/&#123;repo&#125;/pulls&quot;, &#123; mediaType: &#123; previews: [&quot;shadow-cat&quot;], &#125;, owner, repo, title: &quot;My pull request&quot;, base: &quot;master&quot;, head: &quot;my-feature&quot;, draft: true, &#125;);You can also set previews globally, by setting the options.previews option on the constructor. Example:const octokit = new Octokit(&#123; previews: [&quot;shadow-cat&quot;], &#125;); options.request Object Set a default request timeout (options.request.timeout) or an http(s).Agent e.g. for proxy usage (Node only, options.request.agent).There are more options.request.* options, see @octokit/request options. options.request can also be set on a per-request basis. options.timeZone String Sets the Time-Zone header which defines a timezone according to the list of names from the Olson database.const octokit = new Octokit(&#123; timeZone: &quot;America/Los_Angeles&quot;, &#125;);The time zone header will determine the timezone used for generating the timestamp when creating commits. See GitHub’s Timezones documentation. options.userAgent String A custom user agent string for your app or library. Exampleconst octokit = new Octokit(&#123; userAgent: &quot;my-app/v1.2.3&quot;, &#125;); octokat1https://github.com/philschatz/octokat.js","categories":[],"tags":[{"name":"Node","slug":"Node","permalink":"https://wisiw.github.io.git/tags/Node/"},{"name":"npm","slug":"npm","permalink":"https://wisiw.github.io.git/tags/npm/"}]},{"title":"【读书笔记】数据结构与抽象 java语言描述-第二章使用链式数据实现包","slug":"【读书笔记】数据结构与抽象-java语言描述-第三章使用链式数据实现包","date":"2021-07-06T05:58:35.000Z","updated":"2021-07-06T05:59:01.073Z","comments":true,"path":"2021/07/06/【读书笔记】数据结构与抽象-java语言描述-第三章使用链式数据实现包/","link":"","permalink":"https://wisiw.github.io.git/2021/07/06/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E6%8A%BD%E8%B1%A1-java%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0%E4%BD%BF%E7%94%A8%E9%93%BE%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%AE%9E%E7%8E%B0%E5%8C%85/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"【读书笔记】数据结构与抽象 java语言描述-第二章使用数组实现包","slug":"【读书笔记】数据结构与抽象-java语言描述-第二章使用数组实现包","date":"2021-07-06T05:53:21.000Z","updated":"2021-07-06T05:59:44.479Z","comments":true,"path":"2021/07/06/【读书笔记】数据结构与抽象-java语言描述-第二章使用数组实现包/","link":"","permalink":"https://wisiw.github.io.git/2021/07/06/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E6%8A%BD%E8%B1%A1-java%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%8C%85/","excerpt":"","text":"使用固定大小的数组实现ADT包类比一组核心方法实现核心方法让实现安全测试核心方法实现更多的方法删除项的方法使用可变大小的数组实现ADT包可变大小数组包的新实现使用数组实现ADT包的优缺点","categories":[],"tags":[{"name":"数据、算法","slug":"数据、算法","permalink":"https://wisiw.github.io.git/tags/%E6%95%B0%E6%8D%AE%E3%80%81%E7%AE%97%E6%B3%95/"},{"name":"数组实现包","slug":"数组实现包","permalink":"https://wisiw.github.io.git/tags/%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%8C%85/"}]},{"title":"【读书笔记】数据结构与抽象 java语言描述","slug":"【读书笔记】数据结构与抽象-java语言描述","date":"2021-07-05T06:00:12.000Z","updated":"2021-07-06T05:43:17.933Z","comments":true,"path":"2021/07/05/【读书笔记】数据结构与抽象-java语言描述/","link":"","permalink":"https://wisiw.github.io.git/2021/07/05/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E6%8A%BD%E8%B1%A1-java%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0/","excerpt":"","text":"封装 封装：常常被称为信息隐藏。将数据和方法放在一个类中，隐藏了使用类时不需要的实现细节 抽象：是一个要求你关注什么而不是如何的过程。当设计类的时候，执行数据抽象 正确的封装将类定义为两部分：客户接口和实现 ​ 客户接口描述程序员使用这个类时必须了解的一切事情。包括类的公有方法的方法头、注释（告诉程序员如何使用这些公有方法）、以及类中公有定义的任何常量 ​ 实现部分有所有的数据域及所有方法的定义组成，包括公有、私有及保护的方法 说明方法 注释： 前置条件和后置条件 ​ 前置条件：是一条条件语句，在方法执行前必须为真。除非前置条件满足，否则不应该使用方法，也不能期待方法能正确执行 ​ 后置条件：是一条语句，当前置条件满足且完全执行方法后，它为真。一般来说，后置条件描述方法调用产生的所有影响 ​ 对于一个值方法，后置条件将描述方法返回的值 ​ 对于一个void方法，后置条件描述所做的动作及调用对象的任何修改 ​ 职责 说明一个包，使用UML进行表示 123456789+getCurrentSize(): integer+isEmpty(): boolean+add(newEntry: T): boolean+clear(): void+remove(): T+remove(anEntry T): T+getFrequencyOf(anEntry: T): integer+contains(anEntry: T): boolean+toArray(): T[] 包类的java接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * An interface that describes the operations of a bag of objects */public interface BagInterface&lt;T&gt; &#123; /** * Gets the current number of entries in this bag. * @return The integer number of entries currently in the bag. */ public int getCurrentSize(); /** * Sees whether this bag is empty. * @return true if the bag is empty, or false if not. */ public boolean isEmpty(); /** * Adds a new entry to this bag. * @param newEntry The objects to be added as a new entry * @return True if the addition is successful, or false if not. */ public boolean add(T newEntry); /** * Removes all entries from this bag. */ public void clear(); /** * Removes one unspecified entry from this bag, if possible. * @return Either the removed entry, if the removal was successful, or null. */ public T remove(); /** * Remove one occurrence of a given entry from this bag, if possible. * @param anEntry The entry to be removed. * @return True if the removal was successful, or false if not. */ public T remove(T anEntry); /** * Counts the number of times a given entry appears in this bag. * @param anEntry The entry to be counted. * @return The number of times anEntry appears in the bag. */ public int getFrequencyOf(T anEntry); /** * Tests whether this bag contains a given entry * @param anEntry The entry to locate. * @return True if the bag contains an Entry, or false if not. */ public boolean contains(T anEntry); /** * Retrieves all entries that are in this bag * @return A newly allocated array of all the entries in the bag. Note: If the bag is empty, the returned array is empty. */ public T[] toArray();&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://wisiw.github.io.git/tags/Java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://wisiw.github.io.git/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"数据结构","slug":"数据结构","permalink":"https://wisiw.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"【JavaScript】技巧","slug":"【JavaScript】技巧","date":"2021-07-05T02:01:45.000Z","updated":"2021-09-23T05:59:00.203Z","comments":true,"path":"2021/07/05/【JavaScript】技巧/","link":"","permalink":"https://wisiw.github.io.git/2021/07/05/%E3%80%90JavaScript%E3%80%91%E6%8A%80%E5%B7%A7/","excerpt":"","text":"1.多个条件判断的if语句，使用includes在数组中存储需要判断的值，使用数组的includes方法 123456if( x === &#x27;abc&#x27; || x === &#x27;def&#x27; || x === &#x27;ghi&#x27;) &#123; &#125;if([&#x27;abc&#x27;, &#x27;def&#x27;, &#x27;ghi&#x27;].includes(x)) &#123; &#125; 2.if…else使用三元表达式if…else的逻辑判断较为简单的时候，使用三元判断","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wisiw.github.io.git/tags/JavaScript/"},{"name":"技巧","slug":"技巧","permalink":"https://wisiw.github.io.git/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"【代码片段】日常积累","slug":"【代码片段】日常积累","date":"2021-06-25T05:42:05.000Z","updated":"2021-09-23T06:08:06.740Z","comments":true,"path":"2021/06/25/【代码片段】日常积累/","link":"","permalink":"https://wisiw.github.io.git/2021/06/25/%E3%80%90%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E3%80%91%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/","excerpt":"","text":"平时写的方法或样式，待分类整理 1.微信分享功能1-1.uni中使用manifest.json中勾选 123456789101112uni.share(&#123; provider: &#x27;&#x27;, // 分享服务供应商（weixin|qq|sinaweibo） scene: scene, // 分享形式 type: type, href: &#x27;&#x27;, title: title, imageUrl: this.shareObj.imageUrl, summary: this.shareObj.summary, success(res) &#123;&#125;, fail(&#123;errMsg&#125;) &#123;&#125;, complete(res) &#123;&#125;&#125;) 1-2.summary分行功能：1234// 使用\\r\\n换行&#123; summary: `第一行\\r\\n第二行`&#125; 1-3.iOS分享图片过大，将图片压缩123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869toShare(&#123; provider, scene, type &#125;) &#123; let href = &#x27;&#x27; let that = this; const &#123; href, title, imageUrl, summary &#125; = this.shareObj //获取图片后压缩 uni.downloadFile(&#123; url: imageUrl, success: function(images) &#123; that.compress(images.tempFilePath, (img) =&gt; &#123; that.share(provider, scene, type, href, title, img, summary) &#125;) &#125;, fail(error) &#123; uni.hideLoading(); &#125; &#125;)&#125;,compress(img, cb) &#123; plus.io.resolveLocalFileSystemURL(img, (entry) =&gt; &#123; entry.file((file) =&gt; &#123; console.log(&#x27;压缩前图片信息:&#x27; + JSON.stringify(file)); //压缩前图片信息 // 如果大于20Kb进行压缩 if(file.size &gt; 20000) &#123; plus.zip.compressImage(&#123; src: img, dst: img.replace(&#x27;.png&#x27;, &#x27;_s.png&#x27;).replace(&#x27;.PNG&#x27;, &#x27;_s.PNG&#x27;).replace(&#x27;.jpg&#x27;,&#x27;_s.jpg&#x27;).replace(&#x27;.JPG&#x27;,&#x27;_s.JPG&#x27;), width: &#x27;40%&#x27;, height: &#x27;40%&#x27;, quality: 10, overwrite: true, format: &#x27;jpg&#x27; &#125;, (event) =&gt; &#123; console.log(&#x27;压缩后图片信息:&#x27; + JSON.stringify(event)); cb &amp;&amp; cb(event.target); &#125;, function(err) &#123; console.log(&#x27;Resolve file URL failed: &#x27; + err.message); &#125;); &#125;else&#123; //else小于20kb跳过压缩，直接返回现有的src cb &amp;&amp; cb(img); &#125; &#125;); &#125;, (e) =&gt; &#123; // 返回错误信息 console.log(&#x27;Resolve file URL failed: &#x27; + e.message); &#125;);&#125;,share(provider, scene, type, href, title, img, summary) &#123; uni.share(&#123; provider: provider, scene: scene, type: type, href: href, title: title, imageUrl: img, summary: summary, success(res) &#123; console.log(res) &#125;, fail(&#123;errMsg&#125;) &#123; this.$refs.uToast.show(&#123; title: &#x27;请安装微信客户端&#x27;, type: &#x27;warning&#x27; &#125;) &#125;, complete(res) &#123; console.log(res) &#125; &#125;)&#125; 2.apple支付123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;script&gt; let iapChannel = null, productId = &#x27;HelloUniappPayment1&#x27;, productIds = [&#x27;HelloUniappPayment1&#x27;, &#x27;HelloUniappPayment6&#x27;]; export default &#123; data() &#123; return &#123; title: &#x27;request-payment&#x27;, loading: false, disabled: true, priceList: [&#123; value: &#x27;HelloUniappPayment1&#x27;, text: &#x27;支付1元&#x27;, checked: true &#125;, &#123; value: &#x27;HelloUniappPayment6&#x27;, text: &#x27;支付6元&#x27;, checked: false &#125;] &#125; &#125;, onLoad: function() &#123; plus.payment.getChannels((channels) =&gt; &#123; console.log(&quot;获取到channel&quot; + JSON.stringify(channels)) for (var i in channels) &#123; var channel = channels[i]; if (channel.id === &#x27;appleiap&#x27;) &#123; iapChannel = channel; this.requestOrder(); &#125; &#125; if(!iapChannel)&#123; this.errorMsg() &#125; &#125;, (error) =&gt; &#123; this.errorMsg() &#125;); &#125;, methods: &#123; requestOrder() &#123; uni.showLoading(&#123; title:&#x27;检测支付环境...&#x27; &#125;) iapChannel.requestOrder(productIds, (orderList) =&gt; &#123; //必须调用此方法才能进行 iap 支付 this.disabled = false; console.log(&#x27;requestOrder success666: &#x27; + JSON.stringify(orderList)); uni.hideLoading(); &#125;, (e) =&gt; &#123; console.log(&#x27;requestOrder failed: &#x27; + JSON.stringify(e)); uni.hideLoading(); this.errorMsg() &#125;); &#125;, requestPayment(e) &#123; this.loading = true; uni.requestPayment(&#123; provider: &#x27;appleiap&#x27;, orderInfo: &#123; productid: productId &#125;, success: (e) =&gt; &#123; uni.showModal(&#123; content: &quot;感谢您的赞助&quot;, showCancel: false &#125;) &#125;, fail: (e) =&gt; &#123; uni.showModal(&#123; content: &quot;支付失败,原因为: &quot; + e.errMsg, showCancel: false &#125;) &#125;, complete: () =&gt; &#123; console.log(&quot;payment结束&quot;) this.loading = false; &#125; &#125;) &#125;, applePriceChange(e) &#123; productId = e.detail.value; &#125;, errorMsg()&#123; uni.showModal(&#123; content: &quot;暂不支持苹果 iap 支付&quot;, showCancel: false &#125;) &#125; &#125; &#125;&lt;/script&gt; productId需要去https://appstoreconnect.apple.com/配置内购id 2.webpack2.1为什么开发时webpack生成很慢因为loader中使用this.callback与webpack通信 12345678910this.callback( // 当无法转换原 内容时，为 Webpa ck 返回一个 Error err: Error I null, // 原内容转换后的内容 content: string I Buffer, // 用于通过转换后的 内容得出原内容的 Source Map ，以方便调试 sourceMap?: SourceMap, // 如果本次转换为原 内容生成了 AST 语法树，则可以将这个 AST 返回，以方便之后需要 AST Loader 复用该 AST ，避免重复生成 AST ，提升性能 abstractSyntaxTree?: AST); Source Map的生成很耗时，通常只有在开发环境下才会生成Source Map，在其他环境下不生成，以加速构建。因此webpack为loader提供了this.sourceMap以用来判断当前构建环境下的用户是否需要生成Source Map。 2.文件下载时或responseType:Blob时，如果返回json中携带错误信息，如何在error中获取？2.1Why接口返回了正常的错误对象，包含错误码和错误信息，但是因为是blob数据类型，无法获取 1234Blob &#123; size: 17, type: &quot;application/json&quot;&#125; 需要转化为json格式 1234567891011let &#123; data &#125; = errorconst reader = new FileReader()reader.onload = funtion() &#123; try &#123; let result = JSON.parse(this.result) &#125;catch (error) &#123; // 解析不成功，说明是正常的文件，下载 ... &#125;&#125;reader.readAsText(data) // 解析返回结果 监听DOM内容变化使用MutationObserver 1234567const observer = new MutationObserver(this.update);// 监听此组件的变化observer.observe([el], &#123; childList: true, subtree: true&#125;) vue限定prop类型123456789101112export default &#123; name: &#x27;Image&#x27;, props: &#123; src: &#123; type: String, &#125;, style: &#123; type: String, validator: s =&gt; [&#x27;square&#x27;, &#x27;rounded&#x27;].includes(s) &#125; &#125;&#125;;","categories":[],"tags":[{"name":"代码片段","slug":"代码片段","permalink":"https://wisiw.github.io.git/tags/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"}]},{"title":"【Java】MyBatis-Plus实现curd操作","slug":"【Java】MyBatis-Plus实现curd操作","date":"2021-04-11T10:47:23.000Z","updated":"2021-09-23T06:00:08.991Z","comments":true,"path":"2021/04/11/【Java】MyBatis-Plus实现curd操作/","link":"","permalink":"https://wisiw.github.io.git/2021/04/11/%E3%80%90Java%E3%80%91MyBatis-Plus%E5%AE%9E%E7%8E%B0curd%E6%93%8D%E4%BD%9C/","excerpt":"","text":"1.MyBatis-Plus是什么是MyBatis的增强工具，在MyBatis的基础上只做增强，不做改变，为简化开发、提高效率而生 2.实现增删改查3.自动填充乐观锁4.逻辑删除#5.分页查询 ​","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://wisiw.github.io.git/tags/Java/"},{"name":"数据库","slug":"数据库","permalink":"https://wisiw.github.io.git/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MyBatis-Plus","slug":"MyBatis-Plus","permalink":"https://wisiw.github.io.git/tags/MyBatis-Plus/"}]},{"title":"操作系统","slug":"操作系统","date":"2021-03-21T12:52:58.000Z","updated":"2021-06-21T08:13:20.417Z","comments":true,"path":"2021/03/21/操作系统/","link":"","permalink":"https://wisiw.github.io.git/2021/03/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"操作系统的类型和结构类型 类型 分类 描述 特征 批处理操作系统 联级批处理、脱机批处理 把用户提交的作业分类，把一批中的作业编成一个作业执行序列 用户脱机使用计算机、成批处理、多道程序运行 分时操作系统 采用分时技术，使多个用户同时以会话方式控制自己程序的运行，每个用户都感到似乎有一台独立的、支持自己请求服务的系统。 交互性、多用户同时性、独立性 分时技术把处理机的运行时间分成很短的时间片，按时间片轮流把处理机分配给各联机作业使用。若某个作业在分配给他的时间片内不能完成其计算，则该作业暂时中断，把处理器让给另一作业使用，等下一轮时再继续运行 实时操作系统 实时过程控制、实时信息处理 往往是专用的，系统与应用很难分离，常常紧密结合在一起。实时系统并不强调资源利用率，而更关心及时性（时间紧迫性）、可靠性和完整性 提供即时响应、高可靠性 网络操作系统 分布式操作系统 要求有一个统一的操作系统，实现系统操作的统一性，负责全系统的资源分配和调度，为用户提供统一的界面 结构处理器管理进程的状态信号量与PV操作死锁问题管程与进程文件管理文件的逻辑组织文件的物理组织树形目录结构##存储空间的管理 存储管理地址变换存储组织##存储管理 作业管理作业状态##作业调度 设备管理数据传输控制方式磁盘调度算法##虚设备与SPOOLing技术 网络操作系统网络操作系统概述##网络操作系统的组成 #例题","categories":[],"tags":[{"name":"系统架构设计师考试","slug":"系统架构设计师考试","permalink":"https://wisiw.github.io.git/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%80%83%E8%AF%95/"},{"name":"第一章","slug":"第一章","permalink":"https://wisiw.github.io.git/tags/%E7%AC%AC%E4%B8%80%E7%AB%A0/"}]},{"title":"【面试题】CSS","slug":"【面试题】CSS","date":"2021-02-23T02:28:03.000Z","updated":"2021-09-23T05:43:50.832Z","comments":true,"path":"2021/02/23/【面试题】CSS/","link":"","permalink":"https://wisiw.github.io.git/2021/02/23/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%91CSS/","excerpt":"","text":"","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://wisiw.github.io.git/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"CSS","slug":"CSS","permalink":"https://wisiw.github.io.git/tags/CSS/"}]},{"title":"【面试题】vuex","slug":"【面试题】vuex","date":"2021-02-21T14:04:33.000Z","updated":"2021-09-23T04:00:04.457Z","comments":true,"path":"2021/02/21/【面试题】vuex/","link":"","permalink":"https://wisiw.github.io.git/2021/02/21/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%91vuex/","excerpt":"","text":"vuex是什么？怎么使用？哪种功能场景使用它？是专门为vue开发的状态管理模式 采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一直能够可预测的方式发生变化 解决多个组件共享状态或来自不同组件的行为需要变更同一状态：音乐播放、登录状态、购物车 vuex 的 store 特性是什么 vuex 就是一个仓库，仓库里放了很多对象。其中 state 就是数据源存放地，对应于一般 vue 对象里面的 data state 里面存放的数据是响应式的，vue 组件从 store 读取数据，若是 store 中的数据发生改变，依赖这相数据的组件也会发生更新 它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性 Vuex中状态是对象时，使用时要注意什么？因为对象是引用类型，复制后改变属性还是会影响原始数据，这样会改变state里面的状态，是不允许，所以先用深度克隆复制对象，再修改。 怎么在组件中批量使用Vuex的state状态？使用mapState辅助函数, 利用对象展开运算符将state混入computed对象中 123456import &#123;mapState&#125; from &#x27;vuex&#x27;export default&#123; computed:&#123; ...mapState([&#x27;price&#x27;,&#x27;number&#x27;]) &#125;&#125; Vuex中要从state派生一些状态出来，且多个组件使用它，该怎么做？使用getter属性，相当Vue中的计算属性computed，只有原状态改变派生状态才会改变。 getter接收两个参数，第一个是state，第二个是getters(可以用来访问其他getter)。 123456789101112131415const store = new Vuex.Store(&#123; state: &#123; price: 10, number: 10, discount: 0.7, &#125;, getters: &#123; total: state =&gt; &#123; return state.price * state.number &#125;, discountTotal: (state, getters) =&gt; &#123; return state.discount * getters.total &#125; &#125;,&#125;); 然后在组件中可以用计算属性computed通过this.$store.getters.total这样来访问这些派生转态。 12345678computed: &#123; total() &#123; return this.$store.getters.total &#125;, discountTotal() &#123; return this.$store.getters.discountTotal &#125;&#125; 怎么通过getter来实现在组件内可以通过特定条件来获取state的状态？通过让getter返回一个函数，来实现给getter传参。然后通过参数来进行判断从而获取state中满足要求的状态。 12345678910111213const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: &#x27;...&#x27;, done: true &#125;, &#123; id: 2, text: &#x27;...&#x27;, done: false &#125; ] &#125;, getters: &#123; getTodoById: (state) =&gt; (id) =&gt;&#123; return state.todos.find(todo =&gt; todo.id === id) &#125; &#125;,&#125;); 然后在组件中可以用计算属性computed通过this.$store.getters.getTodoById(2)这样来访问这些派生转态。 12345678computed: &#123; getTodoById() &#123; return this.$store.getters.getTodoById &#125;,&#125;mounted()&#123; console.log(this.getTodoById(2).done)//false&#125; vuex有哪几种属性State , Getter , Mutation , Action , Module (就是mapAction) state：vuex的基本数据，用来存储变量 geeter： ​ (1) getter 可以对 state 进行计算操作，它就是 store 的计算属性 (2) 虽然在组件内也可以做计算属性，但是 getters 可以在多给件之间复用 (3) 如果一个状态只在一个组件内使用，是可以不用 getters mutation：提交更新数据的方法，必须是同步的(如果需要异步使用action)。每个mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数，提交载荷作为第二个参数。 action：和mutation的功能大致相同，不同之处在于 ==》 1. Action 提交的是 mutation，而不是直接变更状态。 2. Action 可以包含任意异步操作。 modules：模块化vuex，可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理。 Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？ 单独组件使用，放在methods中 多组件复用，放在action中，包装成promise返回，在调用处用async await返回 不用 vuex 会带来什么问题 可维护性会下降，你要修改数据，你得维护3个地方 可读性下降，因为一个组件里的数据，你根本就看不出来是从哪里来的 增加耦合，大量的上传派发，会让耦合性大大的增加，本来Vue用Component就是为了减少耦合，现在这么用，和组件化的初衷相背 vuex一个例子方法vuex中如何异步修改状态123456789this.$store.dispatch(&#x27;mutations方法名&#x27;,值)const actions =&#123; asyncIncre(&#123;commit,dispatch&#125;,payload)&#123; setTimeout(()=&gt;&#123; commit(&#x27;minus&#x27;,payload) &#125;) &#125;&#125; vuex中actions和mutations的区别Mutation 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数 1234567891011const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, mutations: &#123; increment (state) &#123; // 变更状态 state.count++ &#125; &#125;&#125;) Action Action 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 . 123456789101112131415const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; increment (context) &#123; context.commit(&#x27;increment&#x27;) &#125; &#125;&#125;) 怎么在组件中批量使用Vuex的getter属性使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中 123456import &#123;mapGetters&#125; from &#x27;vuex&#x27;export default&#123; computed:&#123; ...mapGetters([&#x27;total&#x27;,&#x27;discountTotal&#x27;]) &#125;&#125; 怎么在组件中批量给Vuex的getter属性取别名并使用使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中 123456789import &#123;mapGetters&#125; from &#x27;vuex&#x27;export default&#123; computed:&#123; ...mapGetters(&#123; myTotal:&#x27;total&#x27;, myDiscountTotal:&#x27;discountTotal&#x27;, &#125;) &#125;&#125; 在Vuex中使用mutation要注意什么。mutation 必须是同步函数 Vuex中action和mutation有什么区别？action 提交的是 mutation，而不是直接变更状态。mutation可以直接变更状态。 action 可以包含任意异步操作。mutation只能是同步操作。 提交方式不同，action 是用this.$store.dispatch(&#39;ACTION_NAME&#39;,data)来提交。mutation是用this.$store.commit(&#39;SET_NUMBER&#39;,10)来提交。 接收参数不同，mutation第一个参数是state，而action第一个参数是context，其包含了 12345678&#123; state, // 等同于 `store.state`，若在模块中则为局部状态 rootState, // 等同于 `store.state`，只存在于模块中 commit, // 等同于 `store.commit` dispatch, // 等同于 `store.dispatch` getters, // 等同于 `store.getters` rootGetters // 等同于 `store.getters`，只存在于模块中&#125; Vuex中action和mutation有什么相同点？第二参数都可以接收外部提交时传来的参数。 this.$store.dispatch(&#39;ACTION_NAME&#39;,data)和this.$store.commit(&#39;SET_NUMBER&#39;,10) 在组件中多次提交同一个action，怎么写使用更方便。使用mapActions辅助函数,在组件中这么使用 12345methods:&#123; ...mapActions(&#123; setNumber:&#x27;SET_NUMBER&#x27;, &#125;)&#125; 然后调用this.setNumber(10)相当调用this.$store.dispatch(&#39;SET_NUMBER&#39;,10) Vuex中action通常是异步的，那么如何知道action什么时候结束呢？在action函数中返回Promise，然后再提交时候用then处理 12345678910111213actions:&#123; SET_NUMBER_A(&#123;commit&#125;,data)&#123; return new Promise((resolve,reject) =&gt;&#123; setTimeout(() =&gt;&#123; commit(&#x27;SET_NUMBER&#x27;,10); resolve(); &#125;,2000) &#125;) &#125;&#125;this.$store.dispatch(&#x27;SET_NUMBER_A&#x27;).then(() =&gt; &#123; // ...&#125;) Vuex中有两个action，分别是actionA和actionB，其内都是异步操作，在actionB要提交actionA，需在actionA处理结束再处理其它操作，怎么实现？利用ES6的async和await来实现。 123456789actions:&#123; async actionA(&#123;commit&#125;)&#123; //... &#125;, async actionB(&#123;dispatch&#125;)&#123; await dispatch (&#x27;actionA&#x27;)//等待actionA完成 // ... &#125;&#125; 有用过Vuex模块吗，为什么要使用，怎么使用。有，因为使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。所以将 store 分割成模块（module）。每个模块拥有自己的 state、mutations、actions、getters，甚至是嵌套子模块，从上至下进行同样方式的分割。 在module文件新建moduleA.js和moduleB.js文件。在文件中写入 123456789101112131415161718const state=&#123; //...&#125;const getters=&#123; //...&#125;const mutations=&#123; //...&#125;const actions=&#123; //...&#125;export default&#123; state, getters, mutations, actions&#125; 然后再index.js引入模块 123456789101112import Vue from &#x27;vue&#x27;;import Vuex from &#x27;vuex&#x27;;Vue.use(Vuex);import moduleA from &#x27;./module/moduleA&#x27;import moduleB from &#x27;./module/moduleB&#x27;const store = new Vuex.Store(&#123; modules:&#123; moduleA, moduleB &#125;&#125;)export default store 在模块中，getter和mutation接收的第一个参数state，是全局的还是模块的？第一个参数state是模块的state，也就是局部的state。 在模块中，getter和mutation和action中怎么访问全局的state和getter？在getter中可以通过第三个参数rootState访问到全局的state,可以通过第四个参数rootGetters访问到全局的getter。 在mutation中不可以访问全局的satat和getter，只能访问到局部的state。 在action中第一个参数context中的context.rootState访问到全局的state，context.rootGetters访问到全局的getter。 在组件中怎么访问Vuex模块中的getter和state,怎么提交mutation和action？直接通过this.$store.getters和this.$store.state来访问模块中的getter和state。 直接通过this.$store.commit(&#39;mutationA&#39;,data)提交模块中的mutation。 直接通过this.$store.dispatch(&#39;actionA,data&#39;)提交模块中的action。 用过Vuex模块的命名空间吗？为什么使用，怎么使用。默认情况下，模块内部的action、mutation和getter是注册在全局命名空间，如果多个模块中action、mutation的命名是一样的，那么提交mutation、action时，将会触发所有模块中命名相同的mutation、action。 这样有太多的耦合，如果要使你的模块具有更高的封装度和复用性，你可以通过添加namespaced: true 的方式使其成为带命名空间的模块。 1234567export default&#123; namespaced: true, state, getters, mutations, actions&#125; 怎么在带命名空间的模块内提交全局的mutation和action？将 { root: true } 作为第三参数传给 dispatch 或 commit 即可。 12this.$store.dispatch(&#x27;actionA&#x27;, null, &#123; root: true &#125;)this.$store.commit(&#x27;mutationA&#x27;, null, &#123; root: true &#125;) #怎么在带命名空间的模块内注册全局的action？ 123456actions: &#123; actionA: &#123; root: true, handler (context, data) &#123; ... &#125; &#125;&#125; 怎么使用mapState，mapGetters，mapActions和mapMutations这些函数来绑定带命名空间的模块？首先使用createNamespacedHelpers创建基于某个命名空间辅助函数 123456789101112131415161718import &#123; createNamespacedHelpers &#125; from &#x27;vuex&#x27;;const &#123; mapState, mapActions &#125; = createNamespacedHelpers(&#x27;moduleA&#x27;);export default &#123; computed: &#123; // 在 `module/moduleA` 中查找 ...mapState(&#123; a: state =&gt; state.a, b: state =&gt; state.b &#125;) &#125;, methods: &#123; // 在 `module/moduleA` 中查找 ...mapActions([ &#x27;actionA&#x27;, &#x27;actionB&#x27; ]) &#125;&#125; Vuex插件有用过吗？怎么用简单介绍一下？Vuex插件就是一个函数，它接收 store 作为唯一参数。在Vuex.Store构造器选项plugins引入。 在store/plugin.js文件中写入 12345export default function createPlugin(param)&#123; return store =&gt;&#123; //... &#125;&#125; 然后在store/index.js文件中写入 123456import createPlugin from &#x27;./plugin.js&#x27;const myPlugin = createPlugin()const store = new Vuex.Store(&#123; // ... plugins: [myPlugin]&#125;) 在Vuex插件中怎么监听组件中提交mutation和action？ 用Vuex.Store的实例方法subscribe监听组件中提交mutation 用Vuex.Store的实例方法subscribeAction监听组件中提交action 在store/plugin.js文件中写入 123456789101112131415161718192021export default function createPlugin(param) &#123; return store =&gt; &#123; store.subscribe((mutation, state) =&gt; &#123; console.log(mutation.type)//是那个mutation console.log(mutation.payload) console.log(state) &#125;) // store.subscribeAction((action, state) =&gt; &#123; // console.log(action.type)//是那个action // console.log(action.payload)//提交action的参数 // &#125;) store.subscribeAction(&#123; before: (action, state) =&gt; &#123;//提交action之前 console.log(`before action $&#123;action.type&#125;`) &#125;, after: (action, state) =&gt; &#123;//提交action之后 console.log(`after action $&#123;action.type&#125;`) &#125; &#125;) &#125;&#125; 然后在store/index.js文件中写入 123456import createPlugin from &#x27;./plugin.js&#x27;const myPlugin = createPlugin()const store = new Vuex.Store(&#123; // ... plugins: [myPlugin]&#125;) 在v-model上怎么用Vuex中state的值？需要通过computed计算属性来转换。 123456789101112&lt;input v-model=&quot;message&quot;&gt;// ...computed: &#123; message: &#123; get () &#123; return this.$store.state.message &#125;, set (value) &#123; this.$store.commit(&#x27;updateMessage&#x27;, value) &#125; &#125;&#125; Vuex的严格模式是什么,有什么作用,怎么开启？在严格模式下，无论何时发生了状态变更且不是由 mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。 在Vuex.Store 构造器选项中开启,如下 123const store = new Vuex.Store(&#123; strict:true,&#125;) 如何解决vuex持久化问题","categories":[],"tags":[{"name":"vuex","slug":"vuex","permalink":"https://wisiw.github.io.git/tags/vuex/"}]},{"title":"【面试题】VueRouter","slug":"【面试题】VueRouter","date":"2021-02-20T02:37:28.000Z","updated":"2021-09-23T05:55:09.388Z","comments":true,"path":"2021/02/20/【面试题】VueRouter/","link":"","permalink":"https://wisiw.github.io.git/2021/02/20/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%91VueRouter/","excerpt":"","text":"Vue-Router基本应用怎么重定向页面第一种方法： 12345const router = new VueRouter(&#123; routes: [ &#123; path: &#x27;/a&#x27;, redirect: &#x27;/b&#x27; &#125; ]&#125;) 第二种方法: 12345const router = new VueRouter(&#123; routes: [ &#123; path: &#x27;/a&#x27;, redirect: &#123; name: &#x27;foo&#x27; &#125;&#125; ]&#125;) 第三种方法： 12345678910111213141516const router = new VueRouter(&#123; routes: [ &#123; path: &#x27;/a&#x27;, redirect: to =&gt;&#123; const &#123; hash, params, query &#125; = to if (query.to === &#x27;foo&#x27;) &#123; return &#123; path: &#x27;/foo&#x27;, query: null &#125; &#125;else&#123; return &#x27;/b&#x27; &#125; &#125; &#125; ]&#125;) 怎么配置404页面？1234567const router = new VueRouter(&#123; routes: [ &#123; path: &#x27;*&#x27;, redirect: &#123;path: &#x27;/&#x27;&#125; &#125; ]&#125;) 切换路由时，需要保存草稿的功能，怎么实现呢？123&lt;keep-alive :include=&quot;include&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; 路由有几种模式？说说它们的区别？ hash: 兼容所有浏览器，包括不支持 HTML5 History Api 的浏览器，例http://www.abc.com/#/index，hash值为#/index， hash的改变会触发hashchange事件，通过监听hashchange事件来完成操作实现前端路由。hash值变化不会让浏览器向服务器请求。 history: 兼容能支持 HTML5 History Api 的浏览器，依赖HTML5 History API来实现前端路由。没有#，路由地址跟正常的url一样，但是初次访问或者刷新都会向服务器请求，如果没有请求到对应的资源就会返回404，所以路由地址匹配不到任何静态资源，则应该返回同一个index.html 页面，需要在nginx中配置。 abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式。 讲一下完整的导航守卫流程？导航被触发。 在失活的组件里调用离开守卫beforeRouteLeave(to,from,next)。 调用全局的beforeEach( (to,from,next) =&gt;&#123;&#125; )守卫。 在重用的组件里调用 beforeRouteUpdate(to,from,next) 守卫。 在路由配置里调用beforeEnter(to,from,next)路由独享的守卫。 解析异步路由组件。 在被激活的组件里调用beforeRouteEnter(to,from,next)。 在所有组件内守卫和异步路由组件被解析之后调用全局的beforeResolve( (to,from,next) =&gt;&#123;&#125; )解析守卫。 导航被确认。 调用全局的afterEach( (to,from) =&gt;&#123;&#125; )钩子。 触发 DOM 更新。 用创建好的实例调用beforeRouteEnter守卫中传给 next 的回调函数 12345beforeRouteEnter(to, from, next) &#123; next(vm =&gt; &#123; //通过vm访问组件实例 &#125;)&#125;, 导航守卫的三个参数的含义？to：即将要进入的目标 路由对象。 from：当前导航正要离开的路由对象。 next：函数，必须调用，不然路由跳转不过去。 next()：进入下一个路由。 next(false)：中断当前的导航。 next(&#39;/&#39;)或next(&#123; path: &#39;/&#39; &#125;) : 跳转到其他路由，当前导航被中断，进行新的一个导航。 全局导航守卫有哪些？怎么使用？ router.beforeEach：全局前置守卫。 router.beforeResolve：全局解析守卫。 router.afterEach：全局后置钩子。 在afterEach钩子中可以使用next()吗？不可以，不接受next的参数。 什么是路由独享的守卫，怎么使用？是beforeEnter守卫 1234567891011const router = new VueRouter(&#123; routes: [ &#123; path: &#x27;/foo&#x27;, component: Foo, beforeEnter: (to, from, next) =&gt; &#123; // ... &#125; &#125; ]&#125;) 说说你对router-link的了解&lt;router-link&gt;是Vue-Router的内置组件，在具有路由功能的应用中作为声明式的导航使用。 &lt;router-link&gt;有8个props，其作用是： to ：必填，表示目标路由的链接。当被点击后，内部会立刻把to的值传到 router.push()，所以这个值可以是一个字符串或者是描述目标位置的对象。 12345&lt;router-link to=&quot;home&quot;&gt;Home&lt;/router-link&gt;&lt;router-link :to=&quot;&#x27;home&#x27;&quot;&gt;Home&lt;/router-link&gt;&lt;router-link :to=&quot;&#123; path: &#x27;home&#x27; &#125;&quot;&gt;Home&lt;/router-link&gt;&lt;router-link :to=&quot;&#123; name: &#x27;user&#x27;, params: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;/router-link&gt;&lt;router-link :to=&quot;&#123; path: &#x27;user&#x27;, query: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;/router-link&gt; 注意path存在时params不起作用，只能用query replace：默认值为false，若设置的话，当点击时，会调用router.replace()而不是router.push()，于是导航后不会留下 history 记录。 append：设置 append 属性后，则在当前 (相对) 路径前添加基路径。 tag：让&lt;router-link&gt;渲染成tag设置的标签，如tag:&#39;li,渲染结果为&lt;li&gt;foo&lt;/li&gt;。 active-class：默认值为router-link-active,设置链接激活时使用的 CSS 类名。默认值可以通过路由的构造选项 linkActiveClass 来全局配置。 exact-active-class：默认值为router-link-exact-active,设置链接被精确匹配的时候应该激活的 class。默认值可以通过路由构造函数选项 linkExactActiveClass 进行全局配置的。 exact：是否精确匹配，默认为false。 12&lt;!-- 这个链接只会在地址为 / 的时候被激活 --&gt;&lt;router-link to=&quot;/&quot; exact&gt;&lt;/router-link&gt; event：声明可以用来触发导航的事件。可以是一个字符串或是一个包含字符串的数组，默认是click。 怎么在组件中监听路由参数的变化？有两种方法可以监听路由参数的变化，但是只能用在包含&lt;router-view /&gt;的组件内。 第一种 12345watch: &#123; &#x27;$route&#x27;(to, from) &#123; //这里监听 &#125;,&#125;, 第二种 123beforeRouteUpdate (to, from, next) &#123; //这里监听&#125;, 切换路由后，新页面要滚动到顶部或保持原先的滚动位置怎么做呢？ 滚动顶部 123456789101112const router = new Router(&#123; mode: &#x27;history&#x27;, base: process.env.BASE_URL, routes, scrollBehavior(to, from, savedPosition) &#123; if (savedPosition) &#123; return savedPosition; &#125; else &#123; return &#123; x: 0, y: 0 &#125;; &#125; &#125;&#125;); 路由组件和路由为什么解耦，怎么解耦？因为在组件中使用 $route 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性，所有要解耦。 耦合如以下代码所示。Home组件只有在 1http://localhost:8036/home/123 URL上才能使用。 12345678const Home = &#123; template: &#x27;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&#x27;&#125;const router = new VueRouter(&#123; routes: [ &#123; path: &#x27;/home/:id&#x27;, component: Home &#125; ]&#125;) 使用 props 来解耦 props为true，route.params将会被设置为组件属性。 props为对象，则按原样设置为组件属性。 props为函数，http://localhost:8036/home?id=123,会把123传给组件Home的props的id。 1234567891011121314151617const Home = &#123; props: [&#x27;id&#x27;], template: &#x27;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;&#x27;&#125;const router = new VueRouter(&#123; routes: [ &#123; path: &#x27;/home/:id&#x27;, component: Home, props: true&#125;, // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项： &#123; path: &#x27;/home/:id&#x27;, components: &#123; default: Home, sidebar: Sidebar &#125;, props: &#123; default: true, sidebar: false &#125; &#125; &#123; path: &#x27;/home&#x27;, component: Home, props: &#123;id:123&#125; &#125;, &#123; path: &#x27;/home&#x27;, component: Home, props: (route) =&gt; (&#123; id: route.query.id &#125;) &#125;, ]&#125;) route和router有什么区别 route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。 router是“路由实例对象”，包括了路由的跳转方法，钩子函数等。 路由之间是怎么跳转的？有哪些方式？ 声明式 通过使用内置组件&lt;router-link :to=&quot;/home&quot;&gt;来跳转 编程式 通过调用router实例的push方法router.push(&#123; path: &#39;/home&#39; &#125;)或replace方法router.replace(&#123; path: &#39;/home&#39; &#125;) 怎么实现路由懒加载呢123456789101112131415function load(component) &#123; //return resolve =&gt; require([`views/$&#123;component&#125;`], resolve); return () =&gt; import(`views/$&#123;component&#125;`);&#125;const routes = [ &#123; path: &#x27;/home&#x27;, name: &#x27;home&#x27;, component: load(&#x27;home&#x27;), meta: &#123; title: &#x27;首页&#x27; &#125;, &#125;,] 怎样动态加载路由使用Router的实例方法addRoutes来实现动态加载路由，一般用来实现菜单权限。 使用时要注意，静态路由文件中不能有404路由，而要通过addRoutes一起动态添加进去。 1234567891011121314151617181920const routes = [ &#123; path: &#x27;/overview&#x27;, name: &#x27;overview&#x27;, component: () =&gt; import(&#x27;@/views/account/overview/index&#x27;), meta: &#123; title: &#x27;账户概览&#x27;, pid: 869, nid: 877 &#125;, &#125;, &#123; path: &#x27;*&#x27;, redirect: &#123; path: &#x27;/&#x27; &#125; &#125;]vm.$router.options.routes.push(...routes);vm.$router.addRoutes(routes); active-class是哪个组件的属性&lt;router-link/&gt;组件的属性，设置链接激活时使用的 CSS 类名。默认值可以通过路由的构造选项 linkActiveClass 来全局配置 Vue路由怎么跳转打开新窗口12345678const obj = &#123; path: xxx,//路由地址 query: &#123; mid: data.id//可以带参数 &#125;&#125;;const &#123;href&#125; = this.$router.resolve(obj);window.open(href, &#x27;_blank&#x27;);","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://wisiw.github.io.git/tags/Vue/"},{"name":"VueRouter","slug":"VueRouter","permalink":"https://wisiw.github.io.git/tags/VueRouter/"}]},{"title":"【代码片段】获取一个页面中使用最多的标签","slug":"【代码片段】获取一个页面中使用最多的标签","date":"2021-02-20T01:45:57.000Z","updated":"2021-09-23T06:13:08.631Z","comments":true,"path":"2021/02/20/【代码片段】获取一个页面中使用最多的标签/","link":"","permalink":"https://wisiw.github.io.git/2021/02/20/%E3%80%90%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E3%80%91%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%9C%80%E5%A4%9A%E7%9A%84%E6%A0%87%E7%AD%BE/","excerpt":"","text":"12345678910111213141516171819202122232425function getTagRank(ranks)&#123; if(typeof ranks !== &#x27;number&#x27;)&#123; throw new Error(&#x27;typeerror:获取标签的数量必须是number类型&#x27;); return; &#125; // 获取当前页面所有标签 let tags = [...document.querySelectorAll(&#x27;*&#x27;)].map(node=&gt;node.nodeName); let obj = &#123;&#125;; // 获取所有标签的数量 tags.forEach(item =&gt;&#123; if(!obj[item])&#123; obj[item] = 1; &#125;else&#123; obj[item] += 1; &#125; &#125;); // 根据数量从大到小排序 let tagRank = Object.keys(obj).sort((a,b)=&gt;&#123; return obj[b] - obj[a]; &#125;); // 根据ranks截取长度 tagRank.length = ranks; return tagRank; &#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://wisiw.github.io.git/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wisiw.github.io.git/tags/JavaScript/"},{"name":"代码片段","slug":"代码片段","permalink":"https://wisiw.github.io.git/tags/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"}]},{"title":"【面试题】JavaScript编程题","slug":"【面试题】JavaScript编程题","date":"2021-02-18T04:09:21.000Z","updated":"2021-09-23T05:59:30.297Z","comments":true,"path":"2021/02/18/【面试题】JavaScript编程题/","link":"","permalink":"https://wisiw.github.io.git/2021/02/18/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%91JavaScript%E7%BC%96%E7%A8%8B%E9%A2%98/","excerpt":"","text":"柯里化实现 add(1)(2)(3)123456789101112131415161718192021function add () &#123; const numberList = Array.from(arguments); // 进一步收集剩余参数 const calculate = function() &#123; numberList.push(...arguments); return calculate; &#125; // 利用 toString 隐式转换，最后执行时进行转换 calculate.toString = function() &#123; return numberList.reduce((a, b) =&gt; a + b, 0); &#125; return calculate;&#125;// 实现一个 add 方法，使计算结果能够满足以下预期console.log(add(1)(2)(3)); // 6console.log(add(1, 2, 3)(4)); // 10;console.log(add(1)(2)(3)(4)(5)); // 15; 实现 compose(foo, bar, baz)(‘start’)12345678910111213141516171819202122232425262728293031323334353637383940414243function foo(...args) &#123; console.log(args[0]); return &#x27;foo&#x27;;&#125;function bar(...args) &#123; console.log(args[0]); return &#x27;bar&#x27;;&#125;function baz(...args) &#123; console.log(args[0]); return &#x27;baz&#x27;;&#125;function compose() &#123; // 闭包元素 - 函数列表 const list = Array.from(arguments); // 闭包元素 - 函数列表执行位置 let index = -1; // 闭包元素 - 上一个函数的返回 let prev = &#x27;&#x27;; // 返回闭包函数 const doNext = function() &#123; index++; // 索引值累加 // 一开始没有上一个元素时，获取第二个括号的值 if (!prev) &#123; prev = arguments[0]; &#125; // 设置前一个结果为当前函数返回 prev = list[index](prev); // 递归调用 if (index &lt; list.length - 1) &#123; doNext(index + 1); &#125; &#125;; // 第一次返回闭包函数 return doNext;&#125;compose(foo, bar, baz)(&#x27;start&#x27;); 选择题12345678910111213141516171819202122function test() &#123; var n = 4399; function add() &#123; n++; console.log(n); &#125; return &#123; n, add &#125;;&#125;;var result = test();var result2 = test();result.add(); // 输出啥result.add(); // 输出啥console.log(result.n); // 输出啥result2.add(); // 输出啥// 4400 4401 4399 4400 1234567891011121314function Foo() &#123; var i = 0; return function() &#123; console.log(i++); &#125;&#125;var f1 = Foo();var f2 = Foo();f1();f1();f2();// 0 1 0","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://wisiw.github.io.git/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"编程题","slug":"编程题","permalink":"https://wisiw.github.io.git/tags/%E7%BC%96%E7%A8%8B%E9%A2%98/"}]},{"title":"【browser】从输入 URL 到页面呈现","slug":"【browser】从输入-URL-到页面呈现","date":"2021-02-17T14:21:23.000Z","updated":"2021-09-23T06:03:31.420Z","comments":true,"path":"2021/02/17/【browser】从输入-URL-到页面呈现/","link":"","permalink":"https://wisiw.github.io.git/2021/02/17/%E3%80%90browser%E3%80%91%E4%BB%8E%E8%BE%93%E5%85%A5-URL-%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0/","excerpt":"","text":"1.DNS解析根据域名解析出IP地址 DNS 解析过程： 查询 www.baidu.com 访问客户端 DNS 缓存： 浏览器缓存 -&gt; 系统缓存（host） -&gt; 路由器缓存 访问 ISP DNS 服务器（ISP，互联网服务提供商，有联通电信移动等。如果你是电信网络，则进入电信的 DNS 缓存服务器，以下简称本地），如果本地服务器有，则直接返回；如果没有，让本地 DNS 服务器去咨询查找。 本地去咨询 DNS 根服务器，DNS 根服务器发现是 .com 区域 管理的，告诉本地去咨询它。 本地去咨询 .com 顶级域名服务器，.com 顶级域名服务器不太清楚，告诉本地去咨询 baidu.com 主区域 的服务器。 本地去咨询 baidu.com 主域名服务器，baidu.com 域服务器查找到对应的 IP 地址，返回给本地。 本地服务器通知用户， baidu.com 对应的 IP 地址，同时缓存这个 IP 地址，下次就直接访问了。 2.TCP连接 建立连接阶段：3 次握手。建立客户端和服务器之间的连接。 传输数据阶段 断开连接阶段：4 次挥手。断开客户端和服务器之间的连接。 3.发送HTTP请求构建 HTTP 请求报文，并通过 TCP 协议发送到服务器指定端口（HTTP 协议默认端口 80/8080，HTTPS 协议默认端口 443） HTTP 请求报文由 3 部分组成：请求行、请求报文 和 请求正文。 请求行：常用方法有：GET、POST、PUT、DELETE、OPTIONS、HEAD。 请求报头：允许客户端向服务器传递请求的附加信息和客户端自身的信息。 请求正文：通过 POST、PUT 等方法时，通常需要客户端向服务器传递数据，这些数据就储存在请求正文中。 4.服务器响应服务器处理请求完毕后，会返回 HTTP 报文。 HTTP 响应报文也是由 3 部分组成：状态码、响应报头 和 响应报文 状态码： 1xx 指示信息-表示请求已接收； 2xx 请求成功-表示请求成功接收并解析； 3xx 重定向-表示要完成请求需要更进一步操作； 4xx 客户端错误-请求有语法错误或者请求无法实现； 5xx：服务端错误-服务端未能实现合法的请求。 常见状态码：200（成功）、304（请求内容有缓存，不需要更新）、404（网页或者文件找不到）、500（服务器-后端处理错误）。 响应报头：常见的响应报头字段 Server、 Connection 等。 响应报文：服务器返回给浏览器的文本信息，通常 HTML、CSS、JS、图片等文件就放在这一部分 5.浏览器渲染 解析 HTML，生成 DOM 树 解析 CSS，生成 CSS 规则树（CSS Rule Tree） 将 DOM Tree 和 CSS Rule Tree 相结合，生成 渲染树（ Render Tree） 从根节点开始，计算每一个元素的大小、位置，给出每个节点所应该出现的屏幕精确坐标，从而得到基于渲染树的 布局渲染树（ Layout of the render tree）。 遍历渲染树，将每个节点用 UI 渲染引擎来绘制，从而将整棵树绘制到页面上，这个步骤叫 绘制渲染树（ Painting the render tree） 在解析渲染过程中，可能会产生 回流 和 重绘： 重绘(repaint)**：当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要 UI 层面的重新像素绘制，因此 **损耗较少。 **回流(reflow)**：又叫重排（ layout）。当元素的尺寸、结构或者触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。 在构建 DOM 的时候，HTML 解析器如果碰到 JavaScript，那么就会停止构建 DOM，将控制权交给 JavaScript 引擎，等 JavaScript 运行完毕，浏览器再从中断的地方恢复 DOM 构建 也就是说：首屏渲染越快，就越不应该在首屏的时候加载 JS 文件，这也就是建议将 script 标签放到 body 标签底部，或者给 script 标签添加 defer/async 属性的原因","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://wisiw.github.io.git/tags/%E5%89%8D%E7%AB%AF/"},{"name":"面试题","slug":"面试题","permalink":"https://wisiw.github.io.git/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"browser","slug":"browser","permalink":"https://wisiw.github.io.git/tags/browser/"}]},{"title":"【JavaScript】数据结构与算法","slug":"【JavaScript】数据结构与算法","date":"2021-02-16T14:12:25.000Z","updated":"2021-09-23T05:44:48.132Z","comments":true,"path":"2021/02/16/【JavaScript】数据结构与算法/","link":"","permalink":"https://wisiw.github.io.git/2021/02/16/%E3%80%90JavaScript%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","excerpt":"","text":"","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wisiw.github.io.git/tags/JavaScript/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://wisiw.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"Flux架构","slug":"Flux架构","date":"2021-02-10T19:57:04.000Z","updated":"2021-06-21T08:12:55.908Z","comments":true,"path":"2021/02/11/Flux架构/","link":"","permalink":"https://wisiw.github.io.git/2021/02/11/Flux%E6%9E%B6%E6%9E%84/","excerpt":"","text":"","categories":[],"tags":[{"name":"架构","slug":"架构","permalink":"https://wisiw.github.io.git/tags/%E6%9E%B6%E6%9E%84/"},{"name":"Flux","slug":"Flux","permalink":"https://wisiw.github.io.git/tags/Flux/"}]},{"title":"【Java】MyBatis生成工具","slug":"【Java】MyBatis生成工具","date":"2021-02-05T08:11:54.000Z","updated":"2021-09-23T05:58:41.007Z","comments":true,"path":"2021/02/05/【Java】MyBatis生成工具/","link":"","permalink":"https://wisiw.github.io.git/2021/02/05/%E3%80%90Java%E3%80%91MyBatis%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7/","excerpt":"","text":"1.MyBatis Genneratorpom123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;util&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.3.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.shenjia&lt;/groupId&gt; &lt;artifactId&gt;MyBatisX&lt;/artifactId&gt; &lt;version&gt;0.0.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;version&gt;2.3.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.9&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.15&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;configuration&gt; &lt;configurationFile&gt;src/main/resources/generatorConfig.xml&lt;/configurationFile&gt; &lt;overwrite&gt;false&lt;/overwrite&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; source/application.yml123456spring: datasource: driverClassName: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/XXXX?useUnicode=true&amp;serverTimezone=Asia/Shanghai&amp;autoReconnect=true&amp;characterEncoding=utf-8 username: root password: 106613 source/generatorConfig.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;!--mysql 连接数据库jar 这里选择自己本地位置--&gt; &lt;classPathEntry location=&quot;C:/Users/wsw/.m2/repository/mysql/mysql-connector-java/8.0.13/mysql-connector-java-8.0.13.jar&quot; /&gt; &lt;context id=&quot;MysqlTables&quot; targetRuntime=&quot;MyBatis3Simple&quot; defaultModelType=&quot;flat&quot;&gt; &lt;property name=&quot;autoDelimitKeywords&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;javaFileEncoding&quot; value=&quot;utf-8&quot;/&gt; &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt; &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt; &lt;/commentGenerator&gt; &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/XXXX?serverTimezone=Asia/Shanghai&amp;amp;nullCatalogMeansCurrent=true&quot; userId=&quot;XXXX&quot; password=&quot;XXXX&quot;&gt; &lt;/jdbcConnection&gt; &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 NUMERIC 类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt; &lt;/javaTypeResolver&gt; &lt;!-- targetProject:生成PO类的位置 --&gt; &lt;javaModelGenerator targetPackage=&quot;model&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!-- targetProject:mapper映射文件生成的位置 如果maven工程只是单独的一个工程，targetProject=&quot;src/main/java&quot; 若果maven工程是分模块的工程，targetProject=&quot;所属模块的名称&quot;，例如： targetProject=&quot;ecps-manager-mapper&quot;，下同--&gt; &lt;sqlMapGenerator targetPackage=&quot;sqlmap&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- targetPackage：mapper接口生成的位置 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;dao&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定数据库表 --&gt; &lt;table schema=&quot;general&quot; tableName=&quot;%&quot; enableInsert=&quot;true&quot; enableDeleteByPrimaryKey=&quot;true&quot; enableSelectByPrimaryKey=&quot;true&quot; enableUpdateByPrimaryKey=&quot;true&quot; selectByPrimaryKeyQueryId=&quot;true&quot; enableCountByExample= &quot;false&quot; enableUpdateByExample= &quot;false&quot; enableDeleteByExample= &quot;false&quot; enableSelectByExample= &quot;false&quot; selectByExampleQueryId= &quot;false&quot;&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 2.Mybatis Plus待续","categories":[],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://wisiw.github.io.git/tags/mybatis/"},{"name":"工具","slug":"工具","permalink":"https://wisiw.github.io.git/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"【Java】微服务架构搭建","slug":"【Java】微服务架构搭建","date":"2021-02-05T07:55:11.000Z","updated":"2021-09-23T06:02:07.916Z","comments":true,"path":"2021/02/05/【Java】微服务架构搭建/","link":"","permalink":"https://wisiw.github.io.git/2021/02/05/%E3%80%90Java%E3%80%91%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%90%AD%E5%BB%BA/","excerpt":"","text":"主要搭建两个框架，使用IntelliJ IDEA Spring Boot和Spring Cloude 1）Spring Boot 2）Spring Cloude","categories":[{"name":"微服务","slug":"微服务","permalink":"https://wisiw.github.io.git/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://wisiw.github.io.git/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"教程","slug":"教程","permalink":"https://wisiw.github.io.git/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"【面试题】JavaScript","slug":"【面试题】JavaScript","date":"2021-02-04T09:20:55.000Z","updated":"2021-09-23T05:45:48.699Z","comments":true,"path":"2021/02/04/【面试题】JavaScript/","link":"","permalink":"https://wisiw.github.io.git/2021/02/04/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%91JavaScript/","excerpt":"","text":"基础1.null 和 undefined 的区别 null 表示 无 的对象，也就是此处不应该有值；而 undefined 表示未定义。 在转换数字的时候， Number(null) 为 0，而 Number(undefined) 为 NaN null： 作为函数的参数，表示该函数的参数不是对象。 作为对象原型链的终点。 Object.prototype.__proto__ === null undefined： 变量被声明但是没有赋值，等于 undefined。 调用函数时，对应的参数没有提供，也是 undefined。 对象没有赋值，这个属性的值为 undefined。 函数没有返回值，默认返回 undefined。 2.事件流3.typeof 和 instanceof 的区别 typeof：对某个变量类型的检测，基本类型除了 null 之外，都能正常地显示为对应的类型，引用类型除了函数会显示为 function，其他都显示为 object。 instanceof 主要用于检测某个构造函数的原型对象在不在某个对象的原型链上。 为什么&quot;object&quot;?因为 JavaScript 早起版本是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，所以它错误判断为 object 4.一句话描述this对于函数而言，指向最后调用函数的那个对象，是函数运行时内部自动生成的一个内部对象，只能在函数内部使用；对于全局而言，this 指向 window 普通函数中 this 的指向，是 this 执行时的上下文 箭头函数中 this 的指向，是 this 定义时的上下文 改变this的指向？1）保存指针let that = this 2）使用箭头函数：因为箭头函数不会创建其自身的执行上下文，函数中的this取决于外部函数，即谁调用它this就继承谁 3）call/apply/bind 5.执行上下文闭包是什么？在JavaScript中，根据作用域规则，内部函数总是可以访问外部函数声明的变量。 当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数应用外部函数的变量依旧保存在内存中，这些变量的集合称为闭包 函数B在函数A中调用了A中的变量，B就称之为A的闭包 优缺点 优点 1）缓存持久化 2）实现柯里化 缺点 1）内存消耗：闭包产生的变量无法被销毁 2）性能问题：闭包内部变量优先级高于外部变量，所以需要作用域链要多查找一级，影响查找速度 柯里化是什么？通过将接收多个参数换成一个参数，每次调用返回新函数的技术 通过闭包管理 支持链式调用 每次运行返回一个 function 为什么？ 参数复用 1234567891011121314151617181920// 校验数字let numberReg = /[0-9]+/g;// 校验小写字母let stringReg = /[a-z]+/g;// currying 后function curryingCheck(reg) &#123; return function(txt) &#123; return reg.test(txt); &#125;&#125;// 校验数字let checkNumber = curryingCheck(numberReg);let checkString = curryingCheck(stringReg);// 使用console.log(checkNumber(&#x27;13888888888&#x27;)); // trueconsole.log(checkString(&#x27;jsliang&#x27;)); // true 提前确认 延迟运行 作用域与作用域链 作用域： 作用域链：本质上是一个指向变量对象的指针列表 变量提升与函数提升函数提升是为了解决相互递归的问题，大体上可以解决自上而下的顺序问题 原型与原型链是什么？ 原型：在JavaScript中，每当定义一个对象时，对象中都会包含一些预定义的属性。 其中每个函数对象都有一个prototype属性，这个属性的指向被称为这个函数对象的原型对象（简称原型） 原型链：查找原型上存在的某个属性的的链式路径 如果某个实例对象不存在的某个属性，那么JavaScript会去改构造函数的原型上去找；如果原型上没有找到，那么会继续往Object的原型上，如果Object的原型上还是没有，会返回undefined 为什么？为了节约内存空间 __proto__与prototype的关系每个 JavaScript 对象（普通对象和函数对象）都具有一个属性 __proto__，这个属性会指向该对象的原型。 堆与栈Event Loop（事件循环）为什么？因为JavaScript是单线程语言，一次只能执行一件程序。单线程在程序执行的时候，所走的程序路径按照连续顺序排下来，依次执行，只有前面的程序执行结束才会执行接下来的程序。 如果遇到一些需要等待的程序，比如说setTimeOut就会造成延迟 因此，JavaScript为了协调时间、用户交互、脚本、渲染、网络等，就使用事件循环（Event Loop） 是什么？从script开始读取，不断循环，从“任务队列”中读取执行事件的过程。 执行过程 一开始整个脚本script作为一个宏任务执行 执行过程中，同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列 当前宏任务执行出对，检查微任务列表是否存在，有则一次执行，直至全部执行完毕 执行浏览器的UI线程的渲染工作 检查是否有web worker任务，有则执行 执行完本轮的宏任务，回到步骤2，依次循环，知道宏任务和微任务为空 宏任务、微任务是什么？事件循环的异步队列，是为了解决单线程阻塞的问题 宏任务队列可以有多个，但是微任务队列只有一个 宏任务：script、setTimeout、setInterval、setImmediate、I/O、UI rendering 微任务：MutationObserver、Promise.then()/catch()、fetch/axios（以Promise为基础开发）、V8垃圾回收过程、process.nextTick（Node独有） babel 编译原理 babylon 将 ES6/ES7 代码解析成 AST babel-traverse 对 AST 进行遍历转译，得到新的 AST 新 AST 通过 babel-generator 转换成 ES5 浏览器渲染过程 1）创建DOM树HTML解析器解析HTML元素，创建DOM树 2）创建CSS规则树CSS解析器解析CSS文件和内联与行内样式，生成页面的样式表 3）创建Render树将DOM树与CSS规则树关联起来，创建Render树 4）布局Layout根据Render树，浏览器开始布局，为每个Render树上的节点确定一个在显示器出现的精确坐标 5）绘制Painting在Render树和节点显示坐标的基础上，调用每个节点的paint方法，绘制出来 重绘：当元素样式的改变不影响布局时，只会对元素进行更新，此时只需要UI层面的额像素绘制，损耗较少 触发条件：background、color、visibility 回流：当元素尺寸、结构或者触发某些属性时，浏览器会重新渲染页面 触发条件：1）添加删除DOM元素；2）修改边框、边距、宽高等影响元素定位 的属性；3）浏览器窗口resize 回流必定会发生重绘，重绘不一定会引发回流。 1234567891011121314151617181920function a() &#123; console.log(1) return &quot;2&quot;&#125;function b() &#123; try&#123; console.log(3) return a() &#125;catch (e) &#123; console.log(5) return &quot;6&quot; &#125;finally &#123; console.log(7) return &quot;8&quot; &#125; return &quot;9&quot;&#125;console.log(b()) // 3 1 7 8// finally有return 那么return的就是finally的","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wisiw.github.io.git/tags/JavaScript/"},{"name":"面试题","slug":"面试题","permalink":"https://wisiw.github.io.git/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"【JavaScript】手写函数","slug":"【JavaScript】手写函数","date":"2021-02-02T07:32:39.000Z","updated":"2021-09-23T06:06:23.051Z","comments":true,"path":"2021/02/02/【JavaScript】手写函数/","link":"","permalink":"https://wisiw.github.io.git/2021/02/02/%E3%80%90JavaScript%E3%80%91%E6%89%8B%E5%86%99%E5%87%BD%E6%95%B0/","excerpt":"","text":"call()&amp;&amp;apply()&amp;&amp;bind()1.call()12345678910111213function call(Fn, obj, ...arg) &#123; if (obj === undefined || obj === null) &#123; obj = window; &#125; // 为obj添加临时方法,this自动指向obj obj.temp = Fn; // 调用temp方法 let result = obj.temp(...arg); // 删除临时方法 delete obj.temp; // 返回执行结果 return result;&#125; 2.apply()12345678910111213function call(Fn, obj, arg) &#123; if (obj === undefined || obj === null) &#123; obj = window; &#125; // 为obj添加临时方法,this自动指向obj obj.temp = Fn; // 调用temp方法 let result = obj.temp(...arg); // 删除临时方法 delete obj.temp; // 返回执行结果 return result;&#125; 3.bind()1234567function bind(Fn, obj, ...arg) &#123; // 返回一个新函数 return function (...arg2) &#123; // 通过call调用原函数, 并指定this为obj, 实参为args与args2 return call(Fn, obj, ...arg, ...arg2) &#125;&#125; 函数节流与防抖1.函数节流throttle()12345678910function throttle(callback, wait) &#123; let start = 0; return function (e) &#123; let now = Date.now(); if (now - start &gt; wait) &#123; callback.call(this, e) start = now; &#125; &#125;&#125; 2.函数防抖debounce()123456789101112function debounce(callback,time) &#123; let timeId = null; return function(e) &#123; if(timeId !== null)&#123; clearTimeout(timeId); &#125; timeId = setTimeout(function () &#123; callback.call(this,e); timeId = null; &#125;,time) &#125;&#125; 数组相关1.map()返回一个由回调函数的返回值组成的新数组 123456789function map(arr,callback) &#123; // 声明空数组 let result = []; for (let i = 0;i&lt;arr.length;i++)&#123; // 将callback的执行结果添加到数组中 result.push(callback(arr[i],i)) &#125; return result;&#125; 2.reduce()从左到右为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值 123456789function reduce(arr, callback, initValue) &#123; let result = initValue; // 执行callback for (let i = 0; i &lt; arr.length; i++) &#123; // 将回调函数的执行结果赋值给result result = callback(result, arr[i]); &#125; return result;&#125; 3.filter()将所有在过滤函数中返回 true 的数组元素放进一个新数组中并返回 1234567891011function filter(arr, callback) &#123; // 声明空数组 let result = []; for (let i = 0; i &lt; arr.length; i++) &#123; // 判断回调函数的返回值 if (callback(arr[i], i)) &#123; result.push(arr[i]) &#125; &#125; return result;&#125; 4.find()找到第一个满足测试函数的元素并返回那个元素的值，如果找不到，则返回 undefined 123456789101112function find(arr, callback) &#123; // 遍历数组 for (let i = 0; i &lt; arr.length; i++) &#123; // 判断执行结果 if (callback(arr[i], i)) &#123; // 返回当前正在遍历的元素 return arr[i]; &#125; &#125; // 没有遇到满足条件的元素，返回undefined return undefined;&#125; 5.findIndex()找到第一个满足测试函数的元素并返回那个元素的索引，如果找不到，则返回 -1 1234567891011function findIndex(arr, callback) &#123; // 遍历数组 for (let i = 0; i &lt; arr.length; i++) &#123; // 判断回调函数返回值 if (callback(arr[i], i)) &#123; return i &#125; &#125; // 找不到返回-1 return -1&#125; 6.every()如果数组中的每个元素都满足测试函数，则返回 true，否则返回 false 123456789function every(arr, callback) &#123; for (let i = 0; i &lt; arr.length; i++) &#123; // 只有一个结果为false, 直接返回false if (!callback(arr[i], i)) &#123; return false &#125; &#125; return true&#125; 7.some()如果数组中至少有一个元素满足测试函数，则返回 true，否则返回 false 123456789function some(arr, callback) &#123; for (let i = 0; i &lt; arr.length; i++) &#123; // 只有一个结果为true, 直接返回true if (callback(arr[i], i)) &#123; return true &#125; &#125; return false&#125; 8.数组去重8.1.利用forEach()和indexOf()本质是双重遍历, 效率差些 123456789function unique1 (arr) &#123; const result = [] arr.forEach(item =&gt; &#123; if (result.indexOf(item)===-1) &#123; result.push(item) &#125; &#125;) return result&#125; 8.2.利用forEach() + 对象容器只需一重遍历, 效率高些 1234567891011function unique2 (arr) &#123; const result = [] const obj = &#123;&#125; arr.forEach(item =&gt; &#123; if (!obj.hasOwnProperty(item)) &#123; obj[item] = true result.push(item) &#125; &#125;) return result&#125; 8.3.利用ES6语法: from + Set 或者 … + Set123function unique3 (arr) &#123; return [...new Set(arr)]&#125; 8.4.不使用多余空间1234567891011function unique4(arr) &#123; for (let i = 0; i &lt; arr.length; i++) &#123; for (let j = i + 1; j &lt; arr.length; j++) &#123; if (arr[i] === arr[j]) &#123; arr.splice(j, 1); j--; &#125; &#125; &#125; return arr;&#125; 9.数组合并1234567891011function concat(arr,...value) &#123; const array = [...arr] value.forEach(item =&gt; &#123; if(Array.isArray(item))&#123; array.push(...item) &#125;else&#123; array.push(item) &#125; &#125;) return array;&#125; 10.数组切片1234567891011121314151617181920212223242526function slice(arr, start, end) &#123; // 如果当前数组为[]，返回[] if (arr.length === 0) &#123; return [] &#125; // 如果开始位置大雨数组长度，返回[] start = start || 0 if (start &gt;= arr.length) &#123; return [] &#125; // 如果结束位置大于数组长度，end更新为数组长度 end = end || arr.length if (end &gt; arr.length) &#123; end = arr.length; &#125; // 如果结束位置小于等于开始位置，返回[] if (end &lt;= start) &#123; return [] &#125; let result = []; // 取出下标在[start,end)之间的元素，放入result中 for (let i = start; i &lt; end; i++) &#123; result.push(arr[i]) &#125; return result;&#125; 11.数组扁平化##11.1.递归 + concat() 12345678910111213function flatten1(arr) &#123; let result = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (Array.isArray(arr[i])) &#123; // 如果是数组，遍历 result = result.concat(flatten1(arr[i])) &#125; else &#123; // 不是数组，合并入result中 result = result.concat(arr[i]) &#125; &#125; return result;&#125; 11.2. … + some() + concat()1234567function flatten2(arr) &#123; let result = [].concat(...arr) // 如果数组中存在第二级，展开合并 while (result.some(item =&gt; Array.isArray(item))) &#123; result = [].concat(...result) &#125;&#125; 12.数组分块123456789101112131415161718function chunk(arr, size = 1) &#123; let result = []; let temp = []; // 遍历数组 arr.forEach(item =&gt; &#123; if (temp.length === 0) &#123; // 如果临时数组为空，压入结果数组中 result.push(temp) &#125; // 将元素压入临时数组中 temp.push(item) if (temp.length === size) &#123; // 长度满足后，清空temp temp = [] &#125; &#125;) return result;&#125; 13.数组求差集1234567891011function difference(arr1,arr2=[]) &#123; // 如果arr1为[]，返回[] if(arr1.length === 0)&#123; return []; &#125; // 如果arr2为[]，通过slice深拷贝arr1返回 if(arr2.length === 0)&#123; return arr1.slice(); &#125; return arr1.filter(item =&gt; !arr2.includes(item))&#125; 14.删除数组中部分元素14.1.pull([1,3,5,3,7], 2, 7, 3, 7) ===&gt; 原数组变为[1, 5], 返回值为[3,3,7]1234567891011121314function pull(arr, ...values) &#123; if (arr.length === 0 || values.length === 0) &#123; return []; &#125; let result = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (values.indexOf(arr[i]) !== -1) &#123; arr.splice(i,1); result.push(arr[i]); i--; &#125; &#125; return result;&#125; 14.2.pullAll([1,3,5,3,7], [2, 7, 3, 7]) ===&gt; 数组1变为[1, 5], 返回值为[3,3,7]123456function pullAll(arr, values) &#123; if (!values || !Array.isArray(values)) &#123; return []; &#125; return pull(arr, ...values)&#125; 16.获取数组部分元素16.1.drop(array, count)drop([1,3,5,7], 2) ===&gt; [5, 7] 123456function drop(arr, count = 1) &#123; if (arr.length === 0 || count &gt;= arr.length) &#123; return []; &#125; return arr.filter((item, i) =&gt; i &gt;= count)&#125; 16.2.dropRight(array, count)dropRight([1,3,5,7], 2) ===&gt; [1, 3] 123456function dropRight(arr, count = 1) &#123; if (arr.length === 0 || count &gt;= arr.length) &#123; return []; &#125; return arr.filter((item, i) =&gt; i &lt; arr.length - count)&#125; 对象相关new根据构造函数实例化对象 123456789function New(Fn, ...args) &#123; // 1.创建一个新对象 const obj = &#123;&#125;; // 2.修改函数内部的this指向新对象，并执行 const result = Fn.call(obj, ...args) obj.__proto__ = Fn.prototype; // 3.返回新对象 return result instanceof Object ? result : obj;&#125; instanceOf1234567891011121314function InstanceOf(obj,type) &#123; // 获取obj的隐式原型对象 let protoObj = obj.__proto__; // 遍历原型链 while (protoObj)&#123; // 检测obj的原型对象和type的原型对象是否相等 if (protoObj === type.__proto__)&#123; return true; &#125; // 不相等，向上查找原型对象 protoObj = protoObj.__proto__; &#125; return false;&#125; 对象合并1234567891011121314151617function mergeObj(...objs) &#123; let result = &#123;&#125;; // 遍历对象 objs.forEach(obj =&gt; &#123; // 获取对象的所有key并遍历 Object.keys(obj).forEach(key =&gt; &#123; if (result.hasOwnProperty(key)) &#123; // 存在，则合并属性 result[key] = [].concat(result[key], obj[key]) &#125; else &#123; // 如果结果对象中不存在，则添加属性 result[key] = obj[key]; &#125; &#125;) &#125;) return result;&#125; 对象/数组拷贝浅拷贝1）…123456789101112function clone1(target) &#123; // 判断是否为对象 if (target !== null &amp;&amp; typeof target === &#x27;Object&#x27;) &#123; if (Array.isArray(target)) &#123; return [...target] &#125; else &#123; return &#123;...target&#125; &#125; &#125; else &#123; return target; &#125;&#125; 2）for…in1234567891011121314151617function clone2(target) &#123; // 判断是否为对象 if (target !== null &amp;&amp; typeof target === &#x27;Object&#x27;) &#123; const result = Array.isArray(target) ? [] : &#123;&#125;; // 遍历target数据 for (let key in target) &#123; // 判断target中是否包含该属性 if (target.hasOwnProperty(key)) &#123; // 将该属性写入result中 result[key] = target[key] &#125; &#125; return result; &#125; else &#123; return target; &#125;&#125; 深拷贝例子1234567let obj = &#123; a: 1, b: [&#x27;e&#x27;, &#x27;f&#x27;], c: &#123;d: 20&#125;, g: function () &#123; &#125;&#125;obj.b.push(obj.c)obj.c.d = obj.bdeepClone3(obj) 1）’JSON.parse(JSON.stringify())’缺点：1.无法克隆函数属性；2.无法解决循环引用 123function deepClone1(target) &#123; return JSON.parse(JSON.stringify(target));&#125; 2）递归拷贝，解决无法克隆函数属性12345678910111213function deepClone2(target) &#123; if (target !== null &amp;&amp; typeof target === &#x27;object&#x27;) &#123; const result = Array.isArray(target) ? [] : &#123;&#125;; for (let key in target) &#123; if (target.hasOwnProperty(key)) &#123; result[key] = deepClone2(target[key]) &#125; &#125; return result; &#125; else &#123; return target; &#125;&#125; 3）使用缓存容器，解决无法循环应用问题12345678910111213141516171819function deepClone3(target, map = new Map()) &#123; if (target !== null &amp;&amp; typeof target === &#x27;object&#x27;) &#123; // 判断传入的map中存不存在对象的克隆 let result = map.get(target) if (result) &#123; return target; &#125; result = Array.isArray(target) ? [] : &#123;&#125;; map.set(target, result) for (let key in target) &#123; if (target.hasOwnProperty(key)) &#123; result[key] = deepClone3(target[key], map) &#125; &#125; return result; &#125; else &#123; return target; &#125;&#125; 4）性能优化**数组: while | for | forEach() 优于 for-in | keys()&amp;forEach() ** 对象: for-in 与 keys()&amp;forEach() 差不多 123456789101112131415161718192021222324function deepClone4(target, map = new Map()) &#123; if (target !== null &amp;&amp; target === &quot;object&quot;) &#123; let result = map.get(target); if (result) &#123; return result; &#125; if (Array.isArray(target)) &#123; result = []; map.set(target, result); target.forEach((item, i) =&gt; &#123; result[i] = deepClone4(item[i], map) &#125;) &#125; else &#123; result = &#123;&#125;; map.set(target, result); Object.keys(target).forEach(key =&gt; &#123; result[key] = deepClone4(target[key], map) &#125;) &#125; return result; &#125;else&#123; return target; &#125;&#125; 字符串相关倒序12345function reverseString(str) &#123; // return str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) // return [...str].reverse().join(&#x27;&#x27;) return Array.from(str).reverse().join(&#x27;&#x27;)&#125; 检测是否回文123function palindrome(str) &#123; return str === reverseString(str)&#125; 截取字符串，以…隐藏多余字符串123function truncate(str, size) &#123; return str.length &gt; size ? str.slice(0, size) + &#x27;...&#x27; : str&#125; 手写DOM事件监听事件捕获与事件冒泡 事件委托函数将多个子元素的同类事件监听委托给(绑定在)共同的一个父组件上 好处： 减少内存占用(事件监听回调从n变为 动态添加的内部元素也能响应 1234567891011121314151617181920function addEventListener(el, type, Fn, selector) &#123; if (typeof el === &#x27;string&#x27;) &#123; el = document.querySelector(el); &#125; if (!selector) &#123; // 如果没有selector，普通事件绑定 el.addEventListener(type, Fn); &#125; else &#123; // 否则是代委托的事件绑定 el.addEventListener(type, function (e) &#123; // 获取真正发生事件的目标元素 const target = e.target; // 判断目标元素是否与selector相同 if (target.matches(selector)) &#123; // 调用处理事件的回调函数Fn，绑定当前this，参数为e Fn.call(target, e) &#125; &#125;) &#125;&#125; 事件总线123456789101112131415161718192021222324252627282930const eventBus = &#123;callbacks: &#123;&#125;&#125;// 注册事件监听eventBus.on = function (type, callback) &#123; const callbacks = this.callbacks[type]; if (!callbacks) &#123; this.callbacks[type] = [callback]; &#125; else &#123; callbacks.push(callback); &#125;&#125;// 触发事件监听eventBus.emit = function (type, data) &#123; const callbacks = this.callbacks[type]; if (callbacks &amp;&amp; callbacks.length &gt; 0) &#123; this.callbacks[type].forEach(cb =&gt; &#123; cb(data) &#125;) &#125;&#125;// 移除事件监听eventBus.off = function (type) &#123; if (!type) &#123; this.callbacks = &#123;&#125;; &#125; else &#123; delete this.callbacks[type] &#125;&#125; 消息订阅与发布123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const sub = &#123; callbacks: &#123;&#125;, id: 0&#125;// 订阅sub.subscribe = function (type, callback) &#123; const token = &quot;token_&quot; + this.id; const callbacks = this.callbacks[type]; if (callbacks) &#123; callbacks[token] = callback &#125; else &#123; this.callbacks[type] = &#123; [token]: callback &#125; console.log(this.callbacks) &#125; this.id++; return token;&#125;// 发布sub.publish = function (type, data) &#123; const callbacks = this.callbacks[type]; if (callbacks) &#123; Object.values(this.callbacks).forEach(cb =&gt; &#123; cb(data) &#125;) &#125;&#125;// 取消sub.unsubscribe = function (flag) &#123; if (flag === undefined) &#123; this.callbacks = &#123;&#125;; &#125; else if (typeof flag === &quot;string&quot;) &#123; if (flag.indexOf(&quot;token_&quot;) === 0) &#123; const callbacks = Object.values(this.callbacks).find(callback =&gt; callback.hasOwnProperty(flag)); if (callbacks) &#123; delete callbacks[flag] &#125; &#125; else &#123; delete this.callbacks[flag] &#125; &#125; else &#123; throw new Error(&quot;传入参数错误&quot;) &#125;&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wisiw.github.io.git/tags/JavaScript/"},{"name":"手写","slug":"手写","permalink":"https://wisiw.github.io.git/tags/%E6%89%8B%E5%86%99/"}]},{"title":"【源码解析】Vue：AST抽象语法树","slug":"【源码解析】Vue：AST抽象语法树","date":"2021-02-01T15:29:56.000Z","updated":"2021-09-23T05:51:53.475Z","comments":true,"path":"2021/02/01/【源码解析】Vue：AST抽象语法树/","link":"","permalink":"https://wisiw.github.io.git/2021/02/01/%E3%80%90%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91Vue%EF%BC%9AAST%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91/","excerpt":"","text":"基础版12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var templateStr = &quot;&lt;div&gt;&lt;p&gt;aaa&lt;/p&gt;&lt;ul&gt;&lt;li&gt;a&lt;/li&gt;&lt;li&gt;b&lt;/li&gt;&lt;li&gt;c&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&quot;;parseHtml(templateStr)function parseHtml(templateStr) &#123; // 指针 var index = 0; var stackTag = []; var stackContent = [&#123;&#x27;children&#x27;: []&#125;]; var rest = templateStr; var startRegExp = /^\\&lt;([a-z]+[1-6]?)\\&gt;/; var endRegExp = /^\\&lt;\\/([a-z]+[1-6]?)\\&gt;/; var wordRegExp = /^([^\\&lt;]+)\\&lt;\\/[a-z]+[1-6]?\\&gt;/; while (index &lt; templateStr.length - 1) &#123; rest = templateStr.substring(index) // 识别开始字符是不是开始标签 if (startRegExp.test(rest)) &#123; // 获取开始标记 let tag = rest.match(startRegExp)[1]; // 将开始标记推入栈中 stackTag.push(tag); // 将空数组推入栈中 stackContent.push(&#123;&#x27;tag&#x27;: tag, &#x27;children&#x27;: []&#125;); index += tag.length + 2; &#125; else if (endRegExp.test(rest)) &#123; // 获取结束标记 let tag = rest.match(endRegExp)[1]; let pop_tag = stackTag.pop(); // 判断跟栈顶的标记是不是同一个 if (tag == pop_tag) &#123; let pop_arr = stackContent.pop(); if (stackContent.length &gt; 0) &#123; stackContent[stackContent.length - 1].children.push(pop_arr); &#125; &#125; else &#123; throw new Error(stackTag[stackTag.length - 1] + &quot;没有闭合&quot;) &#125; index += tag.length + 3; &#125; else if (wordRegExp.test(rest)) &#123; let word = rest.match(wordRegExp)[1]; if (!/^\\s+$/.test(word)) &#123; stackContent[stackContent.length - 1].children.push(&#123;&#x27;text&#x27;: word, &#x27;type&#x27;: 3&#125;) &#125; index += word.length; &#125; else &#123; index++; &#125; &#125; console.log(stackContent[0].children[0])&#125; 进阶版1）修改检测开始标记的正则12var startRegExp = /^\\&lt;([a-z]+[1-6]?)(\\s[^\\&lt;]+)?\\&gt;/;// 添加检测attr 2）检测到开始标记时，取出识别到的attr内容，指针后移12let attrString = rest.match(startRegExp)[2];index += tag.length + 2 + attrString.length; 3）格式化attrString12345678910111213141516171819202122232425262728function parseAttrString(attrString) &#123; if(attrString == undefined)return []; var isYinhao = false; var point = 0; var result = []; for (var i = 0;i&lt;attrString.length;i++)&#123; let char = attrString[i]; if(char == &#x27;&quot;&#x27;)&#123; isYinhao = !isYinhao; &#125;else if (char == &#x27; &#x27; &amp;&amp; !isYinhao)&#123; if(!/^\\s*$/.test(attrString.substring(point,i))) &#123; result.push(attrString.substring(point,i).trim()); point = i; &#125; &#125; &#125; result.push(attrString.substring(point).trim()) result = result.map(item =&gt; &#123; // 根据=拆分 let o = item.match(/^(.+)=&quot;(.+)&quot;$/); return &#123; name: o[1], value: o[2] &#125; &#125;) return result&#125; 4）添加attrs属性1stackContent.push(&#123;&#x27;tag&#x27;: tag, &#x27;children&#x27;: [],&#x27;attrs&#x27;:parseAttrString(attrString)&#125;); 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980var templateStr = &#x27;&lt;div&gt;&lt;p id=&quot;div&quot; class=&quot;box p&quot;&gt;aaa&lt;/p&gt;&lt;ul&gt;&lt;li&gt;a&lt;/li&gt;&lt;li&gt;b&lt;/li&gt;&lt;li&gt;c&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&#x27;;parseHtml(templateStr)function parseHtml(templateStr) &#123; // 指针 var index = 0; var stackTag = []; var stackContent = [&#123;&#x27;children&#x27;: []&#125;]; var rest = templateStr; var startRegExp = /^\\&lt;([a-z]+[1-6]?)(\\s[^\\&lt;]+)?\\&gt;/; var endRegExp = /^\\&lt;\\/([a-z]+[1-6]?)\\&gt;/; var wordRegExp = /^([^\\&lt;]+)\\&lt;\\/[a-z]+[1-6]?\\&gt;/; while (index &lt; templateStr.length - 1) &#123; rest = templateStr.substring(index) // 识别开始字符是不是开始标签 if (startRegExp.test(rest)) &#123; // 获取开始标记 let tag = rest.match(startRegExp)[1]; let attrString = rest.match(startRegExp)[2]; // 将开始标记推入栈中 stackTag.push(tag); // 将空数组推入栈中 stackContent.push(&#123;&#x27;tag&#x27;: tag, &#x27;children&#x27;: [],&#x27;attrs&#x27;:parseAttrString(attrString)&#125;); index += tag.length + 2 + (attrString != null?attrString.length:0); &#125; else if (endRegExp.test(rest)) &#123; // 获取结束标记 let tag = rest.match(endRegExp)[1]; let pop_tag = stackTag.pop(); // 判断跟栈顶的标记是不是同一个 if (tag == pop_tag) &#123; let pop_arr = stackContent.pop(); if (stackContent.length &gt; 0) &#123; stackContent[stackContent.length - 1].children.push(pop_arr); &#125; &#125; else &#123; throw new Error(stackTag[stackTag.length - 1] + &quot;没有闭合&quot;) &#125; index += tag.length + 3; &#125; else if (wordRegExp.test(rest)) &#123; let word = rest.match(wordRegExp)[1]; // 判断内容是否为空 if (!/^\\s+$/.test(word)) &#123; stackContent[stackContent.length - 1].children.push(&#123;&#x27;text&#x27;: word, &#x27;type&#x27;: 3&#125;) &#125; index += word.length; &#125; else &#123; index++; &#125; &#125; console.log(stackContent[0].children[0])&#125;function parseAttrString(attrString) &#123; if(attrString == undefined)return []; var isYinhao = false; var point = 0; var result = []; for (var i = 0;i&lt;attrString.length;i++)&#123; let char = attrString[i]; if(char == &#x27;&quot;&#x27;)&#123; isYinhao = !isYinhao; &#125;else if (char == &#x27; &#x27; &amp;&amp; !isYinhao)&#123; if(!/^\\s*$/.test(attrString.substring(point,i))) &#123; result.push(attrString.substring(point,i).trim()); point = i; &#125; &#125; &#125; result.push(attrString.substring(point).trim()) result = result.map(item =&gt; &#123; // 根据=拆分 let o = item.match(/^(.+)=&quot;(.+)&quot;$/); return &#123; name: o[1], value: o[2] &#125; &#125;) return result&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://wisiw.github.io.git/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://wisiw.github.io.git/tags/Vue/"},{"name":"源码解析","slug":"源码解析","permalink":"https://wisiw.github.io.git/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"name":"AST语法树","slug":"AST语法树","permalink":"https://wisiw.github.io.git/tags/AST%E8%AF%AD%E6%B3%95%E6%A0%91/"},{"name":"模板解析","slug":"模板解析","permalink":"https://wisiw.github.io.git/tags/%E6%A8%A1%E6%9D%BF%E8%A7%A3%E6%9E%90/"}]},{"title":"【源码解析】Vue：判断是否是html标签","slug":"【源码解析】Vue：判断是否是html标签","date":"2021-02-01T01:18:20.000Z","updated":"2021-09-23T05:51:47.480Z","comments":true,"path":"2021/02/01/【源码解析】Vue：判断是否是html标签/","link":"","permalink":"https://wisiw.github.io.git/2021/02/01/%E3%80%90%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91Vue%EF%BC%9A%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AFhtml%E6%A0%87%E7%AD%BE/","excerpt":"","text":"1234567891011121314151617181920212223242526272829// vue/dist/vue.js// 5589var isHTMLTag = makeMap( &#x27;html,body,base,head,link,meta,style,title,&#x27; + &#x27;address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,&#x27; + &#x27;div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,&#x27; + &#x27;a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,&#x27; + &#x27;s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,&#x27; + &#x27;embed,object,param,source,canvas,script,noscript,del,ins,&#x27; + &#x27;caption,col,colgroup,table,thead,tbody,td,th,tr,&#x27; + &#x27;button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,&#x27; + &#x27;output,progress,select,textarea,&#x27; + &#x27;details,dialog,menu,menuitem,summary,&#x27; + &#x27;content,element,shadow,template,blockquote,iframe,tfoot&#x27; );// 117function makeMap ( str, expectsLowerCase ) &#123; var map = Object.create(null); var list = str.split(&#x27;,&#x27;); for (var i = 0; i &lt; list.length; i++) &#123; map[list[i]] = true; &#125; return expectsLowerCase ? function (val) &#123; return map[val.toLowerCase()]; &#125; : function (val) &#123; return map[val]; &#125; &#125;","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://wisiw.github.io.git/tags/Vue/"},{"name":"源码","slug":"源码","permalink":"https://wisiw.github.io.git/tags/%E6%BA%90%E7%A0%81/"},{"name":"源码解析","slug":"源码解析","permalink":"https://wisiw.github.io.git/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"}]},{"title":"【Node】npm包发布","slug":"【Node】npm包发布","date":"2021-01-31T16:06:32.000Z","updated":"2021-09-23T05:57:56.244Z","comments":true,"path":"2021/02/01/【Node】npm包发布/","link":"","permalink":"https://wisiw.github.io.git/2021/02/01/%E3%80%90Node%E3%80%91npm%E5%8C%85%E5%8F%91%E5%B8%83/","excerpt":"","text":"","categories":[{"name":"前端","slug":"前端","permalink":"https://wisiw.github.io.git/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://wisiw.github.io.git/tags/Node/"},{"name":"npm","slug":"npm","permalink":"https://wisiw.github.io.git/tags/npm/"}]},{"title":"【Node】cli工具编写","slug":"【Node】cli工具编写","date":"2021-01-31T16:06:11.000Z","updated":"2021-09-23T06:01:12.751Z","comments":true,"path":"2021/02/01/【Node】cli工具编写/","link":"","permalink":"https://wisiw.github.io.git/2021/02/01/%E3%80%90Node%E3%80%91cli%E5%B7%A5%E5%85%B7%E7%BC%96%E5%86%99/","excerpt":"","text":"","categories":[{"name":"cli","slug":"cli","permalink":"https://wisiw.github.io.git/categories/cli/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://wisiw.github.io.git/tags/Node/"},{"name":"cli","slug":"cli","permalink":"https://wisiw.github.io.git/tags/cli/"}]},{"title":"【Webpack】工作原理概述","slug":"【Webpack】工作原理概述","date":"2021-01-29T08:44:56.000Z","updated":"2021-09-23T03:58:14.583Z","comments":true,"path":"2021/01/29/【Webpack】工作原理概述/","link":"","permalink":"https://wisiw.github.io.git/2021/01/29/%E3%80%90Webpack%E3%80%91%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/","excerpt":"","text":"webpack的运行流程是一个串行的过程，从启动到结束会依次执行以下流程： 初始化参数：从配置文件和shell语句中读取并合并参数，得出最终的参数 开始编译：将得到的参数初始化Compiler对象，加载所有配置的插件，通过执行对象的run方法开始执行编译 确定入口：根据配置文件中的entey找到所有的入口文件 编译模块：从入口文件出发，调用所有配置的Loader对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖文件都经过处理 完成模块编译：经过编译后，得到每个模块被翻译后的最终内容和它们之间的依赖关系 输出资源：根据入口和模块之间的依赖关系，组成一个个包含多个模块的Chunk，再将每个Chunk转换成一个单独的文件加入输出列表（此时可以最后修改输出内容） 输出完成：在确定输出内容后，根据配置确定输出的路径和文件名，将文件的内容写入文件系统中 在上述过程中，webpack会在特定的时间点广播特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用webpack提供的API改变webpack的运行结果，","categories":[],"tags":[{"name":"原理","slug":"原理","permalink":"https://wisiw.github.io.git/tags/%E5%8E%9F%E7%90%86/"},{"name":"Webpack","slug":"Webpack","permalink":"https://wisiw.github.io.git/tags/Webpack/"}]},{"title":"【读书笔记】解读React源码（《深入React技术栈》————第四章）","slug":"【读书笔记】深入了解React组件（《深入React技术栈》————第四章）","date":"2021-01-27T07:58:03.000Z","updated":"2021-09-14T06:59:31.938Z","comments":true,"path":"2021/01/27/【读书笔记】深入了解React组件（《深入React技术栈》————第四章）/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3React%E7%BB%84%E4%BB%B6%EF%BC%88%E3%80%8A%E6%B7%B1%E5%85%A5React%E6%8A%80%E6%9C%AF%E6%A0%88%E3%80%8B%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%89/","excerpt":"","text":"","categories":[{"name":"react","slug":"react","permalink":"https://wisiw.github.io.git/categories/react/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://wisiw.github.io.git/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"react","slug":"react","permalink":"https://wisiw.github.io.git/tags/react/"},{"name":"《深入React技术栈》","slug":"《深入React技术栈》","permalink":"https://wisiw.github.io.git/tags/%E3%80%8A%E6%B7%B1%E5%85%A5React%E6%8A%80%E6%9C%AF%E6%A0%88%E3%80%8B/"}]},{"title":"【读书笔记】解读React源码（《深入React技术栈》————第三章）","slug":"【读书笔记】解读React源码（《深入React技术栈》————第三章）","date":"2021-01-27T07:58:03.000Z","updated":"2021-09-14T07:00:33.296Z","comments":true,"path":"2021/01/27/【读书笔记】解读React源码（《深入React技术栈》————第三章）/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E8%A7%A3%E8%AF%BBReact%E6%BA%90%E7%A0%81%EF%BC%88%E3%80%8A%E6%B7%B1%E5%85%A5React%E6%8A%80%E6%9C%AF%E6%A0%88%E3%80%8B%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%89/","excerpt":"","text":"","categories":[{"name":"react","slug":"react","permalink":"https://wisiw.github.io.git/categories/react/"}],"tags":[{"name":"读书笔记 - React - 《深入React技术栈》","slug":"读书笔记-React-《深入React技术栈》","permalink":"https://wisiw.github.io.git/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-React-%E3%80%8A%E6%B7%B1%E5%85%A5React%E6%8A%80%E6%9C%AF%E6%A0%88%E3%80%8B/"}]},{"title":"【读书笔记】解读React源码（《深入React技术栈》————第六章）","slug":"【读书笔记】高阶组件（《深入React技术栈》————第六章）","date":"2021-01-27T07:58:03.000Z","updated":"2021-09-14T07:04:21.863Z","comments":true,"path":"2021/01/27/【读书笔记】高阶组件（《深入React技术栈》————第六章）/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%EF%BC%88%E3%80%8A%E6%B7%B1%E5%85%A5React%E6%8A%80%E6%9C%AF%E6%A0%88%E3%80%8B%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%89/","excerpt":"","text":"","categories":[{"name":"React","slug":"React","permalink":"https://wisiw.github.io.git/categories/React/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://wisiw.github.io.git/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"《深入React技术栈》","slug":"《深入React技术栈》","permalink":"https://wisiw.github.io.git/tags/%E3%80%8A%E6%B7%B1%E5%85%A5React%E6%8A%80%E6%9C%AF%E6%A0%88%E3%80%8B/"},{"name":"React","slug":"React","permalink":"https://wisiw.github.io.git/tags/React/"}]},{"title":"【读书笔记】架构设计：多页面应用（《前端架构：从入门到微前端》———五第六章）","slug":"【读书笔记】架构设计：多页面应用（《前端架构：从入门到微前端》———五第六章）","date":"2021-01-27T07:56:49.000Z","updated":"2021-06-21T08:13:15.918Z","comments":true,"path":"2021/01/27/【读书笔记】架构设计：多页面应用（《前端架构：从入门到微前端》———五第六章）/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%EF%BC%88%E3%80%8A%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BE%AE%E5%89%8D%E7%AB%AF%E3%80%8B%E2%80%94%E2%80%94%E2%80%94%E4%BA%94%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%89/","excerpt":"","text":"","categories":[{"name":"前端架构","slug":"前端架构","permalink":"https://wisiw.github.io.git/categories/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"微前端","slug":"微前端","permalink":"https://wisiw.github.io.git/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"},{"name":"前端 - 架构","slug":"前端-架构","permalink":"https://wisiw.github.io.git/tags/%E5%89%8D%E7%AB%AF-%E6%9E%B6%E6%9E%84/"}]},{"title":"【Echarts】读取本地Excel生成Echarts","slug":"【Echarts】读取本地Excel生成Echarts","date":"2021-01-27T07:54:50.000Z","updated":"2021-09-23T06:09:12.197Z","comments":true,"path":"2021/01/27/【Echarts】读取本地Excel生成Echarts/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/%E3%80%90Echarts%E3%80%91%E8%AF%BB%E5%8F%96%E6%9C%AC%E5%9C%B0Excel%E7%94%9F%E6%88%90Echarts/","excerpt":"","text":"","categories":[],"tags":[{"name":"Echarts","slug":"Echarts","permalink":"https://wisiw.github.io.git/tags/Echarts/"},{"name":"Excel","slug":"Excel","permalink":"https://wisiw.github.io.git/tags/Excel/"}]},{"title":"【读书笔记】架构设计：单页面应用（《前端架构：从入门到微前端》—第六）—","slug":"【读书笔记】架构设计：单页面应用（《前端架构：从入门到微前端》—第六）—","date":"2021-01-27T07:53:42.000Z","updated":"2021-06-21T08:13:15.277Z","comments":true,"path":"2021/01/27/【读书笔记】架构设计：单页面应用（《前端架构：从入门到微前端》—第六）—/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%EF%BC%88%E3%80%8A%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BE%AE%E5%89%8D%E7%AB%AF%E3%80%8B%E2%80%94%E7%AC%AC%E5%85%AD%EF%BC%89%E2%80%94/","excerpt":"","text":"","categories":[{"name":"前端架构","slug":"前端架构","permalink":"https://wisiw.github.io.git/categories/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"前端架构","slug":"前端架构","permalink":"https://wisiw.github.io.git/tags/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/"},{"name":"微前端","slug":"微前端","permalink":"https://wisiw.github.io.git/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"}]},{"title":"【Docker】使用","slug":"【Docker】使用","date":"2021-01-27T07:49:28.000Z","updated":"2021-09-23T06:00:37.259Z","comments":true,"path":"2021/01/27/【Docker】使用/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/%E3%80%90Docker%E3%80%91%E4%BD%BF%E7%94%A8/","excerpt":"","text":"","categories":[{"name":"后端","slug":"后端","permalink":"https://wisiw.github.io.git/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://wisiw.github.io.git/tags/Docker/"},{"name":"后端","slug":"后端","permalink":"https://wisiw.github.io.git/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"【Angular】使用","slug":"【Angular】使用","date":"2021-01-27T07:48:49.000Z","updated":"2021-09-23T06:01:40.064Z","comments":true,"path":"2021/01/27/【Angular】使用/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/%E3%80%90Angular%E3%80%91%E4%BD%BF%E7%94%A8/","excerpt":"","text":"","categories":[{"name":"Angular","slug":"Angular","permalink":"https://wisiw.github.io.git/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"https://wisiw.github.io.git/tags/Angular/"}]},{"title":"TypeScript使用","slug":"【JavaScript】TypeScript使用","date":"2021-01-27T07:48:29.000Z","updated":"2021-06-21T08:13:05.827Z","comments":true,"path":"2021/01/27/【JavaScript】TypeScript使用/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/%E3%80%90JavaScript%E3%80%91TypeScript%E4%BD%BF%E7%94%A8/","excerpt":"","text":"","categories":[{"name":"前端","slug":"前端","permalink":"https://wisiw.github.io.git/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://wisiw.github.io.git/tags/TypeScript/"},{"name":"使用","slug":"使用","permalink":"https://wisiw.github.io.git/tags/%E4%BD%BF%E7%94%A8/"}]},{"title":"linux集群","slug":"linux集群","date":"2021-01-27T07:47:42.000Z","updated":"2021-06-21T08:13:01.070Z","comments":true,"path":"2021/01/27/linux集群/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/linux%E9%9B%86%E7%BE%A4/","excerpt":"","text":"","categories":[{"name":"后端","slug":"后端","permalink":"https://wisiw.github.io.git/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://wisiw.github.io.git/tags/linux/"},{"name":"集群","slug":"集群","permalink":"https://wisiw.github.io.git/tags/%E9%9B%86%E7%BE%A4/"}]},{"title":"【JavaScript】设计模式","slug":"【JavaScript】设计模式","date":"2021-01-27T07:47:26.000Z","updated":"2021-09-23T05:57:36.165Z","comments":true,"path":"2021/01/27/【JavaScript】设计模式/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/%E3%80%90JavaScript%E3%80%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"","categories":[{"name":"前端","slug":"前端","permalink":"https://wisiw.github.io.git/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript - 设计模式","slug":"JavaScript-设计模式","permalink":"https://wisiw.github.io.git/tags/JavaScript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"nginx使用","slug":"nginx使用","date":"2021-01-27T07:46:58.000Z","updated":"2021-06-21T08:13:03.420Z","comments":true,"path":"2021/01/27/nginx使用/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/nginx%E4%BD%BF%E7%94%A8/","excerpt":"","text":"","categories":[{"name":"代码工具","slug":"代码工具","permalink":"https://wisiw.github.io.git/categories/%E4%BB%A3%E7%A0%81%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://wisiw.github.io.git/tags/Nginx/"},{"name":"代码工具","slug":"代码工具","permalink":"https://wisiw.github.io.git/tags/%E4%BB%A3%E7%A0%81%E5%B7%A5%E5%85%B7/"}]},{"title":"【git】常用方法列表","slug":"【git】常用方法列表","date":"2021-01-27T07:46:16.000Z","updated":"2021-09-23T05:58:16.282Z","comments":true,"path":"2021/01/27/【git】常用方法列表/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/%E3%80%90git%E3%80%91%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E5%88%97%E8%A1%A8/","excerpt":"","text":"","categories":[{"name":"代码工具","slug":"代码工具","permalink":"https://wisiw.github.io.git/categories/%E4%BB%A3%E7%A0%81%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"代码工具","slug":"代码工具","permalink":"https://wisiw.github.io.git/tags/%E4%BB%A3%E7%A0%81%E5%B7%A5%E5%85%B7/"},{"name":"git","slug":"git","permalink":"https://wisiw.github.io.git/tags/git/"}]},{"title":"【源码解析】Promise","slug":"【源码解析】Promise","date":"2021-01-27T07:45:29.000Z","updated":"2021-09-23T05:53:39.202Z","comments":true,"path":"2021/01/27/【源码解析】Promise/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/%E3%80%90%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91Promise/","excerpt":"","text":"构造函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236/** * Promise构造函数 * excutor：执行器函数（同步执行） * @param excutor */function Promise(executor) &#123; const _this = this; _this.status = &quot;pending&quot;; // 给Promise对象指定status属性，初始值为pending _this.data = undefined; // 给Promise对象指定一个用于存储结果数据的属性 _this.callbacks = []; // 每个元素的结构：&#123;onResolve()&#123;&#125;,onReject()&#123;&#125;&#125; function resolve(value) &#123; // 如果状态已经修改，返回 if (_this.status !== &quot;pending&quot;) return; // 修改状态为fullFilled _this.status = &quot;fullFilled&quot;; // 保存value数据 _this.data = value; if (_this.callbacks.length &gt; 0) &#123; setTimeout(function () &#123; // 放入队列中执行所有成功的回调 _this.callbacks.forEach(callbackObj =&gt; &#123; callbackObj.onResolved(value) &#125;) &#125;) &#125; &#125; function reject(reason) &#123; // 如果状态已经修改，返回 if (_this.status !== &quot;pending&quot;) return; // 修改状态为fullFilled _this.status = &quot;rejected&quot;; // 保存value数据 _this.data = reason; if (_this.callbacks.length &gt; 0) &#123; setTimeout(function () &#123; // 放入队列中执行所有成功的回调 _this.callbacks.forEach(callbackObj =&gt; &#123; callbackObj.onRejected(reason) &#125;) &#125;) &#125; &#125; // 立即同步执行excutor try &#123; executor(resolve, reject) &#125; catch (reason) &#123; // 如果执行器抛出异常，Promise对象变为rejected状态 reject(reason) &#125;&#125;/** * Promise原型对象的then()，指定成功和失败的回调函数，返回一个新的Promise对象 * @param onResolved * @param onRejected */Promise.prototype.then = function (onResolved, onRejected) &#123; onResolved = typeof onResolved === &#x27;function&#x27; ? onResolved : value =&gt; value; // 向后传递成功的value // 指定默认的失败回调（实现错误/异常传递的关键点） onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : reason =&gt; &#123; throw reason &#125; // 向后传递失败的reason const _this = this; /** 调用指定回调函数执行 */ return new Promise((resolve, reject) =&gt; &#123; function handler(callback) &#123; /** 1. 如果抛出异常，return的Promise就会失败，reason就是error 2. 如果回调函数返回的不是Promise，return的Promise就会成功，value就是返回的值 3. 如果回调函数返回的是Promise，return的Promise结果就是这个Promise的结果 */ try &#123; const result = callback(_this.data); if (result instanceof Promise) &#123; result.then( value =&gt; resolve(value), // 当result成功时，让return的Promise也成功 reason =&gt; reject(reason) // 当result失败时，让return的Promise也失败 ) // 简洁写法 // result.then(resolve,reject) &#125; else &#123; resolve(result) &#125; &#125; catch (error) &#123; reject(error) &#125; &#125; // 当前状态还是pending状态，将回调函数保存 if (_this.status === &quot;pending&quot;) &#123; _this.callbacks.push(&#123; onResolved() &#123; handler(onResolved) &#125;, onRejected() &#123; handler(onRejected) &#125; &#125;) &#125; else if (_this.status === &quot;fullFilled&quot;) &#123; // 如果当前是fullFilled状态，异步执行onResolve并改变return的promise状态 setTimeout(() =&gt; &#123; handler(onResolved) &#125;) &#125; else &#123; // 如果当前是rejected状态，异步执行onReject并改变return的promise状态 setTimeout(() =&gt; &#123; handler(onRejected) &#125;) &#125; &#125;)&#125;;/** * Promise原型对象的catch()，指定失败的回调函数，返回一个新的Promise对象 * @param onRejected */Promise.prototype.catch = function (onRejected) &#123; return this.then(undefined, onRejected)&#125;;/** * Promise函数对象的resolve方法，返回一个指定value的成功的Promise * @param value */Promise.resolve = function (value) &#123; // 返回一个成功/失败的Promise return new Promise((resolve, reject) =&gt; &#123; // value是promise if (value instanceof Promise) &#123; value.then(resolve, reject) &#125; else &#123; resolve(value) &#125; &#125;)&#125;/** * Promise函数对象的reject方法，返回一个指定reason的失败的Promise * @param reason */Promise.reject = function (reason) &#123; // 返回一个失败的promise return new Promise((resolve, reject) =&gt; &#123; reject(reason) &#125;)&#125;/** * Promise函数对象的all方法，返回一个Promise，只有当所有的Promise都成功时才成功，否则只要有一个失败的就失败 * @param promises */Promise.all = function (promises) &#123; // 保存所有成功value的数组 const values = new Array(promises.length); // 用来保存成功Promise的数量 let count = 0; return new Promise((resolve, reject) =&gt; &#123; // 遍历获取每个Promise的结果 promises.forEach((p, index) =&gt; &#123; p.then( value =&gt; &#123; // 成功了数量+1 count++; // p成功，将成功的value保存入values values[index] = value; // 如果全部成功了，将return的Promise状态改为成功 if (count === promises.length) resolve(values); &#125;, reason =&gt; &#123; // 只要一个失败了，return的Promise就会失败 reject(reason) &#125; ) &#125;) &#125;)&#125;/** * Promise函数对象的race方法，返回一个Promise，只有当所有的Promise都成功时才成功，否则只要有一个失败的就失败 * @param promises */Promise.race = function (promises) &#123; return new Promise((resolve, reject) =&gt; &#123; // 遍历promises获取每个promise的结果 promises.forEach((p, index) =&gt; &#123; p.then( value =&gt; &#123; // 一旦成功了，就将返回的Promise状态变为成功 resolve(value) &#125;, reason =&gt; &#123; // 一旦失败了，就将返回的Promise状态变为失败 reject(reason) &#125; ) &#125;) &#125;)&#125;/** * 返回一个Promise对象，在指定的时间后才确定结果 * @param value * @param time */Promise.resolveDelay = function (value, time) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; if (value instanceof Promise) &#123; value.then(resolve, reject) &#125; else &#123; resolve(value) &#125; &#125;, time) &#125;)&#125;/** * 返回一个Promise对象，在指定的时间后才确定失败 * @param reason * @param time */Promise.rejectDelay = function (reason, time) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(reason) &#125;) &#125;, time)&#125;window.Promise = Promise; class版本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162class Promise &#123; constructor(executor) &#123; const _this = this; _this.status = &quot;pending&quot;; // 给Promise对象指定status属性，初始值为pending _this.data = undefined; // 给Promise对象指定一个用于存储结果数据的属性 _this.callbacks = []; // 每个元素的结构：&#123;onResolve()&#123;&#125;,onReject()&#123;&#125;&#125; function resolve(value) &#123; // 如果状态已经修改，返回 if (_this.status !== &quot;pending&quot;) return; // 修改状态为fullFilled _this.status = &quot;fullFilled&quot;; // 保存value数据 _this.data = value; if (_this.callbacks.length &gt; 0) &#123; setTimeout(function () &#123; // 放入队列中执行所有成功的回调 _this.callbacks.forEach(callbackObj =&gt; &#123; callbackObj.onResolved(value) &#125;) &#125;) &#125; &#125; function reject(reason) &#123; // 如果状态已经修改，返回 if (_this.status !== &quot;pending&quot;) return; // 修改状态为fullFilled _this.status = &quot;rejected&quot;; // 保存value数据 _this.data = reason; if (_this.callbacks.length &gt; 0) &#123; setTimeout(function () &#123; // 放入队列中执行所有成功的回调 _this.callbacks.forEach(callbackObj =&gt; &#123; callbackObj.onRejected(reason) &#125;) &#125;) &#125; &#125; // 立即同步执行executor try &#123; executor(resolve, reject) &#125; catch (reason) &#123; // 如果执行器抛出异常，Promise对象变为rejected状态 reject(reason) &#125; &#125; then(onResolve, onReject) &#123; onResolve = typeof onResolve === &#x27;function&#x27; ? onResolve : value =&gt; value; onReject = typeof onReject === &#x27;function&#x27; ? onReject : reason =&gt; throw reason; const _this = this; return new Promise((resolve, reject) =&gt; &#123; function handle(callback) &#123; try &#123; const result = callback(_this.data) if (result instanceof Promise) &#123; result.then( value =&gt; resolve(value), reason =&gt; reject(reason) ) &#125; else &#123; resolve(result) &#125; &#125; catch (error) &#123; reject(error) &#125; &#125; if (_this.status === &quot;pending&quot;) &#123; _this.callbacks.push(&#123; onResolved() &#123; handle(onResolve) &#125;, onRejected() &#123; handle(onReject) &#125; &#125;) &#125; else if (_this.status === &quot;fullFilled&quot;) &#123; setTimeout(() =&gt; &#123; handle(resolve) &#125;) &#125; else if (_this.status === &quot;rejected&quot;) &#123; setTimeout(() =&gt; &#123; handle(reject) &#125;) &#125; &#125;) &#125; catch(onRejected) &#123; return this.then(undefined, onRejected) &#125; static resolve(value)&#123; return new Promise((resolve,reject)=&gt;&#123; if(value instanceof Promise)&#123; value.then(resolve,reject) &#125;else&#123; resolve(value) &#125; &#125;) &#125; static reject(reason)&#123; return new Promise((resolve,reject)=&gt;&#123; reject(reason) &#125;) &#125; static all(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; const values = new Array(promises.length); let count = 0; promises.forEach((p, index) =&gt; &#123; p.then( value =&gt; &#123; count++; values[index] = value; if (count === promises.length) resolve(values) &#125;, reject ) &#125;) &#125;) &#125; static race(promise) &#123; return new Promise((resolve, reject) =&gt; &#123; promise.forEach((p, index) =&gt; &#123; p.then( value =&gt; resolve(value), reason =&gt; reject(reason) ) &#125;) &#125;) &#125; static resolveDelay(value, time) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; if (value instanceof Promise) &#123; value.then(resolve,reject) &#125; else &#123; resolve(value) &#125; &#125;, time) &#125;) &#125; static rejectDelay(reason, time) &#123; return new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; reject(reason) &#125;,time) &#125;) &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://wisiw.github.io.git/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wisiw.github.io.git/tags/JavaScript/"},{"name":"Promise","slug":"Promise","permalink":"https://wisiw.github.io.git/tags/Promise/"},{"name":"源码解析","slug":"源码解析","permalink":"https://wisiw.github.io.git/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"}]},{"title":"【Webpack】热更新原理解析","slug":"【Webpack】热更新原理解析","date":"2021-01-27T07:45:11.000Z","updated":"2021-09-23T03:58:14.587Z","comments":true,"path":"2021/01/27/【Webpack】热更新原理解析/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/%E3%80%90Webpack%E3%80%91%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/","excerpt":"","text":"","categories":[],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"https://wisiw.github.io.git/tags/Webpack/"}]},{"title":"【源码解析】map","slug":"【源码解析】map","date":"2021-01-27T07:37:26.000Z","updated":"2021-09-23T05:55:48.495Z","comments":true,"path":"2021/01/27/【源码解析】map/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/%E3%80%90%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91map/","excerpt":"","text":"","categories":[{"name":"后端","slug":"后端","permalink":"https://wisiw.github.io.git/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wisiw.github.io.git/tags/Java/"},{"name":"源码解析","slug":"源码解析","permalink":"https://wisiw.github.io.git/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"name":"map","slug":"map","permalink":"https://wisiw.github.io.git/tags/map/"}]},{"title":"【源码解析】Vue：生命周期","slug":"【源码解析】Vue：生命周期","date":"2021-01-27T07:36:57.000Z","updated":"2021-09-23T05:52:31.261Z","comments":true,"path":"2021/01/27/【源码解析】Vue：生命周期/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/%E3%80%90%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91Vue%EF%BC%9A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://wisiw.github.io.git/tags/Vue/"},{"name":"源码解析","slug":"源码解析","permalink":"https://wisiw.github.io.git/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"name":"生命周期","slug":"生命周期","permalink":"https://wisiw.github.io.git/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"}]},{"title":"【源码解析】axios使用与源码解析","slug":"【源码解析】axios使用与源码解析","date":"2021-01-27T07:36:11.000Z","updated":"2021-09-23T05:46:23.685Z","comments":true,"path":"2021/01/27/【源码解析】axios使用与源码解析/","link":"","permalink":"https://wisiw.github.io.git/2021/01/27/%E3%80%90%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91axios%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","excerpt":"","text":"","categories":[{"name":"axios","slug":"axios","permalink":"https://wisiw.github.io.git/categories/axios/"}],"tags":[{"name":"源码","slug":"源码","permalink":"https://wisiw.github.io.git/tags/%E6%BA%90%E7%A0%81/"},{"name":"axios","slug":"axios","permalink":"https://wisiw.github.io.git/tags/axios/"}]},{"title":"【面试题】React","slug":"【面试题】React","date":"2021-01-26T09:57:12.000Z","updated":"2021-09-23T04:00:34.544Z","comments":true,"path":"2021/01/26/【面试题】React/","link":"","permalink":"https://wisiw.github.io.git/2021/01/26/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%91React/","excerpt":"","text":"","categories":[{"name":"前端","slug":"前端","permalink":"https://wisiw.github.io.git/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://wisiw.github.io.git/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"React","slug":"React","permalink":"https://wisiw.github.io.git/tags/React/"}]},{"title":"【源码解析】Vue：数据响应式原理","slug":"【源码解析】Vue：数据响应式原理","date":"2021-01-26T09:55:19.000Z","updated":"2021-09-23T05:51:34.488Z","comments":true,"path":"2021/01/26/【源码解析】Vue：数据响应式原理/","link":"","permalink":"https://wisiw.github.io.git/2021/01/26/%E3%80%90%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91Vue%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/","excerpt":"","text":"VUE源码-数据响应式原理12345678910111213141516171819202122232425262728293031323334353637383940var data = &#123; name:&#x27;wsw&#x27;, info:[ 27, &#123;sex:1&#125; ]&#125;function observe(data)&#123; if(Array.isArray(data))&#123; data.__proto__ = arrayMethods; this.observerArray(data) &#125;else&#123; walk(data); &#125;&#125;function observerArray(value)&#123; for(let i = 0; i&lt; value.length;i++)&#123; observe(value[i]) &#125;&#125;function walk(data)&#123; let keys = Object.keys(data); keys.forEach((key) =&gt; &#123; defineReactive(data,key,data[key]) &#125;)&#125;function defineReactive(data,key,value) &#123; observe(value) Object.defineProperty(data,key,&#123; get() &#123; return value &#125;, set(newV) &#123; if(newV == value)return; console.log(&quot;数据修改&quot;) observe(newV) value = newV; &#125; &#125;)&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041// 重写数组的方法 push/shift/unshift/pop/reverse/sort/splicelet oldArrayMethods = Array.prototype;let arrayMethods = Object.create(oldArrayMethods);const methods = [ &#x27;push&#x27;, &quot;shift&quot;, &quot;unshift&quot;, &quot;pop&quot;, &quot;reverse&quot;, &quot;sort&quot;, &quot;splice&quot;]methods.forEach( method =&gt; &#123; arrayMethods[method] = function (...args) &#123; const result = oldArrayMethods[method].apply(this,args); let inserted; let ob = this.__ob__; switch (method) &#123; case &#x27;push&#x27;: break; case &#x27;shift&#x27;: break; case &#x27;unshift&#x27;: inserted = args; break; case &#x27;pop&#x27;: break; case &#x27;reverse&#x27;: break; case &#x27;sort&#x27;: break; case &#x27;splice&#x27;: inserted = args.splice(2) break; default: break; &#125; if(inserted)ob.observerArray(inserted); // 当新增属性继续观测 return result; &#125;&#125;)","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://wisiw.github.io.git/tags/Vue/"},{"name":"源码","slug":"源码","permalink":"https://wisiw.github.io.git/tags/%E6%BA%90%E7%A0%81/"},{"name":"数据响应式","slug":"数据响应式","permalink":"https://wisiw.github.io.git/tags/%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/"}]},{"title":"【源码解析】Vue：虚拟DOM与diff算法","slug":"【源码解析】Vue：虚拟DOM与diff算法","date":"2021-01-26T09:55:03.000Z","updated":"2021-09-23T05:52:51.853Z","comments":true,"path":"2021/01/26/【源码解析】Vue：虚拟DOM与diff算法/","link":"","permalink":"https://wisiw.github.io.git/2021/01/26/%E3%80%90%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91Vue%EF%BC%9A%E8%99%9A%E6%8B%9FDOM%E4%B8%8Ediff%E7%AE%97%E6%B3%95/","excerpt":"","text":"","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://wisiw.github.io.git/tags/Vue/"},{"name":"源码解析","slug":"源码解析","permalink":"https://wisiw.github.io.git/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"name":"虚拟DOM与diff算法","slug":"虚拟DOM与diff算法","permalink":"https://wisiw.github.io.git/tags/%E8%99%9A%E6%8B%9FDOM%E4%B8%8Ediff%E7%AE%97%E6%B3%95/"}]},{"title":"【源码解析】Vue：模板引擎","slug":"【源码解析】Vue：模板引擎","date":"2021-01-26T09:54:43.000Z","updated":"2021-09-23T05:52:20.071Z","comments":true,"path":"2021/01/26/【源码解析】Vue：模板引擎/","link":"","permalink":"https://wisiw.github.io.git/2021/01/26/%E3%80%90%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91Vue%EF%BC%9A%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/","excerpt":"","text":"","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://wisiw.github.io.git/tags/Vue/"},{"name":"源码解析","slug":"源码解析","permalink":"https://wisiw.github.io.git/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"name":"模板引擎","slug":"模板引擎","permalink":"https://wisiw.github.io.git/tags/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"}]},{"title":"算法","slug":"算法","date":"2021-01-26T09:53:39.000Z","updated":"2021-06-21T08:13:22.325Z","comments":true,"path":"2021/01/26/算法/","link":"","permalink":"https://wisiw.github.io.git/2021/01/26/%E7%AE%97%E6%B3%95/","excerpt":"","text":"斐波那契数列使用递归123456789101112var cache = &#123;&#125;;function fib(n)&#123; if(cache.hasOwnProperty(n))&#123; return cache[n]; &#125; var v= n == 0 || n == 1?fib(n-1) + fib(n-2) cache[n] = v; return v;&#125;for(let i=0;i&lt;=9;i++)&#123; fib(i);&#125; 不使用递归123456function a(n)&#123; var arr = [1,1]; while(arr.length &lt;= n)&#123; arr.push(arr[arr.length-1] + arr[ arr.length-2])&#125;console.log(arr) 重复字符串中连续重复次数最多的字符12345678910111213var s = &quot;aaadafakssssshhhhhrrrrrgggggkkkkkffffwwwwddddd&quot;var maxRepeatCount = 0,maxReapeatChar = &#x27;&#x27;;var i = 0,j = 1;while ( i &lt;= s.length - 1 ) &#123; if(s[i] !== s[j])&#123; i = j; if(maxRepeatCount &lt; j-i)&#123; maxRepeatCount = j-i; maxReapeatChar = s[i] &#125; &#125; j++;&#125; 智能重复123456789101112131415161718192021222324252627282930var str = &quot;2[1[a]3[b]2[3[c]4[d]]]&quot;;function smartRepeat(str) &#123; var index = 0, stack1 = [], stack2 = [], rest = str; while (index &lt; str.length - 1) &#123; rest = str.substring(index); if (/^\\d+\\[/.test(rest)) &#123; // 剩余字符串以数字开头，1）取出这个数字压入数字栈；2）字符栈压入空字符串；3）指针后移至[之后 let times = Number(rest.match(/^(\\d+)\\[/)[1]); stack1.push(times); stack2.push(&#x27;&#x27;); index += times.toString().length + 1; &#125; else if (/^\\w+\\]/.test(rest)) &#123; // 剩余字符串以字母开头，1）取出字符并压入字符栈；2）指针后移至字符之后 let word = rest.match(/^(\\w+)\\]/)[1]; stack2[stack2.length - 1] = word; index += word.length; &#125; else if (rest[0] == &#x27;]&#x27;)&#123; // 剩余字符串以]开头，1）数字栈弹栈；2）字符栈弹栈3）弹出的字符重复刚才弹栈的次数并拼接到新的字符栈顶 let times = stack1.pop(); let word = stack2.pop(); stack2[stack2.length - 1] += word.repeat(times) index++; &#125; &#125; // 当while结束后，stack1和stack2中肯定存在剩余1项，返回stack2中剩余的这一项，重复stack1中剩余的这一项的次数，返回这个字符串 return stack2[0].repeat(stack1[0])&#125; 判断标签是否闭合使用while与replace12345678910function isValid(s) &#123; while (s.length) &#123; let temp = s; s = s.replace(&#x27;()&#x27;, &#x27;&#x27;); s = s.replace(&#x27;[]&#x27;, &#x27;&#x27;); s = s.replace(&#x27;&#123;&#125;&#x27;, &#x27;&#x27;); if (s == temp) return false &#125; return true;&#125; 使用指针与栈123456789101112131415161718function isValid(s) &#123; let map = &#123; &#x27;&#123;&#x27;: &#x27;&#125;&#x27;, &#x27;(&#x27;: &#x27;)&#x27;, &#x27;[&#x27;: &#x27;]&#x27; &#125; let stack = [] for(let i = 0; i &lt; s.length ; i++) &#123; // 如果此字符在集合中存在，存入栈中 if(map[s[i]]) &#123; stack.push(s[i]) &#125; else if(s[i] !== map[stack.pop()])&#123; // 如果此字符与栈顶不同，则说明字符串并不是封闭的 return false &#125; &#125; return stack.length === 0&#125; 树树的遍历深度优先（DFC）以深度优先为策略，从根节点开始一直遍历到某个叶子结点，再遍历另外一个分支 广度优先（BFC）##路径总和 相同的树对称二叉树翻转二叉树另一个树的子树验证二叉搜索树二叉树的最小深度平衡二叉树将有序数组转换为二叉搜索树二叉搜索树迭代器二叉搜索树的最近公共祖先二叉树的最近公共祖先链表合并两个有序链表反转链表回文链表倒数第K个节点找出链表的中间节点两个链表的第一个公共节点LRU的缓存机制#数组 打乱数组构建乘积数组##使数组唯一的最小增量##扑克牌中的顺子##数组的交集##数组的交集II##数组中的第K个最大元素##合并两个有序数组##全排列##螺旋矩阵##螺旋矩阵II##三数之和##更接近的三数之和 数学##计算质数##求众数##中位数##只出现一次的数字##有效的三角形个数 #动态规划 斐波那契数列买卖股票的最佳时机I买卖股票的最佳时机II盛最多水的容器接雨水无重复字符的最长子串最大子序和最长公共前缀最长回文子串打家劫舍打家劫舍 II打家劫舍 III","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://wisiw.github.io.git/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【代码片段】根据字符串路径访问对象的成员","slug":"【代码片段】根据字符串路径访问对象的成员","date":"2020-03-01T01:19:38.000Z","updated":"2021-09-23T06:07:06.533Z","comments":true,"path":"2020/03/01/【代码片段】根据字符串路径访问对象的成员/","link":"","permalink":"https://wisiw.github.io.git/2020/03/01/%E3%80%90%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E3%80%91%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%B7%AF%E5%BE%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%88%90%E5%91%98/","excerpt":"","text":"1234567891011121314151617181920/** * 在dataObj对象中，寻找用连续.符号（a.b.c）的keyName属性 * @param dataObj * @param keyName */function lookUp(dataObj, keyName) &#123; // 查看传入的keyName中有没有.符号 if (keyName.indexOf(&#x27;.&#x27;) != -1) &#123; let names = keyName.split(&quot;.&quot;); // 设置临时变量，存储当前层查找到的数据 let temp = dataObj; for (let i = 0; i &lt; names.length; i++) &#123; // 每找一层，就将临时变量设为新的 temp = temp[names[i]] &#125; return temp; &#125; // 如果没有.符号，直接返回dataObj[keyName] return dataObj[keyName]&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://wisiw.github.io.git/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://wisiw.github.io.git/tags/Vue/"},{"name":"源码","slug":"源码","permalink":"https://wisiw.github.io.git/tags/%E6%BA%90%E7%A0%81/"},{"name":"代码片段","slug":"代码片段","permalink":"https://wisiw.github.io.git/tags/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"}]},{"title":"【代码片段】瀑布流","slug":"【代码片段】瀑布流","date":"2020-02-27T07:54:19.000Z","updated":"2021-09-23T06:05:53.301Z","comments":true,"path":"2020/02/27/【代码片段】瀑布流/","link":"","permalink":"https://wisiw.github.io.git/2020/02/27/%E3%80%90%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E3%80%91%E7%80%91%E5%B8%83%E6%B5%81/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html&gt;&lt;html lang=&quot;ch&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; body&#123; width: 100%; height: 100%; &#125; .main&#123; position: static; margin: 0; border: 0; padding: 0; background-color: antiquewhite; overflow: hidden; &#125; .main div&#123; width: 100px; padding: 10px; position: absolute; display: inline-block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;img style=&quot;width:100%;height: 200px&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;img style=&quot;width:100%;height: 151px&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;img style=&quot;width:100%;height: 256px&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;img style=&quot;width:100%;height: 331px&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;img style=&quot;width:100%;height: 222px&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;img style=&quot;width:100%;height: 444px&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;img style=&quot;width:100%;height: 111px&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;img style=&quot;width:100%;height: 531px&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;img style=&quot;width:100%;height: 661px&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;img style=&quot;width:100%;height: 145px&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;img style=&quot;width:100%;height: 103px&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;img style=&quot;width:100%;height: 133px&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; f(); window.onresize = () =&gt; f() function f() &#123; var box = document.getElementsByClassName(&quot;box&quot;), boxWidth = box[0].offsetWidth, screenWidth = document.getElementsByClassName(&quot;main&quot;)[0].offsetWidth, cols = parseInt(screenWidth/boxWidth), heightArr = []; for(let i =0 ;i&lt;box.length;i++)&#123; let boxHeight = box[i].offsetHeight, left = 0, top = 0; box[i].style.position = &quot;absolute&quot;; if(i&lt;cols)&#123; left = i * boxWidth; top = 0; heightArr[i] = boxHeight; &#125;else&#123; let num = parseInt(i%cols), min = Math.min(...heightArr), key = heightArr.indexOf(min); left = key * boxWidth; top = min; heightArr[key] += boxHeight; &#125; box[i].style.left = left + &quot;px&quot;; box[i].style.top = top + &quot;px&quot;; &#125; &#125;&lt;/script&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://wisiw.github.io.git/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"代码片段","slug":"代码片段","permalink":"https://wisiw.github.io.git/tags/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"},{"name":"瀑布流","slug":"瀑布流","permalink":"https://wisiw.github.io.git/tags/%E7%80%91%E5%B8%83%E6%B5%81/"}]},{"title":"【面试题】Vue","slug":"【面试题】Vue","date":"2020-01-25T07:17:13.000Z","updated":"2021-09-23T03:55:22.986Z","comments":true,"path":"2020/01/25/【面试题】Vue/","link":"","permalink":"https://wisiw.github.io.git/2020/01/25/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%91Vue/","excerpt":"","text":"生命周期VUE实例从创建到销毁的过程 浏览器渲染有8个钩子，服务端渲染只有beforeCreate和created beforeCreate当前阶段data、methods、computed、watch上的数据和方法都不能访问 可以在这加个loading事件，在加载实例时触发 created实例创建完成，当前阶段已经完成了数据观测，此时修改数据不会触发updated函数，可以在当前阶段获取一些初始数据，但DOM节点$el未创建，无法进行交互，但是可以通过$nextTick访问 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用 beforeMount挂载之前，在这之前template模板已导入渲染函数编译，虚拟DOM已经创建完成，即将开始渲染，此时可以进行数据更改，不会触发updated mounted挂载完成之后，真实DOM挂载完毕，数据完成双向绑定，可以访问到DOM节点，可以使用$ref对DOM进行操作 获取到DOM节点;对数据统一处理 beforeUpdate发生在更新之前，通过响应式数据更新触发，发生在虚拟DOM重新渲染之前，可以在当前阶段更改数据，不会造成重新渲染 update更新完成之后，当前节点组件DOM更新完成，避免在此阶段更改数据，因为可能会导致无限循环 beforeDestory实例销毁之前，当前阶段组件实例还存在，可以在当前阶段清除计时器、销毁父组件对子组件的重复监听 destoryed实例销毁之后，组件已被拆解，数据绑定被卸除，监听被移除，子实例被销毁 生命周期调用顺序为什么 vue 组件中 data 必须是一个函数？对象为引用类型，当复用组件时，由于数据对象都指向同一个 data 对象，当在一个组件中修改 data 时，其他重用的组件中的 data 会同时被修改；而使用返回对象的函数，由于每次返回的都是一个新对象（Object 的实例），引用地址不同，则不会出现这个问题。 vue 中 v-if 和 v-show 有什么区别？v-if 和 v-show 看起来似乎差不多，当条件不成立时，其所对应的标签元素都不可见，但是这两个选项是有区别的: 1、v-if 在条件切换时，会对标签进行适当的创建和销毁，而 v-show 则仅在初始化时加载一次，因此 v-if 的开销相对来说会比 v-show 大。 2、v-if 是惰性的，只有当条件为真时才会真正渲染标签；如果初始条件不为真，则 v-if 不会去渲染标签。v-show 则无论初始条件是否成立，都会渲染标签，它仅仅做的只是简单的 CSS 切换。 v-for与v-if的优先级问题1）v-for优先于v-if被解析 12// src/complier/codegen/index.js// 会优先处理for，两者不同级的话生成不同的渲染函数 2）如果同时出现，每次渲染会先执行循环再判断条件，无论如何循环都不可避免，浪费性能3）要避免这种情况，在外层嵌套template，在这一层进行v-if判断，然后在内部进行v-for Vue 组件中 data 为什么必须是函数？为什么根实例没有限制1// src/score/instance/state.js-initData() 因为Vue组件可能会存在多个实例，如果使用对象形式定义data，则会导致他们在内存中指向向同一个对象，会造成数据污染。 采用函数形式，在initData时会将其作为工厂函数返回一个全新的data对象，有效避免了多实例之间的数据污染问题。 而根实例不存在该限制，以为根实例有且只能有一个。 vue中key的作用和工作原理？1// src/core/vdom/patch.js-updateChildren() key的作用是为了高效的更新虚拟DOM，其原理是vue在patch过程中通过key精准判断两个节点是否是同一个，从而避免频繁地更新不同元素，使得整个patch过程更加高效，减少DOM的操作，提高性能 若不设置key还可能会在列表更新引发一些隐蔽的bug vue在使用相同标签名元素的过渡切换时，也会使用到key属性，其目的是为了让vue可以区分它们，否则vue只会替换内部标签属性而不会触发过渡过程 虚拟DOM为什么？虚拟DOM本质上是用JavaScript对象描述的DOM节点，是对真实DOM的抽象。 浏览器获取到页面资源后，会对页面进行渲染，分别生成DOM树和CSS样式表，合并生成Render树，进行布局绘制。 用原生JS和JQuery操作真实DOM时，浏览器会从头到尾执行一遍渲染流程，触发回流和重绘，频繁地操作DOM，会有一定的性能问题，因此需要在patch过程中尽可能的一次性将差异更新到DOM中，但还是不可避免的去操作真实DOM，因此出现了虚拟DOM，使用一个JavaScript对象去描真实的DOM节点，在patch中使用diff算法比较新旧虚拟DOM，获得最小差异，再将结果反映到真实DOM上。因为在浏览器中，js操作要比操作真实DOM迅速许多，所以可以节约大量的时间。 是什么？是一个用来描述真实DOM的JavaScript对象，在patch中使用Diff算法来获取最小更新，再反映到真实DOM中 优缺点？ 优点 保证性能下限（虽然不能达到手动优化的最好结果，但是比起粗暴的DOM操作，性能要好很多） 无需手动操作DOM 跨平台（本质上是JavaScript对象，可以更方便地跨平台操作，例如服务端渲染、移动端开发） 缺点 无法进行极致优化（比不上在代码中进行手工优化） Diff算法？diff算法是新旧虚拟DOM的比较算法，通过对两者进行比较，将变化的地方更新在真实DOM上。另外，也需要diff算法进行高效的对比过程，，从而降低时间复杂度O(n) vue2.X中为了降低watcher粒度，每个组件只有一个watcher与之对应，只有引入diff才能精确找到发生变化的地方 执行时刻是组件实例执行其更新函数patch时，它会对比上一次渲染结果的oldVnode与新的渲染结果newVnode 遵循深度优先，同层比较的策略： 两个节点之间的比较会根据他们是否有子节点或者文本节点做不同的操作； 使用列表比对，对两组子节点的头尾进行四次比较（旧前与新前、旧后与新后、旧前与新后、旧后与新前）；如果没有找到相同节点，按照通用方法遍历查找；查找结束后按照情况处理剩余节点。使用key可以精确查找到相同节点，因此patch过程非常高效 template编译先通过while和栈转化为AST树，再得到render函数返回VNode 通过compile编译器把template编译成AST语法树 AST经过generate得到render函数，render返回VNode 常用的事件修饰符 .stop: 阻止冒泡 .prevent: 阻止默认行为 .self: 仅绑定元素自身触发 .once: 2.1.4 新增，只触发一次 passive: 2.3.0 新增，滚动事件的默认行为 (即滚动行为) 将会立即触发，不能和.prevent 一起使用 .sync 修饰符 从 2.3.0 起 vue 重新引入了.sync 修饰符，但是这次它只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 v-on 监听器。示例代码如下： 1&lt;comp :foo.sync=&quot;bar&quot;&gt;&lt;/comp&gt; 会被扩展为： 1&lt;comp :foo=&quot;bar&quot; @update:foo=&quot;val =&gt; bar = val&quot;&gt;&lt;/comp&gt; 当子组件需要更新 foo 的值时，它需要显式地触发一个更新事件： 1this.$emit(&#x27;update:foo&#x27;, newValue) vue 如何获取 dom先给标签设置一个 ref 值，再通过 this.$refs.domName 获取，例如： 123&lt;div ref=&quot;test&quot;&gt;&lt;/div&gt;const dom = this.$refs.test v-on 可以监听多个方法吗？是可以的，来个例子： 1&lt;input type=&quot;text&quot; v-on=&quot;&#123; input:onInput,focus:onFocus,blur:onBlur, &#125;&quot;&gt; assets 和 static 的区别这两个都是用来存放项目中所使用的静态资源文件。 两者的区别： assets 中的文件在运行 npm run build 的时候会打包，简单来说就是会被压缩体积，代码格式化之类的。打包之后也会放到 static 中。 static 中的文件则不会被打包。 建议：将图片等未处理的文件放在 assets 中，打包减少体积。而对于第三方引入的一些资源文件如 iconfont.css 等可以放在 static 中，因为这些文件已经经过处理了。 slot 插槽很多时候，我们封装了一个子组件之后，在父组件使用的时候，想添加一些 dom 元素，这个时候就可以使用 slot 插槽了，但是这些 dom 是否显示以及在哪里显示，则是看子组件中 slot 组件的位置了。 vue 初始化页面闪动问题使用 vue 开发时，在 vue 初始化之前，由于 div 是不归 vue 管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于 的字样，虽然一般情况下这个时间很短暂，但是我们还是有必要让解决这个问题的。 首先：在 css 里加上以下代码 123[v-cloak] &#123; display: none;&#125; 如果没有彻底解决问题，则在根元素加上 style=“display: none;” :style=”{display: ‘block’}” 组件化组件化使开发者使用小型、独立和可复用的组件构建大型应用 能大幅提高应用开发效率、测试性、复用性等 按使用分类为：页面组件、业务组件、通用组件 VUE的组件是基于配置的，平时编写的组件是组件配置而非组件，框架后续会生成其构造函数，基于VueComponent，扩展于Vue vue中的组件化技术有：props、自定义事件、插槽等，主要用于组件通信、扩展等 合理的划分组件，有利于提升应用性能 组件应该是高内聚、低耦合 遵循单向数据流的原则 单向数据流是什么？所有的prop使得 其父子prop之间形成了一个单向下行绑定（父级prop的更新会向下流动到子组件中，但反过来则不行）。 为什么？防止从子组件意外改变父级组件的状态，从而导致应用的数据流向混乱 好处？组件的prop有了单一来源，每次父级组件发生更新时，子组件的所有prop都会刷新为最新值。 如果想要子组件更新父组件的状态，只能通过**$emit**派发一个自定义事件，父组件接收后，由父组件自身修改 需要改变prop的情况的处理1）prop用来传递初始值，组件将其作为一个本地data来处理此时，需要定义一个本地data的属性并将此prop作为其初始值 12345678export default &#123; props: [&#x27;initialCounter&#x27;], data: function () &#123; return &#123; counter: this.initialCounter//定义本地的data属性接收prop初始值 &#125; &#125;&#125; 2）prop以一种原始值传入，需要对其进行转换此时，最好使用这个prop的值来定义一个计算属性 12345678export default &#123; props: [&#x27;size&#x27;], computed: &#123; normalizedSize: function () &#123; return this.size.trim().toLowerCase() &#125; &#125;&#125; computed与watch计算属性 computed： 支持缓存，只有依赖数据发生改变，才会重新进行计算 不支持异步，当 computed 内有异步操作时无效，无法监听数据的变化 computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于 data 中声明过或者父组件传递的 props 中的数据通过计算得到的值 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用 computed 如果 computed 属性属性值是函数，那么默认会走 get 方法；函数的返回值就是属性的属性值；在 computed 中的，属性都有一个 get 和一个 set 方法，当数据变化时，调用 set 方法。 侦听属性 watch： 不支持缓存，数据变，直接会触发相应的操作； watch 支持异步； 监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值； 当一个属性发生变化时，需要执行对应的操作；一对多； 监听数据必须是 data 中声明过或者父组件传递过来的 props 中的数据，当数据变化时，触发其他操作，函数有两个参数： immediate：组件加载立即触发回调函数执行 1234567891011export default &#123; watch: &#123; firstName: &#123; handler(newName, oldName) &#123; this.fullName = newName + &#x27; &#x27; + this.lastName; &#125;, // 代表在wacth里声明了firstName这个方法之后立即执行handler方法 immediate: true &#125; &#125;&#125; deep: deep 的意思就是深入观察，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，但是这样性能开销就会非常大了，任何修改 obj 里面任何一个属性都会触发这个监听器里的 handler 1234567891011export default &#123; watch: &#123; obj: &#123; handler(newName, oldName) &#123; console.log(&#x27;obj.a changed&#x27;); &#125;, immediate: true, deep: true &#125; &#125;&#125; 优化：我们可以使用字符串的形式监听 1234567891011export default &#123; watch: &#123; &#x27;obj.a&#x27;: &#123; handler(newName, oldName) &#123; console.log(&#x27;obj.a changed&#x27;); &#125;, immediate: true, // deep: true &#125; &#125;&#125; 这样 Vue.js 才会一层一层解析下去，直到遇到属性 a，然后才给 a 设置监听函数。 组件通信父–&gt;子子–&gt;父兄弟vue-loadervue 文件的一个加载器，跟 template/js/style 转换成 js 模块 $nextTick 是什么？vue 实现响应式并不是数据发生变化后 dom 立即变化，而是按照一定的策略来进行 dom 更新。 nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 nextTick，则可以在回调中获取更新后的 DOM vue设计理念vue的双向绑定原理观察者（observer）利用Object.definePropertype()拿到data依赖，遍历子集依赖，如果是数组，vue是通过拦截器重写了数组的原型链方法。set拿到所有的子依赖，告诉watcher（订阅者）每收集一个子依赖就new一个订阅者，最后订阅者被收集起来，dep就是个收集器，是个集合或者数组。 complier（编译器）匹配模板中的指令，进行赋值，render到当前页面中 vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 具体步骤： 第一步：需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化 第二步：compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: 1、在自身实例化时往属性订阅器(dep)里面添加自己 2、自身必须有一个update()方法 3、待属性变动dep.notice()通知时，能调用自身的 update() 方法，并触发Compile中绑定的回调，则功成身退。 第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。 如何监听对象或者数组某个属性的变化因为Object.defineProperty()的限制，监听不到数组某一项或者对象的某个属性值的变化。 使用this.$set()或者调用splice()、 push()、pop()、shift()、unshift()、sort()、reverse() 什么是依赖需要用到数据的地方，称为依赖 Vue1.x，细粒度依赖，用到数据的DOM都是依赖 Vue2.X，中等粒度依赖，用到数据的组件是依赖 在getter中收集依赖，在setter中触发依赖 把依赖收集的代码封装成一个Dep类，专门用来管理依赖，每个Observer的实例，成员中都有一个Dep实例 Watcher是一个中介，数据发生变化时通过Watcher中转 Dep中收集的依赖是Watcher，只有Watcher触发的getter才会收集依赖，哪个Watcher触发了getter，就把哪个Watcher收集到Dep中 Dep使用了发布订阅模式，当数据发生变化时，会循环subs列表，把所有的Watcher都通知一遍 Watcher将自己设置到全局的指定位置window.target，然后读取数据，因为读取了数据，所以触发了这个数据的getter，在这个getter中就能获取当前正在读取数据的Watcher，并收集到Dep中 Vue 中操作 data 中数组的方法中哪些可以触发视图更新，哪些不可以，不可以的话有什么解决办法？push ()、pop ()、shift ()、unshift ()、splice ()、sort ()、reverse () 这些方法会改变被操作的数组； filter ()、concat ()、slice () 这些方法不会改变被操作的数组，返回一个新的数组； 以上方法都可以触发视图更新。 利用索引直接设置一个数组项，例：this.array[index] = newValue 直接修改数组的长度，例：this.array.length = newLength 以上两种方法不可以触发视图更新； 可以用 this.$set(this.array,index,newValue) 或 this.array.splice(index,1,newValue) 解决方法 1 可以用 this.array.splice(newLength) 解决方法 2 混入（mixin） 全局混入在项目中怎么用？ 在 main.js 中写入 1234 import Vue from &#39;vue&#39;; import mixins from &#39;.&#x2F;mixins&#39;; Vue.mixin(mixins);123 之后，全局混入可以写在 mixins 文件夹中 index.js 中，全局混入会影响到每一个之后创建的 Vue 实例（组件）； 局部混入在项目中怎么用 局部混入的注册，在 mixins 文件中创建一个 a_mixin.js 文件，然后再 a.vue 文件中写入 123456&lt;script&gt; import aMixin from &#x27;mixins/a_mixin&#x27; export default&#123; mixins:[aMixin], &#125;&lt;/script&gt; 局部混入只会影响 a.vue 文件中创建的 Vue 实例，不会影响到其子组件创建的 Vue 实例； 组件的选项和混入的选项是怎么合并的 数据对象【data 选项】，在内部进行递归合并，并在发生冲突时以组件数据优先； 同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用； watch 对象合并时，相同的 key 合成一个对象，且混入监听在组件监听之前调用； 值为对象的选项【filters 选项、computed 选项、methods 选项、components 选项、directives 选项】将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。 computed 中的属性名和 data 中的属性名可以相同吗？不能同名，因为不管是 computed 属性名还是 data 数据名还是 props 数据名都会被挂载在 vm 实例上，因此这三个都不能同名。 123456if (key in vm.$data) &#123; warn(&#96;The computed property &quot;$&#123;key&#125;&quot; is already defined in data.&#96;, vm)&#125; else if (vm.$options.props &amp;&amp; key in vm.$options.props) &#123; warn(&#96;The computed property &quot;$&#123;key&#125;&quot; is already defined as a prop.&#96;, vm)&#125;12345 怎么强制刷新组件？ this.$forceUpdate()。 组件上加上 key，然后变化 key 的值。 watch 的属性和 methods 方法能用箭头函数定义吗？不可以。this 会是 undefind, 因为箭头函数中的 this 指向的是定义时的 this，而不是执行时的 this，所以不会指向 Vue 实例的上下文。 给组件绑定自定义事件无效怎么解决？加上修饰词.native。 怎么访问子组件的实例或者子元素？先用 ref 特性为子组件赋予一个 ID 引用 &lt;base-input ref=&quot;myInput&quot;&gt;&lt;/&lt;base-input&gt; 比如子组件有个 focus 的方法，可以这样调用 this.$refs.myInput.focus()； 比如子组件有个 value 的数据，可以这样使用 this.$refs.myInput.value。 先用 ref 特性为普通的 DOM 元素赋予一个 ID 引用 1234&lt;ul ref=&quot;mydiv&quot;&gt; &lt;li class=&quot;item&quot;&gt;第一个li&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;第一个li&lt;/li&gt;&lt;/ul&gt; 1console.log(this.$refs[&#x27;mydiv&#x27;].getElementsByClassName(&#x27;item&#x27;)[0].innerHTML)//第一个li 怎么在子组件中访问父组件的实例？怎么在组件中访问到根实例？使用 this.$parent 来访问 1this.$root 组件会在什么时候下被销毁？ 没有使用 keep-alive 时的路由切换； v-if=&#39;false&#39;； 执行 vm.$destroy()； is 这个特性你有用过吗？主要用在哪些方面？ 动态组件 &lt;component :is=&quot;componentName&quot;&gt;&lt;/component&gt;， componentName 可以是在本页面已经注册的局部组件名和全局组件名，也可以是一个组件的选项对象。 当控制 componentName 改变时就可以动态切换选择组件。 is 的用法 有些 HTML 元素，诸如 &lt;ul&gt;、&lt;ol&gt;、&lt;table&gt; 和 &lt;select&gt;，对于哪些元素可以出现在其内部是有严格限制的。 而有些 HTML 元素，诸如 &lt;li&gt;、&lt;tr&gt; 和 &lt;option&gt;，只能出现在其它某些特定的元素内部。 123&lt;ul&gt; &lt;card-list&gt;&lt;/card-list&gt;&lt;/ul&gt; 所以上面 &lt;card-list&gt;&lt;/card-list&gt; 会被作为无效的内容提升到外部，并导致最终渲染结果出错。应该这么写： 123&lt;ul&gt; &lt;li is=&quot;cardList&quot;&gt;&lt;/li&gt;&lt;/ul&gt; prop 验证的 type 类型有哪几种？String、Number、Boolean、Array、Object、Date、Function、Symbol， 此外还可以是一个自定义的构造函数 Personnel，并且通过 instanceof 来验证 propwokrer 的值是否是通过这个自定义的构造函数创建的。 123456789function Personnel(name,age)&#123; this.name = name; this.age = age;&#125;export default &#123; props:&#123; wokrer:Personnel &#125;&#125; 在 Vue 事件中传入 $event ，使用 $event.target和 event.currentTarget 有什么区别？$event.currentTarget 始终指向事件所绑定的元素，而 $event.target 指向事件发生时的元素。 使用事件修饰符要注意什么？要注意顺序很重要，用 @click.prevent.self 会阻止所有的点击，而 @click.self.prevent 只会阻止对元素自身的点击。 说说你对 Vue 的表单修饰符.lazy 的理解？input 标签 v-model 用 lazy 修饰之后，并不会立即监听 input 的 value 的改变，会在 input 失去焦点之后，才会监听 input 的 value 的改变。 v-once 的使用场景有哪些？其作用是只渲染元素和组件一次。随后的重新渲染，元素 / 组件及其所有的子节点将被视为静态内容并跳过。故当组件中有大量的静态的内容可以使用这个指令。 v-cloak 和 v-pre 有什么作用？v-cloak：可以解决在页面渲染时把未编译的 Mustache 标签（&#123;&#123;value&#125;&#125;）给显示出来。 123456[v-cloak] &#123; display: none!important;&#125;&lt;div v-cloak&gt; &#123;&#123; message &#125;&#125;&lt;&#x2F;div&gt; v-pre：跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。 1&lt;span v-pre&gt;&#123;&#123; this will not be compiled &#125;&#125;&lt;&#x2F;span&gt; 怎么使 css 样式只在当前组件中生效？在 style 上加 scoped 属性需要注意哪些？你知道 style 上加 scoped 属性的原理吗？1&lt;style lang=&quot;less&quot; scoped&gt; &lt;/style&gt; 如果在公共组件中使用，修改公共组件的样式需要用 /deep/。 vue 通过在 DOM 结构以及 css 样式上加上唯一的标记 data-v-xxxxxx，保证唯一，达到样式私有化，不污染全局的作用。 Vue 渲染模板时怎么保留模板中的 HTML 注释呢？ 在组件中将 comments 选项设置为 true &lt;template comments&gt; ... &lt;template&gt; Vue 中怎么重置 data？1Object.assign(this.$data,this.$options.data()) 过滤器中可以用 this 吗？不可以 Vue在created和mounted这两个生命周期中请求数据有什么区别呢？在created中，页面视图未出现，如果请求信息过多，页面会长时间处于白屏状态，DOM节点没出来，无法操作DOM节点。在mounted不会这样，比较好。 说说你对keep-alive的理解keep-alive是一个抽象组件：它自身不会渲染一个DOM元素，也不会出现在父组件链中；使用keep-alive包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。 其有三个参数 include定义缓存白名单，会缓存的组件； exclude定义缓存黑名单，不会缓存的组件； 以上两个参数可以是逗号分隔字符串、正则表达式或一个数组,include=&quot;a,b&quot;、:include=&quot;/a|b/&quot;、:include=&quot;[&#39;a&#39;, &#39;b&#39;]&quot;； 匹配首先检查组件自身的 name 选项，如果 name 选项不可用，则匹配它的局部注册名称 (父组件 components 选项的键值)。匿名组件不能被匹配； max最多可以缓存多少组件实例。一旦这个数字达到了，在新实例被创建之前，已缓存组件中最久没有被访问的实例会被销毁掉； 不会在函数式组件中正常工作，因为它们没有缓存实例； 当组件在内被切换，它的activated和deactivated这两个生命周期钩子函数将会被对应执行。 使用v-for遍历对象时，是按什么顺序遍历的？如何保证顺序？按 Object.keys() 的顺序的遍历，转成数组保证顺序。 key除了在v-for中使用，还有什么作用？还可以强制替换元素/组件而不是重复使用它。在以下场景可以使用 完整地触发组件的生命周期钩子 触发过渡 123&lt;transition&gt; &lt;span :key=&quot;text&quot;&gt;&#123;&#123; text &#125;&#125;&lt;/span&gt;&lt;/transition&gt; 当 text 发生改变时，&lt;span&gt;会随时被更新，因此会触发过渡。 使用key要什么要注意的吗？ 不要使用对象或数组之类的非基本类型值作为key，请用字符串或数值类型的值； 不要使用数组的index作为key值，因为在删除数组某一项，index也会随之变化，导致key变化，渲染会出错。 例：在渲染[a,b,c]用 index 作为 key，那么在删除第二项的时候，index 就会从 0 1 2 变成 0 1（而不是 0 2)，随之第三项的key变成1了，就会误把第三项删除了。 说说组件的命名规范给组件命名有两种方式，一种是使用链式命名my-component，一种是使用大驼峰命名MyComponent， 在字符串模板中&lt;my-component&gt;&lt;/my-component&gt; 和 &lt;MyComponent&gt;&lt;/MyComponent&gt;都可以使用， 在非字符串模板中最好使用&lt;MyComponent&gt;&lt;/MyComponent&gt;，因为要遵循W3C规范中的自定义组件名 (字母全小写且必须包含一个连字符)，避免和当前以及未来的 HTML 元素相冲突。 为什么组件中data必须用函数返回一个对象？对象为引用类型，当重用组件时，由于数据对象都指向同一个data对象，当在一个组件中修改data时，其他重用的组件中的data会同时被修改；而使用返回对象的函数，由于每次返回的都是一个新对象（Object的实例），引用地址不同，则不会出现这个问题。 组件的name选项有什么作用？ 递归组件时，组件调用自身使用； 用is特殊特性和component内置组件标签时使用； keep-alive内置组件标签中include和exclude属性中使用。 说下$attrs和$listeners的使用场景？$attrs: 包含了父作用域中（组件标签）不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。 在创建基础组件时候经常使用，可以和组件选项inheritAttrs:false和配合使用在组件内部标签上用v-bind=&quot;$attrs&quot;将非prop特性绑定上去； $listeners: 包含了父作用域中（组件标签）的 (不含.native) v-on 事件监听器。 在组件上监听一些特定的事件，比如focus事件时，如果组件的根元素不是表单元素的，则监听不到，那么可以用v-on=&quot;$listeners&quot;绑定到表单元素标签上解决。 EventBus注册在全局上时，路由切换时会重复触发事件，如何解决呢？在有使用$on的组件中要在beforeDestroy钩子函数中用$off销毁。 Vue组件里写的原生addEventListeners监听事件，要手动去销毁吗？为什么？要，不然会造成多次绑定和内存泄露。 Vue组件里的定时器要怎么销毁？ 如果页面上有很多定时器，可以在data选项中创建一个对象timer，给每个定时器取个名字一一映射在对象timer中，在beforeDestroy构造函数中for(let k in this.timer)&#123;clearInterval(k)&#125;； 如果页面只有单个定时器，可以这么做。 1234const timer = setInterval(() =&gt;&#123;&#125;, 500);this.$once(&#x27;hook:beforeDestroy&#x27;, () =&gt; &#123; clearInterval(timer);&#125;) Vue中能监听到数组变化的方法有哪些？为什么这些方法能监听到呢？ push()、pop()、shift()、unshift()、splice()、sort()、reverse()，这些方法在Vue中被重新定义了，故可以监听到数组变化； filter()、concat()、slice()，这些方法会返回一个新数组，也可以监听到数组的变化。 在Vue中哪些数组变化无法监听，为什么，怎么解决？ 利用索引直接设置一个数组项时； 修改数组的长度时。 第一个情况，利用已有索引直接设置一个数组项时Object.defineProperty()是可以监听到，利用不存在的索引直接设置一个数组项时Object.defineProperty()是不可以监听到，但是官方给出的解释是由于JavaScript的限制，Vue不能检测以上数组的变动，其实根本原因是性能问题，性能代价和获得的用户体验收益不成正比。 第二个情况，原因是Object.defineProperty()不能监听到数组的length属性。 用this.$set(this.items, indexOfItem, newValue)或this.items.splice(indexOfItem, 1, newValue)来解决第一种情况； 用this.items.splice(newLength)来解决第二种情况。 在Vue中哪些对象变化无法监听，为什么，怎么解决？ 对象属性的添加 对象属性的删除 因为Vue是通过Object.defineProperty来将对象的key转成getter/setter的形式来追踪变化，但getter/setter只能追踪一个数据是否被修改，无法追踪新增属性和删除属性，所以才会导致上面对象变化无法监听。 用this.$set(this.obj,&quot;key&quot;,&quot;newValue&quot;)来解决第一种情况； 用Object.assign来解决第二种情况。 删除对象用delete和Vue.delete有什么区别？ delete：只是被删除对象成员变为&#39; &#39;或undefined，其他元素键值不变； Vue.delete：直接删了对象成员，如果对象是响应式的，确保删除能触发更新视图，这个方法主要用于避开 Vue 不能检测到属性被删除的限制。 &lt;template&gt;&lt;/template&gt;有什么用？当做一个不可见的包裹元素，减少不必要的DOM元素，整个结构会更加清晰。 Vue怎么定义全局方法有三种 挂载在Vue的prototype上 123456789// base.jsconst install = function (Vue, opts) &#123; Vue.prototype.demo = function () &#123; console.log(&#x27;我已经在Vue原型链上&#x27;) &#125;&#125;export default &#123; install&#125; 1234//main.js//注册全局函数import base from &#x27;service/base&#x27;;Vue.use(base); 利用全局混入mixin 用this.$root.$on绑定方法，用this.$root.$off解绑方法，用this.$root.$emit全局调用。 12345this.$root.$on(&#x27;demo&#x27;,function()&#123; console.log(&#x27;test&#x27;)&#125;)this.$root.$emit(&#x27;demo&#x27;)this.$root.$off(&#x27;demo&#x27;) Vue怎么改变插入模板的分隔符？用delimiters选项,其默认是[&quot;&#123;&#123;\", \"&#125;&#125;&quot;] 1234// 将分隔符变成ES6模板字符串的风格new Vue(&#123; delimiters: [&#x27;$&#123;&#x27;, &#x27;&#125;&#x27;]&#125;) Vue变量名如果以_、$开头的属性会发生什么问题？怎么访问到它们的值？以 _或 $ 开头的属性 不会 被 Vue 实例代理，因为它们可能和 Vue 内置的属性、API 方法冲突，你可以使用例如 vm.$data._property 的方式访问这些属性。 怎么捕获Vue组件的错误信息？errorCaptured是组件内部钩子，当捕获一个来自子孙组件的错误时被调用，接收error、vm、info三个参数，return false后可以阻止错误继续向上抛出。 errorHandler为全局钩子，使用Vue.config.errorHandler配置，接收参数与errorCaptured一致，2.6后可捕捉v-on与promise链的错误，可用于统一错误处理与错误兜底。 Vue.observable你有了解过吗？说说看让一个对象可响应。可以作为最小化的跨组件状态存储器。 Vue项目中如何配置favicon？ 静态配置 &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt;, 其中&lt;%= BASE_URL %&gt;等同vue.config.js中publicPath的配置; 动态配置 12&lt;link rel&#x3D;&quot;icon&quot; type&#x3D;&quot;image&#x2F;png&quot; href&#x3D;&quot;&quot;&gt;1 123456789import browserImg from &#39;images&#x2F;kong.png&#39;;&#x2F;&#x2F;为favicon的默认图片const imgurl &#x3D;&#39;后端传回来的favicon.ico的线上地址&#39;let link &#x3D; document.querySelector(&#39;link[type&#x3D;&quot;image&#x2F;png&quot;]&#39;);if (imgurl) &#123; link.setAttribute(&#39;href&#39;, imgurl);&#125; else &#123; link.setAttribute(&#39;href&#39;, browserImg);&#125;12345678 怎么修改Vue项目打包后生成文件路径？ 在Vue CLI2中修改config/index.js文件中的build.assetsPublicPath的值； 在Vue CLI3中配置publicPath的值。 怎么解决Vue项目打包后静态资源图片失效的问题？在项目中一般通过配置alias路径别名的方式解决,下面是Vue CLI3的配置。 123456789101112configureWebpack: &#123; resolve: &#123; extensions: [&#39;.js&#39;, &#39;.vue&#39;, &#39;.json&#39;], alias: &#123; &#39;@&#39;: resolve(&#39;src&#39;), &#39;assets&#39;: resolve(&#39;src&#x2F;assets&#39;), &#39;css&#39;: resolve(&#39;src&#x2F;assets&#x2F;css&#39;), &#39;images&#39;: resolve(&#39;src&#x2F;assets&#x2F;images&#39;), &#125; &#125;,&#125;,1234567891011 怎么解决Vue中动态设置img的src不生效的问题？因为动态添加src被当做静态资源处理了，没有进行编译，所以要加上require。 12345678910111213&lt;template&gt; &lt;img class&#x3D;&quot;logo&quot; :src&#x3D;&quot;logo&quot; alt&#x3D;&quot;公司logo&quot;&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; logo:require(&quot;assets&#x2F;images&#x2F;logo.png&quot;), &#125;; &#125;&#125;;&lt;&#x2F;script&gt;123456789101112 在Vue项目中如何引入第三方库（比如jQuery）？有哪些方法可以做到？先在主入口页面 index.html 中用 script 标签引入&lt;script src=&quot;./static/jquery-1.12.4.js&quot;&gt;&lt;/script&gt;,如果你的项目中有用ESLint检测，会报&#39;$&#39; is not defined，要在文件中加上/* eslint-disable */ 先在主入口页面 index.html 中用 script 标签引入&lt;script src=&quot;./static/jquery-1.12.4.js&quot;&gt;&lt;/script&gt;,然后在webpack 中配置一个 externals，即可在项目中使用。 123456export default &#123; // ... externals: &#123; &#x27;jquery&#x27;: &#x27;jQuery&#x27; &#125;&#125; 先在webpack中配置alias，最后在main.js中用import $ from &#39;jquery&#39;，即可在项目中使用。 12345678910export default &#123; // ... resolve: &#123; extensions: [&#x27;.js&#x27;, &#x27;.vue&#x27;, &#x27;.json&#x27;], alias: &#123; &#x27;@&#x27;: resolve(&#x27;src&#x27;), &#x27;jquery&#x27;: resolve(&#x27;static/jquery-1.12.4.js&#x27;) &#125; &#125;&#125; 在webpack中新增一个plugins，即可在项目中使用 12345678910export default &#123; // ... plugins: [ new webpack.ProvidePlugin(&#123; $:&quot;jquery&quot;, jQuery:&quot;jquery&quot;, &quot;windows.jQuery&quot;:&quot;jquery&quot; &#125;) ]&#125; 说说你对SPA单页面的理解，它的优缺点分别是什么？是一种只需要将单个页面加载到服务器之中的web应用程序。当浏览器向服务器发出第一个请求时，服务器会返回一个index.html文件，它所需的js，css等会在显示时统一加载，部分页面按需加载。url地址变化时不会向服务器在请求页面，通过路由才实现页面切换。 优点： 良好的交互体验，用户不需要重新刷新页面，获取数据也是通过Ajax异步获取，页面显示流畅； 良好的前后端工作分离模式。 缺点： SEO难度较高，由于所有的内容都在一个页面中动态替换显示，所以在SEO上其有着天然的弱势。 首屏加载过慢（初次加载耗时多） SPA单页面的实现方式有哪些？ 在hash模式中，在window上监听hashchange事件（地址栏中hash变化触发）驱动界面变化； 在history模式中，在window上监听popstate事件（浏览器的前进或后退按钮的点击触发）驱动界面变化，监听a链接点击事件用history.pushState、history.replaceState方法驱动界面变化； 直接在界面用显示隐藏事件驱动界面变化。 说说你对Object.defineProperty的理解 Object.defineProperty(obj,prop,descriptor)方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 obj：要在其上定义属性的对象。 prop：要定义或修改的属性的名称。 descriptor：将被定义或修改的属性描述符。 descriptor属性描述符主要有两种形式：数据描述符和存取描述符。 描述符必须是这两种形式之一；不能同时是两者。 数据描述符和存取描述符共同拥有 configurable：特性表示对象的属性是否可以被删除，以及除value和writable特性外的其他特性是否可以被修改。默认为false。 enumerable：当该属性的enumerable为true时，该属性才可以在for…in循环和Object.keys()中被枚举。默认为false。 数据描述符 value：该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为undefined。 writable：当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为false。 存取描述符 get：一个给属性提供 getter的方法，如果没有getter则为undefined。当访问该属性时，该方法会被执行，方法执行时没有参数传入，但是会传入this对象（由于继承关系，这里的this并不一定是定义该属性的对象）。默认为undefined。 set：一个给属性提供 setter的方法，如果没有setter则为undefined。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。默认为undefined。 定义descriptor时，最好先把这些属性都定义清楚，防止被继承和继承时出错。 1234567891011121314151617181920function Archiver() &#123; var temperature = null; var archive = []; Object.defineProperty(this, &#x27;temperature&#x27;, &#123; get: function() &#123; console.log(&#x27;get!&#x27;); return temperature; &#125;, set: function(value) &#123; temperature = value; archive.push(&#123; val: temperature &#125;); &#125; &#125;); this.getArchive = function() &#123; return archive; &#125;;&#125;var arc = new Archiver();arc.temperature; // &#x27;get!&#x27;arc.temperature = 11;arc.temperature = 13;arc.getArchive(); // [&#123; val: 11 &#125;, &#123; val: 13 &#125;] 说说你对Proxy的理解官方定义：proxy对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。 通俗来说是在对目标对象的操作之前提供了拦截，对外界的操作进行过滤和修改某些操作的默认行为，可以不直接操作对象本身，而是通过操作对象的代理对象来间接来操作对象。 1let proxy = new Proxy(target, handler) target 是用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）; handler 一个对象，其属性是当执行一个操作时定义代理的行为的函数，也就是自定义的行为。 handle可以为&#123;&#125;，但是不能为null，否则会报错 Proxy 目前提供了 13 种可代理操作，比较常用的 handler.get(target,property,receiver)获取值拦截 handler.set(target,property,value,receiver)设置值拦截 handler.has(target,prop)in 操作符拦截 12345678910111213141516171819202122232425262728let obj = &#123; a : 1, b : 2&#125;let test = new Proxy(obj,&#123; get : function (target,property) &#123; return property in target ? target[property] : 0 &#125;, set : function (target,property,value) &#123; target[property] = 6; &#125;, has: function (target,prop)&#123; if(prop == &#x27;b&#x27;)&#123; target[prop] = 6; &#125; return prop in target; &#125;,&#125;)console.log(test.a); // 1console.log(test.c); // 0test.a = 3;console.log(test.a) // 6if(&#x27;b&#x27; in test)&#123; console.log(test) // Proxy &#123;a: 6, b: 6&#125;&#125; Object.defineProperty和Proxy的区别Object.defineProperty 不能监听到数组length属性的变化； 不能监听对象的添加； 只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。 Proxy 可以监听数组length属性的变化； 可以监听对象的添加； 可代理整个对象，不需要对对象进行遍历，极大提高性能； 多达13种的拦截远超Object.defineProperty只有get和set两种拦截。 Vue的模板语法用的是哪个web模板引擎的吗？说说你对这模板引擎的理解?采用的是Mustache的web模板引擎mustache.js 1234567891011&lt;script type=&quot;text/javascript&quot; src=&quot;./mustache.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var data = &#123; &quot;company&quot;: &quot;Apple&quot;, &#125; var tpl = &#x27;&lt;h1&gt;Hello &#123;&#123;company&#125;&#125;&lt;/h1&gt;&#x27;; var html = Mustache.render(tpl, data); console.log(html);&lt;/script&gt; 你认为Vue的核心是什么？Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统。 说说你对单向数据流和双向数据流的理解单向数据流是指数据只能从父级向子级传递数据，子级不能改变父级向子级传递的数据。 双向数据流是指数据从父级向子级传递数据，子级可以通过一些手段改变父级向子级传递的数据。 比如用v-model、.sync来实现双向数据流。 什么是虚拟DOM？虚拟DOM是将状态映射成视图的众多解决方案中的一种，其是通过状态生成一个虚拟节点树，然后使用虚拟节点树进行渲染生成真实DOM，在渲染之前，会使用新生成的虚拟节点树和上一次虚拟节点树进行对比，只渲染不同的部分。 Vue中如何实现一个虚拟DOM？说说你的思路首先要构建一个VNode的类，DOM元素上的所有属性在VNode类实例化出来的对象上都存在对应的属性。例如tag表示一个元素节点的名称，text表示一个文本节点的文本，chlidren表示子节点等。将VNode类实例化出来的对象进行分类，例如注释节点、文本节点、元素节点、组件节点、函数式节点、克隆节点。 然后通过编译将模板转成渲染函数render，执行渲染函数render，在其中创建不同类型的VNode类，最后整合就可以得到一个虚拟DOM（vnode）。 最后通过patch将vnode和oldVnode进行比较后，生成真实DOM。 Vue为什么要求组件模板只能有一个根元素？当前的virtualDOM差异和diff算法在很大程度上依赖于每个子组件总是只有一个根元素。 axios是什么？怎样使用它？怎么解决跨域的问题？axios 是一个基于 promise 的 HTTP 库，先封装在使用。 使用proxyTable配置解决跨域问题。 比如你要调用http://172.16.13.205:9011/getList这个接口 先在axios.create()配置baseURL增加标志 1234const service = axios.create(&#123; baseURL: &#x27;/api&#x27;,&#125;);service.get(getList, &#123;params:data&#125;); 然后在config/index.js文件中配置 1234567891011121314module.exports = &#123; devServe:&#123; proxyTable: &#123; &#x27;/api&#x27;: &#123; target: &#x27;http://172.16.13.205:9011&#x27;, // 设置你调用的接口域名和端口号 secure: false, changeOrigin: true,// 跨域 pathRewrite: &#123; &#x27;^/api&#x27;: &#x27;&#x27; // 去掉标志 &#125; &#125; &#125;, &#125;&#125; 配置后要重新npm run dev F12中看到请求是http://localhost:8080/api/getList，实际上请求是http://172.16.13.205:9011/getList。 如果想扩展某个现有的Vue组件时，怎么做呢？ 用mixins混入 用extends，比mixins先触发 用高阶组件HOC封装 vue-loader是什么？它有什么作用？vue-loader是一个webpack的loader，是一个模块转换器，用于把模块原内容按照需求转换成新内容。 它允许你以一种名为单文件组件 (SFCs)的格式撰写 Vue 组件。可以解析和转换 .vue 文件，提取出其中的逻辑代码 script、样式代码 style、以及 HTML 模版 template，再分别把它们交给对应的loader去处理。 你有使用过JSX吗？说说你对JSX的理解？JSX就是Javascript和XML结合的一种格式。React发明了JSX，利用HTML语法来创建虚拟DOM。当遇到&lt;，JSX就当HTML解析，遇到&#123;就当JavaScript解析。","categories":[{"name":"前端","slug":"前端","permalink":"https://wisiw.github.io.git/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"https://wisiw.github.io.git/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://wisiw.github.io.git/tags/Vue/"},{"name":"面试题","slug":"面试题","permalink":"https://wisiw.github.io.git/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"author":"不爽的麻雀"}],"categories":[{"name":"前端","slug":"前端","permalink":"https://wisiw.github.io.git/categories/%E5%89%8D%E7%AB%AF/"},{"name":"微服务","slug":"微服务","permalink":"https://wisiw.github.io.git/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"cli","slug":"cli","permalink":"https://wisiw.github.io.git/categories/cli/"},{"name":"react","slug":"react","permalink":"https://wisiw.github.io.git/categories/react/"},{"name":"React","slug":"React","permalink":"https://wisiw.github.io.git/categories/React/"},{"name":"前端架构","slug":"前端架构","permalink":"https://wisiw.github.io.git/categories/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/"},{"name":"后端","slug":"后端","permalink":"https://wisiw.github.io.git/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Angular","slug":"Angular","permalink":"https://wisiw.github.io.git/categories/Angular/"},{"name":"代码工具","slug":"代码工具","permalink":"https://wisiw.github.io.git/categories/%E4%BB%A3%E7%A0%81%E5%B7%A5%E5%85%B7/"},{"name":"axios","slug":"axios","permalink":"https://wisiw.github.io.git/categories/axios/"},{"name":"Vue","slug":"Vue","permalink":"https://wisiw.github.io.git/categories/Vue/"}],"tags":[{"name":"route","slug":"route","permalink":"https://wisiw.github.io.git/tags/route/"},{"name":"基础","slug":"基础","permalink":"https://wisiw.github.io.git/tags/%E5%9F%BA%E7%A1%80/"},{"name":"代码片段","slug":"代码片段","permalink":"https://wisiw.github.io.git/tags/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"},{"name":"组件","slug":"组件","permalink":"https://wisiw.github.io.git/tags/%E7%BB%84%E4%BB%B6/"},{"name":"前端组件化","slug":"前端组件化","permalink":"https://wisiw.github.io.git/tags/%E5%89%8D%E7%AB%AF%E7%BB%84%E4%BB%B6%E5%8C%96/"},{"name":"node","slug":"node","permalink":"https://wisiw.github.io.git/tags/node/"},{"name":"app","slug":"app","permalink":"https://wisiw.github.io.git/tags/app/"},{"name":"源码","slug":"源码","permalink":"https://wisiw.github.io.git/tags/%E6%BA%90%E7%A0%81/"},{"name":"backbone.js","slug":"backbone-js","permalink":"https://wisiw.github.io.git/tags/backbone-js/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://wisiw.github.io.git/tags/JavaScript/"},{"name":"架构","slug":"架构","permalink":"https://wisiw.github.io.git/tags/%E6%9E%B6%E6%9E%84/"},{"name":"前端工程化","slug":"前端工程化","permalink":"https://wisiw.github.io.git/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"原理","slug":"原理","permalink":"https://wisiw.github.io.git/tags/%E5%8E%9F%E7%90%86/"},{"name":"响应式","slug":"响应式","permalink":"https://wisiw.github.io.git/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"},{"name":"面试题","slug":"面试题","permalink":"https://wisiw.github.io.git/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"Vue","slug":"Vue","permalink":"https://wisiw.github.io.git/tags/Vue/"},{"name":"全局弹窗","slug":"全局弹窗","permalink":"https://wisiw.github.io.git/tags/%E5%85%A8%E5%B1%80%E5%BC%B9%E7%AA%97/"},{"name":"Node","slug":"Node","permalink":"https://wisiw.github.io.git/tags/Node/"},{"name":"npm","slug":"npm","permalink":"https://wisiw.github.io.git/tags/npm/"},{"name":"数据、算法","slug":"数据、算法","permalink":"https://wisiw.github.io.git/tags/%E6%95%B0%E6%8D%AE%E3%80%81%E7%AE%97%E6%B3%95/"},{"name":"数组实现包","slug":"数组实现包","permalink":"https://wisiw.github.io.git/tags/%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%8C%85/"},{"name":"Java","slug":"Java","permalink":"https://wisiw.github.io.git/tags/Java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://wisiw.github.io.git/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"数据结构","slug":"数据结构","permalink":"https://wisiw.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"技巧","slug":"技巧","permalink":"https://wisiw.github.io.git/tags/%E6%8A%80%E5%B7%A7/"},{"name":"数据库","slug":"数据库","permalink":"https://wisiw.github.io.git/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MyBatis-Plus","slug":"MyBatis-Plus","permalink":"https://wisiw.github.io.git/tags/MyBatis-Plus/"},{"name":"系统架构设计师考试","slug":"系统架构设计师考试","permalink":"https://wisiw.github.io.git/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%80%83%E8%AF%95/"},{"name":"第一章","slug":"第一章","permalink":"https://wisiw.github.io.git/tags/%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"name":"CSS","slug":"CSS","permalink":"https://wisiw.github.io.git/tags/CSS/"},{"name":"vuex","slug":"vuex","permalink":"https://wisiw.github.io.git/tags/vuex/"},{"name":"VueRouter","slug":"VueRouter","permalink":"https://wisiw.github.io.git/tags/VueRouter/"},{"name":"编程题","slug":"编程题","permalink":"https://wisiw.github.io.git/tags/%E7%BC%96%E7%A8%8B%E9%A2%98/"},{"name":"前端","slug":"前端","permalink":"https://wisiw.github.io.git/tags/%E5%89%8D%E7%AB%AF/"},{"name":"browser","slug":"browser","permalink":"https://wisiw.github.io.git/tags/browser/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://wisiw.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Flux","slug":"Flux","permalink":"https://wisiw.github.io.git/tags/Flux/"},{"name":"mybatis","slug":"mybatis","permalink":"https://wisiw.github.io.git/tags/mybatis/"},{"name":"工具","slug":"工具","permalink":"https://wisiw.github.io.git/tags/%E5%B7%A5%E5%85%B7/"},{"name":"微服务","slug":"微服务","permalink":"https://wisiw.github.io.git/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"教程","slug":"教程","permalink":"https://wisiw.github.io.git/tags/%E6%95%99%E7%A8%8B/"},{"name":"手写","slug":"手写","permalink":"https://wisiw.github.io.git/tags/%E6%89%8B%E5%86%99/"},{"name":"源码解析","slug":"源码解析","permalink":"https://wisiw.github.io.git/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"name":"AST语法树","slug":"AST语法树","permalink":"https://wisiw.github.io.git/tags/AST%E8%AF%AD%E6%B3%95%E6%A0%91/"},{"name":"模板解析","slug":"模板解析","permalink":"https://wisiw.github.io.git/tags/%E6%A8%A1%E6%9D%BF%E8%A7%A3%E6%9E%90/"},{"name":"cli","slug":"cli","permalink":"https://wisiw.github.io.git/tags/cli/"},{"name":"Webpack","slug":"Webpack","permalink":"https://wisiw.github.io.git/tags/Webpack/"},{"name":"react","slug":"react","permalink":"https://wisiw.github.io.git/tags/react/"},{"name":"《深入React技术栈》","slug":"《深入React技术栈》","permalink":"https://wisiw.github.io.git/tags/%E3%80%8A%E6%B7%B1%E5%85%A5React%E6%8A%80%E6%9C%AF%E6%A0%88%E3%80%8B/"},{"name":"读书笔记 - React - 《深入React技术栈》","slug":"读书笔记-React-《深入React技术栈》","permalink":"https://wisiw.github.io.git/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-React-%E3%80%8A%E6%B7%B1%E5%85%A5React%E6%8A%80%E6%9C%AF%E6%A0%88%E3%80%8B/"},{"name":"React","slug":"React","permalink":"https://wisiw.github.io.git/tags/React/"},{"name":"微前端","slug":"微前端","permalink":"https://wisiw.github.io.git/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"},{"name":"前端 - 架构","slug":"前端-架构","permalink":"https://wisiw.github.io.git/tags/%E5%89%8D%E7%AB%AF-%E6%9E%B6%E6%9E%84/"},{"name":"Echarts","slug":"Echarts","permalink":"https://wisiw.github.io.git/tags/Echarts/"},{"name":"Excel","slug":"Excel","permalink":"https://wisiw.github.io.git/tags/Excel/"},{"name":"前端架构","slug":"前端架构","permalink":"https://wisiw.github.io.git/tags/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/"},{"name":"Docker","slug":"Docker","permalink":"https://wisiw.github.io.git/tags/Docker/"},{"name":"后端","slug":"后端","permalink":"https://wisiw.github.io.git/tags/%E5%90%8E%E7%AB%AF/"},{"name":"Angular","slug":"Angular","permalink":"https://wisiw.github.io.git/tags/Angular/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://wisiw.github.io.git/tags/TypeScript/"},{"name":"使用","slug":"使用","permalink":"https://wisiw.github.io.git/tags/%E4%BD%BF%E7%94%A8/"},{"name":"linux","slug":"linux","permalink":"https://wisiw.github.io.git/tags/linux/"},{"name":"集群","slug":"集群","permalink":"https://wisiw.github.io.git/tags/%E9%9B%86%E7%BE%A4/"},{"name":"JavaScript - 设计模式","slug":"JavaScript-设计模式","permalink":"https://wisiw.github.io.git/tags/JavaScript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Nginx","slug":"Nginx","permalink":"https://wisiw.github.io.git/tags/Nginx/"},{"name":"代码工具","slug":"代码工具","permalink":"https://wisiw.github.io.git/tags/%E4%BB%A3%E7%A0%81%E5%B7%A5%E5%85%B7/"},{"name":"git","slug":"git","permalink":"https://wisiw.github.io.git/tags/git/"},{"name":"Promise","slug":"Promise","permalink":"https://wisiw.github.io.git/tags/Promise/"},{"name":"map","slug":"map","permalink":"https://wisiw.github.io.git/tags/map/"},{"name":"生命周期","slug":"生命周期","permalink":"https://wisiw.github.io.git/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"name":"axios","slug":"axios","permalink":"https://wisiw.github.io.git/tags/axios/"},{"name":"数据响应式","slug":"数据响应式","permalink":"https://wisiw.github.io.git/tags/%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/"},{"name":"虚拟DOM与diff算法","slug":"虚拟DOM与diff算法","permalink":"https://wisiw.github.io.git/tags/%E8%99%9A%E6%8B%9FDOM%E4%B8%8Ediff%E7%AE%97%E6%B3%95/"},{"name":"模板引擎","slug":"模板引擎","permalink":"https://wisiw.github.io.git/tags/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"},{"name":"算法","slug":"算法","permalink":"https://wisiw.github.io.git/tags/%E7%AE%97%E6%B3%95/"},{"name":"瀑布流","slug":"瀑布流","permalink":"https://wisiw.github.io.git/tags/%E7%80%91%E5%B8%83%E6%B5%81/"}]}